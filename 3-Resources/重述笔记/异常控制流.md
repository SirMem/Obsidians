---
Project: "[[4-Archives/Stopping/操作系统|操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-23
Connected: 
---

# 控制流
从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列
![[Pasted image 20240423200037.png]]
最简单的一种控制流是一个“平滑的＂序列，其中每个 I<sub>k</sub> 和 I<sub>k+1</sub>在 内存中都是相邻的

而异常的控制流是 I<sub>k</sub> 和 I<sub>k+1</sub>的执行不是连续的I<sub>k</sub> 和 I<sub>k+1</sub>执行顺序不相邻)通常是由诸如跳转、调用和返回这样一些熟悉的程序指令造成的。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关 。 比如， 一个硬件定时器定期产生信号，这个事件必须得到处理 。 包到达网络适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control Flow)

## 理解异常控制流的优点
理解 ECF 将帮助你理解重要的系统概念。
理解 ECF 将帮助你理解应用程序是如何与操作系统交互的 。
理解 ECF 将帮助你编写有趣的新应用程序。
理解 ECF 将帮助你理解并发。
理解 ECF 将帮助你理解软件异常如何工作。

# 异常
异常 (exception) 就是控制流中的突变，用来响应处理器状态中的某些变化。
![[eDqKLfGvNLCndwWt-33500228-67d7-ec6d-8234-86193f3a1a63.png|461]]

在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表 (exception table) 的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序 (exception handler)) 。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：
1) 处理程序将控制返回给当前指令 ICUH' 即当事件发生时正在执行的指令。
2) 处理程序将控制返回给I<sub>next</sub>, 如果没有发生异常将会执行的下一条指令。
3) 处理程序终止被中断的程序。
## 异常处理
系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号 (exception number) 。 其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的部分）的设计者分配的 
![[eDqKLfGvNLCndwWt-3c878fd9-48c7-0357-3bdf-83d7eb6d4976.png|433]]

### 异常表基址寄存器
异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器 ( exception table base register) 的特殊 CPU 寄存器里。
![[eDqKLfGvNLCndwWt-3b6c58e2-8ce5-c3a8-0c93-1b0d533a4b1b.png|645]]
### 异常处理过程
根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在当前指令后执行的指令）。

处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如， x86-64 系统会将包含当前条件码的 EFLAGS寄存器和其他内容压入栈中。

如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中 ， 而不是压到用户栈中。

异常处理程序运行在内核模式下
## 异步和同步
异步由I/O引发的异常
同步由CPU自身引发的异常
## 异常的类别
![[eDqKLfGvNLCndwWt-a07fa714-c6a9-b601-5cdd-1d8055f1306e.png|851]]

### 中断
中断是异步发生的， 是来自处理器外部的 I/0 设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的 。 硬件中断的异常处理程序常常称为中断处理程序 (interrupt handler) 。
![[Pasted image 20240423202706.png]]

### 陷阱(系统调用)
陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口， 叫做系统调用 。

用户程序经常需要向内核请求服务， 比如读一个文件 (read) 、创建一个新的进程(fork) 、 加载一个新的程序 (execve), 或者终止当前进程 (exit) 。

为了允许对这些内核服务的受控的访问，处理器提供了一条特殊的 "syscall n" 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。
![[Pasted image 20240423202733.png]]

### 故障
故障由错误情况引起，它可能能够被故障处理程序修正 。 当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort 例程， abort 例程会终止引起故障的应用程序。
![[Pasted image 20240423202753.png]]
### 终止
终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者SRAM 位被损坏时发生的奇偶错误 。
![[Pasted image 20240423202817.png]]


# 进程
## 进程提供的抽象
一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。

一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。
## 定义
进程的经典定义就是一个执行中程序的实例。

## 逻辑控制流
如果想用调试器单步执行程序，我们会看到一系列的程序计数器 (PC) 的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做逻辑控制流，或者简称逻辑流。

![[eDqKLfGvNLCndwWt-4916eb06-1266-a6ef-2462-1691d2d2ad33.png|439]]
考虑一个运行着 三个进程的系统，如图 8-12 所示 。 处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。
每个竖直的条表示一个进程的逻辑流的一部分。在这个例子中，三个逻辑流的执行是交错的 。 进程 A 运行了一会儿，然后是进程 B 开始运行到完成。然后，进程 C 运行了一会儿，进程 A 接着运行直到完成。最后，进程 C 可以运行到结束了。

### 并发流
一个逻辑流的执行在时间上与另一个流重叠，称为并发流 (concurrent flow) , 这两个流被称为并发地运行。

更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y 开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始 。

例如，图 8-12 中，进程 A 和 B并发地运行， A 和 C 也一样。另一方面， B 和 C 没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行 。

多个流并发地执行的一般现象被称为并发(concurrency) 。 一个进程和其他进程轮流运行的概念称为多任务(multitasking) 。 一个进程执行它的控制流的一部分的每一时间段叫做时间片 (time slice) 。因此，多任务也叫做时间分片 (time slicing) 。例如，图 8-12 中，进程 A 的流由两个时间片组成。

### 并行流
并行流是并发流的一个真子集 。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流(parallel flow) , 它们并行地运行(running in parallel) , 且并行地执行 (parallel execution) 。

## 私有地址空间
进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。进程为每个程序提供它自己的私有地址空间。一般而言 ，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。

地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000 开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。

地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代
码、数据和栈。

![[eDqKLfGvNLCndwWt-96b5fe88-8162-18d2-5080-aadca01bdb2b.png|551]]

# 用户态和内核态
为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

处理器通常是用某个控制寄存器中的一个模式位 (mode bit) 来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。

没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction), 比如停止处理器、改变模式位，或者发起一个 I/O 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。

## 上下文切换
操作系统内核使用一种称为上下文切换(context switch) 的较高层形式的异常控制流来实现多任务。

上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。

在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度 (scheduling), 是由内核中称为调度器 (scheduler) 的代码处理的。当内核选择一个新的进程运行时，我们说内核调度了这个进程。

在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换 1)保存当前进程的上下文， 2)恢复某个先前被抢占的进程被保存的上下文， 3)将控制传递给这个新恢复的进程 。

![[eDqKLfGvNLCndwWt-8859982d-f7b6-3a07-ef0b-53cfb78e6d46.png|690]]
# 进程控制
## 获取进程ID
每个进程都有一个唯一的正数（非零）进程ID(PID) 。 getp过函数返回调用进程的 PID。getppid 函数返回它的父进程的 PID(创建调用进程的进程）。
```c
pid_t getpid(void);
pid_t getppid(void);
```

getpid 和 getppid 函数返回一个类型为 pid t 的整数值，在 Linux 系统上它在types.h 中被定义为 int 。

## 创建,终止,回收,收回进程
从程序员的角度，我们可以认为进程总是处于下面三种状态之一：
- 运行。进程要么在 CPU 上执行，要么在等待被执行且最终会被内核调度。
- 停止。进程的执行被挂起 (suspended), 且不会被调度。当收到 SIGSTOP 、 SIGT­STP 、 SIGTTIN 或者 SIGTTOU 信号时，进程就停止， 并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。 
- 终止 。 进程永远地停止了 。 进程会因为三种原因终止： 1) 收到一个信号，该信号的默认行为是终止进程， 2)从主程序返回， 3) 调用 exit 函数。
### 终止(exit)
```c
#include <stdlib.h>
void exit(int status);
exit 函数以 status 退出状态来终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。
```

### 创建(Fork)
```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在千它们有不同的 PID。

fork只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中， fork 返回子进程的 PID。在子进程中， fork 返回 0 。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。
```c
int main()
{
	int x = 1; 

	if (fork() == 0)
		printf("p1 : x=%d\n", ++x);
	printf("p2 : x x=%d\n", --x);
	exit(0);
}
```

---
```c 

int main()
{
	pid_t pid;
	int x = 1;

	pid = Fork();
	if(pid == 0)
	{
		printf("child: x=%d\n", ++x);
		exit(0);
	}

	/*Parent*/
	printf("parent: x=%d\n", --x);
	exit(0);
}
```
![[eDqKLfGvNLCndwWt-61d1fd05-7072-a954-41d8-30da6321458e.png|425]]

linux> ./fork
parent: x=0
child: x=2

#### fork的微妙之处
- 调用一次，返回两次。 fork 函数被父进程调用一次，但是却返回两次一一次是返回到父进程，一次是返回到新创建的子进程。对千只创建一个子进程的程序来说，这还是相当简单直接的。但是具有多个 fork 实例的程序可能就会令人迷惑，需要仔细地推敲了。
- 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的printf 语句，然后是子进程。
- 相同但是独立的地址空间。如果能够在 fork 函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变最值、相同的堆、相同的全局变量值，以及相同的代码。。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对 x 所做的任何改变都是独立的，不会反映在另一个进程的内存中。这就是为什么当父进程和子进程调用它们各自的 print£ 语句时，它们中的变量 x 会有不同的值。
- 共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用 fork 时，stdout 文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。

### 回收子进程
当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收 (reaped) 。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃己终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程(zombie) 。
#### waitpid
```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
```

返回：如果成功，则为子进程的 PID, 如果 WNOHANG, 则为 0, 如果其他错误，则为 -1,


waitpid函数有点复杂。默认情况下（当 options=0 时）， waitpid 挂起调用进程的执行，直到它的等待集合(wait set) 中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中， waitpid 返回导致 waitpid 返回的已终止子进程的 PID。此时，已终止的子进程巳经被回收，内核会从系统中删除掉它的所有痕迹。

- 判定等待集合的成员
	- 等待集合的成员是由参数 pid 来确定的：
	- 如果 pid>0, 那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。
	- 如果 pid= -1, 那么等待集合就是由父进程所有的子进程组成的。


- 修改默认行为 
	- ![[eDqKLfGvNLCndwWt-6c9fc169-cea8-7e86-807a-a118f6acc433.png|855]]
- 检查已回收子进程的退出状态
	- ![[eDqKLfGvNLCndwWt-c485e353-bc05-ea67-83af-4e0dd358adfd.png|865]]


### 加载并运行程序(execve)
execve 函数在当前进程的上下文中加载并运行一个新程序。
```c
#include <unistd.h>

int execve(const char *filename, const char *argv[], const char *envp[]);
```

execve 函数加载并运行可执行目标文件 filename, 且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，例如找不到 filename, execve 才会返回到调用程序。所以，与 fork 一次调用返回两次不同， execve 调用一次并从不返回。

argv 变量指向一个以 null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例， argv [0] 是可执行目标文件的名字。环境变量的列表是由一个类似的数据结构表示的。 envp 变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变昼字符串，每个串都是形如"name=value" 的名字－值对。

![[eDqKLfGvNLCndwWt-d7050c7e-8f60-d01e-2eb3-25dce820b06f.png|638]]

当 main 开始执行时，用户栈的组织结构如图 8-22 所示。。首先是参数和环境字符串。栈往上紧随其后的是以 null 结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变最 environ 指向这些指针中的第一个 envp[0] 。紧随环境变量数组之后的是以 null 结尾的 argv[] 数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数 libc_start_main的栈帧。

![[eDqKLfGvNLCndwWt-d8062c64-31d2-ff9d-b5be-f146573f5bda.png|706]]

main 函数有 3 个参数： 1) argc, 它给出 argv[ ]数组中非空指针的数量， 2) argv,指向 argv[ ]数组中的第一个条目， 3)envp, 指向 envp[] 数组中的第一个条目。

![[eDqKLfGvNLCndwWt-c1da1532-ea30-1cc7-1ff9-54b86474e265.png|874]]


### 程序与进程
程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实例；程序总是运行在某个进程的上下文中。

fork 函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品 。

execve 函数在当前进程的上下文中加栽并运行一个新的程序 。 它会覆盖当前进程的地址空间，但并没有创建一个新进程 。 新的程序仍然有相同的 PID, 并且继承了调用 execve 函数时已打开的所有文件描述符 。
# 信号
一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。

每种信号类型都对应千某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

比如，如果一个进程试图除以 0, 那么内核就发送给它一个 SIGFPE 信号（号码 8) 。如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号（号码 4) 。

![[eDqKLfGvNLCndwWt-3fb68813-0078-72e3-f23e-02834000e1ec.png|793]]

## 信号术语
### 发送信号
内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程 。

Unix 系统提供了大量向进程发送信号的机制 。 所有这些机制都是基于进程组 (process group) 这个概念的。


#### 进程组
每个进程都只属千一个进程组，进程组是由一个正整数进程组 ID 来标识的 。 getpgrp函数返回当前进程的进程组 ID
```c
#include <unistd.h>

pit_t getpgrp(void);
```
返回：调用进程的进程组 ID

默认地，一个子进程和它的父进程同属千一个进程组。一个进程可以通过使用 set­pgid 函数来改变自己或者其他进程的进程组：
```c
#include <unistd.h>

int set­pgid(pid_t pid, pit_t pgid);
```

返回：若成功则为 0, 若错误则为 -1 。

setpgid 函数将进程 pid 的进程组改为 pgid 。 如果 pid 是 0, 那么就使用当前进程的 PID 。 如果 pgid是 0, 那么就用 pid指定的进程的 PID 作为进程组 ID。

#### /bin/kill程序发送信号
如/bin/kill -9 15213发送信号 9(SIGKILL) 给进程 15213 。

一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。
linux> /bin/kill -9 -15213
发送一个 SIGKILL 信号给进程组 15213 中的每个进程。

#### 键盘发送信号
Unix shell 使用作业 (job) 这个抽象概念来表示为对一条命令行求值而创建的进程 。 在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。

linux> ls / sort

会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。 

shell 为每个作业创建一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。

比如，图 8-28 展示了有一个前台作业和两个后台作业的 shell 。前台作业中的父进程 PID 为 20, 进程组 ID 也为 20。父进程创建两个子进程，每个也都是进程组 20 的成员。

![[eDqKLfGvNLCndwWt-1891373d-7c8b-ba22-f29e-58786d141e4e.png|670]]

##### Ctrl + C
导致内核发送一个 SIGINT 信号到前台进程组中的每个进
程。默认情况下，结果是终止前台作业。

##### Ctrl + Z
发送一个 SIGTSTP 信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。
#### Kill函数
```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```
进程通过调用 kill 函数发送信号给其他进程

返回: 若成功则为 0, 若错误则为一 1,

如果 p过大于零，那么 k过1 函数发送信号号码 sig 给进程 pid。如果 pid 等于零，那么k过1 发送信号 sig 给调用进程所在进程组中的每个进程，包括调用进程自己。如果 pid小于零， Kill 发送信号 sig 给进程组 pid (pid的绝对值）中的每个进程 。

#### alarm函数
```c
#include <unistd.h>

unsigned int alarm(unsigne int secs);
```

返回:前一次闹钟剩余的秒数，若以前没有设定闹钟，则为 0

alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程。如果 secs是零，那么不会调度安排新的闹钟 (alarm) 。
### 接受信号
当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序 (signal handler) 的用户层函数捕获这个信号。分别有
- 进程终止 
- 进程终止并转储内存
- 进程停止(挂起)直到被SIGCONT信号重启
- 进程忽略该信号

![[eDqKLfGvNLCndwWt-c95b09a5-6422-bb04-02eb-d12c57855ebd.png|553]]

#### signal
```c
#include <signal.h>
typedef void(*sighandler_t)(int)

sighandler_t signal(int signum, sighandler_t handler);//前者为信号名字，后者为处理函数，也可以是信号
```

返回: 若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR ( 不设置 errno ) 。

signal 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：
- 如果 handler 是 SIG_IGN, 那么忽略类型为 signum 的信号。
- 如果 handler 是 SIG_DFL, 那么类型为 signum 的信号行为恢复为默认行为 。
- 否则， handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signurn 的信号，就会调用这个程序 。 通过把处理程序的地址传递到 signal 函数从而改变默认行为，这叫做设置信号处理程序 (installing the handler) 。 调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。

#### 信号嵌套
信号处理程序也可以被其他信息处理程序中断
![[eDqKLfGvNLCndwWt-927647fe-e0eb-8d6f-6358-fb1cdca89752.png|778]]

### 阻塞和解除阻塞信号
Linux 提供阻塞信号的隐式和显式的机制：

隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。例如，图 8-31 中，假设程序捕获了信号 s, 当前正在运行处理程序 S。如果发送给该进程另一个信号 s, 那么直到处理程序 S 返回， s 会变成待处理而没有被接收。

显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

#### Sigset_t类型
`   sigset_t` 是一个用于存储信号集的数据类型，它可以表示一组信号。比如阻塞，挂起等等

#### 阻塞
"blocked" 位向量是用来表示进程当前阻塞（或屏蔽）哪些信号的一种数据结构。

这个位向量通常由一系列比特位组成，每个比特位代表一个特定的信号。当某个信号的对应比特位被设置为 1 时，表示该信号被阻塞了；当比特位为 0 时，表示该信号没有被阻塞，即允许该信号被处理。

当进程处于阻塞某些信号的状态时，即使收到这些信号，也不会立即处理它们，直到这些信号被解除阻塞为止。因此，"blocked" 位向量的作用就是为了控制进程对信号的响应。

这种位向量通常会在操作系统内核中维护，并且可以通过系统调用来设置或者查询进程的信号阻塞状态。

#### Linux阻塞接口
```c
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);//阻塞
int sigemptyset(sigset_t *set);//清空位向量
int sigfillset(sigset_t *set);//将所有信号添加至位向量
int sigaddset(sigset_t *set, int signum); //添加一个信号到位向量
int sigdelset(sigset_t *set, int signum);//删除一个位向量的信号

int sigismember(const sigset_t &set, int signum); //判断信号是否存在与位向量
```

使用下述函数对 set 信号集合进行操作： sigemptyset 初始化 set 为空集合。 sigfillset函数把每个信号都添加到 set 中。 sigaddset 函数把 signum 添加到 set, sigdelset 从 set 中删除 signum, 如果 signum 是 set 的成员，那么 sigismember 返回 1, 否则返回 0 。

sigprocmask 函数改变当前阻塞的信号集合。具体的行为依赖于 how 的值
SIG_BLOCK: 把 set 中的信号添加到 blocked 中(blocked=blocked I set) 。
SIG_ UNBLOCK: 从 blocked 中删除 set 中的信号(blocked=blocked &set) 。
SIG_SETMASK: block=set 。
如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。

如
```c
sigset_t mask, prev_mask;

Sigemptyset(&mask);
Sigaddset(&mask, SIGINT);

//阻塞信号，保存之前Block位向量 
Sigprocmask(SIG_BLOCK, &mask, &prev_mask);

//恢复之前的Block位向量，解除信号SIGINT阻塞 
Sigprocmask(SIG_UNBLOCK, &prev_mask, NULL);
```

### Sigset_t挂起位向量
除此之外还有挂起的信号集函数，通常用pending位向量代表
```c
Sigpeeding(const sigset_t *set);
```
# 编写信号处理程序
信号处理是 Linux 系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析： 1)处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰； 2) 如何以及何时接收信号的规则常常有违人的直觉； 3) 不同的系统有不同的信号处理语义。

## 安全的信号处理
信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行，正如我们在图 8-31 中看到的那样 。 如果处理程序和主程序并发地访问同样的全局数据结构，那么结果可能就不可预知，而且经常是致命的 。

### G0
处理程序要尽可能简单 。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志 。

### G1
在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数（或简称安全的函数）能够被信号处理程序安全地调用，原因有二 ： 要么它是可重入的（例如只访问局部变量，见 12. 7. 2 节）， 要么它不能被信号处理程序中断。图 8-33 列出了 Linux 保证安全的系统级函数。注意，许多常见的函数（例如 printf、 sprin七f 、 malloc 和 exit)都不在此列 。

![[eDqKLfGvNLCndwWt-f893a752-c227-76ad-3a10-826b45a48dc3.png|752]]

### SIO(Safe I/O)包输出
信号处理程序中产生输出唯一安全的方法是使用 write 函数（见 10. 1 节）。特别地，
调用 printf 或 sprintf 是不安全的。为了绕开这个不幸的限制，我们开发一些安全的函
数，称为 SIO(安全的 I/0)包，可以用来在信号处理程序中打印简单的消息。

```c
#include "csapp.h"

ssize_t sio_put1(long v);
ssize_t sio_puts(char s[]);
返回:如果成功则为传送的字节数，如果出错，则为-1
void sio_error(char s[]);
```

sio_putl 和 sio_puts 函数分别向标准输出传送一个 long 类型数和一个字符串。sio_error 函数打印一条错误消息并终止。

```c
ssize_t sio_puts(char s[]) /*Put string*/
{
	return write(STDOUT_FILENO, s, sio_strlen(s));
}

ssize_t sio_putl(long v)/*Put long*/
{
	char s[128];

	sio_ltoa(v, s, 10); /*Base on K&R itoa()*/
	return sio_puts(s);
}

void sio_error(char s[]) /*Put error message and exit*/
{
	sio_puts(s);
	_exit(1);
}


```

### G2
保存和恢复 errno。许多 Linux 异步信号安全的函数都会在出错返回时设置errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于 errno 的部分。解决方法是在进入处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用`_exit`终止该进程，那么就不需要这样做了。

### G3
阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问（读或者写）该数据结构时，你的处理程序和主程序应该暂时阻塞所有的信号。
这条规则的原因是从主程序访问一个数据结构 d 通常需要一系列的指令，如果指令序列被访问 d 的处理程序中断，那么处理程序可能会发现 d 的状态不一致，得到不可预知的结果。在访问 d 时暂时阻塞信号保证了处理程序不会中断该指令序列。

### G4
用 volatile 声明全局变量。考虑一个处理程序和一个 main 函数，它们共享一个全局变量 g。处理程序更新 g, main 周期性地读 g。对于一个优化编译器而言， main 中 g的值看上去从来没有变化过，因此使用缓存在寄存器中 g 的副本来满足对 g 的每次引用是很安全的。如果这样， main 函数可能永远都无法看到处理程序更新过的值。

可以用 volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。 例如：volatile int g;

volatile 限定符强迫编译器每次在代码中引用 g 时，都要从内存中读取 g 的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。

### G5
用 sig_atormic_t 声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志， C 提供一种整型数据类型 sig_atormic_t, 对它的读和写保证会是原子的（不可中断的），因为可以用一条指令来实现它们：volatile sig_atomic_t flag;

因为它们是不可中断的，所以可以安全地读和写  sig_atormic_t 变量，而不需要暂时阻塞信号。注意，这里对原子性的保证只适用于单个的读和写，不适用于像flag++ 或 flag=flag+10这样的更新，它们可能需要多条指令。

## 正确的信号处理
![|100%](ziyunote-20240425_212743.jpg)[00:58:13](ziyunote://play?path=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Pm4y1P7XP%3Fp%3D16%26vd_source%3D8b450300cfa6415cb0312754cf65ba30&time=00:58:13)
信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。

因此，如果两个类型 k 的信号发送给一个目的进程，而因为目的进程当前正在执行信号 k 的处理程序，所以信号 k 被阻塞了，那么第二个信号就简单地被丢弃了；它不会排队。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了 。

要了解这样会如何影 响正确性，来看一个简单的应用。基本的结构是父进程创建一些子进程 ， 这些子进程各自 独立运行一段时间， 然后终止。父进程必须回收子进程以避免在系统中留下僵死进程 。 但是我们还希望父进程能够在子进程运行时自 由地去做其 他 的 工 作 。 所以，我们决定用SIGCHLD 处理程序来回收子进程 ， 而不是显式地等待子进程终止 。（只要有一个子进程终止或者停止，内核就会发送一个 SIGCHLD 信号给父进程 。 )

```c
/*WARNING: This code is buggy!这个程序是有缺陷的，因为它假设信号是排队的 */ 

void handler1(int sig)
{
	int olderrno = errno;

	if((waitpid(-1, NULL , 0)) < 0)
		sio_error("waitpid error");
	Sio_puts("Handler reaped child\n");
	Sheep(1);
	errno = olderrno;
}

int main()
{
	int i, n;
	char buf[MAXBUF];

	if(signal(SIGCHLD, handler1) == SIG_ERR)
		unix_error("signal error");

	/* Parent creates children */
	for(i = 0; i < 3; i++){
		if(Fork() == 0){
			printf("hello from child %d\n", (int)getpid());
			exit(0);
		}
	}

	/*Parent waits for terminal inpu and then processes it */
	if((n = read(STDIN_FILENO, buf, sizeof(buf))) < 0)
		unix_error("read");

	printf("Parent processing input\n");
	while(1);

	exit(0);
}
```

父进程设置 了 一个 SIGCHLD 处理程序 ， 然后创建了 3 个子进程。同时，父进程等待来自终端的一个输入行，随后处理它。这个处理被模型化为一个无限循环。当每个子进程终止时，内核通过发送一个 SIGCHLD 信号通知父进
程。父进程捕获这个 SIGCHLD 信号，回收一个子进程，做一些其他的清理工作（模型化为 sleep 语句），然后返回。

然而，当在 Linux 系统上运行它时，我们得到如下输出：

```linux
Hello from child 14073
Hello from child 14074
Hello from child 14075
Handler reaped child
Handler reaped child
CR
Parent processing input
```

从输出中我们注意到，尽管发送了 3 个 SIGCHLD 信号给父进程，但是其中只有两个信号被接收了，因此父进程只是回收了两个子进程。如果挂起父进程，我们看到，实际上子进程14075 没有被回收，它成了一个僵死进程

哪里出错了呢？问题就在于我们的代码没有解决信号不会排队等待这样的情况。所发生的情况是：父进程接收并捕获了第一个信号。当处理程序还在处理第一个信号时，第二个信号就传送并添加到了待处理信号集合里。然而，因为 SIGCHLD 信号被 SIGCHLD 处理程序阻塞了，所以第二个信号就不会被接收。此后不久，就在处理程序还在处理第一个信号时，第三个信号到达了。因为已经有了一个待处理的 SIGCHLD, 第三个 SIGCHLD信号会被丢弃。一段时间之后，处理程序返回，内核注意到有一个待处理的 SIGCHLD 信号，就迫使父进程接收这个信号。父进程捕获这个信号，并第二次执行处理程序。在处理程序完成对第二个信号的处理之后，已经没有待处理的 SIGCHLD 信号了，而且也绝不会再有，因为第三个 SIGCHLD 的所有信息都已经丢失了。由此得到的重要教训是，不可以用信号未对其他进程中发生的事件计数。

为了修正这个问题，我们必须回想一下，存在一个待处理的信号只是暗示自进程最后一次收到一个信号以来，至少巳经有一个这种类型的信号被发送了。所以我们必须修改
SIGCHLD 的处理程序，使得每次 SIGCHLD 处理程序被调用时，回收尽可能多的僵死子进程。

```c
void handler2(int sig)
{
	int olderrno = errno;

	while (waitpid(-1, NULL, 0) > 0){
		Sio_puts("Handler reaped child\n");
	}

	if(errno != ECHILD)
		Sio_error("waitpid error");
	Sleep(1);
	errno = olderrno;
}

```

## 可移植的信号处理
Posix 标准定义了 sigaction 函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。


```c
#include <signal.h>

int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);
```

返回 : 成功为0，失败为-1

`sigaction`函数用于设置和检索信号处理程序。它允许您指定对特定信号的处理方式，包括捕获、忽略或使用默认处理程序。

1. **包含头文件**：确保您的代码中包含了 `<signal.h>` 头文件。
    
2. **定义信号处理函数**：首先，您需要编写一个函数来处理信号。这个函数的原型应该是 `void handler(int signal_number)`，其中`signal_number`是接收到的信号的编号。
    
3. **设置信号处理程序**：使用`sigaction`函数来设置信号处理程序。您将设置要捕获的信号，以及对应的处理函数。
    
4. **使用`struct sigaction`结构**：`sigaction`函数使用`struct sigaction`类型的结构来指定信号的处理方式。

此函数和signal函数类似

