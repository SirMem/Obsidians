---
Project: "[[排序]]"
Status: 🟩
tags:
  - Resources
Deadline: 2024-03-18
CreateTime: 2024-03-18
Connected:
---

# 冒泡排序基本内容
「冒泡排序 bubble sort」通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。
冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 > 右元素”就交换它俩。遍历完成后，最大的元素会被移动到数组的最右端。
![[BAvMXOSKbrXnYZww-dfe88059-eeca-e9d9-040a-ded67222a189.png|943]]
![[BAvMXOSKbrXnYZww-073503f5-2603-b6c7-73a4-338709f0e042.png|936]]
# 算法流程
设数组的长度为 𝑛 ，冒泡排序的步骤如图所示。
1. 首先，对 𝑛 个元素执行“冒泡”，将数组的最大元素交换至正确位置，
2. 接下来，对剩余 𝑛 − 1 个元素执行“冒泡”，将第二大元素交换至正确位置。
3. 以此类推，经过 𝑛 − 1 轮“冒泡”后，前 𝑛 − 1 大的元素都被交换至正确位置。
4. 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。
![[BAvMXOSKbrXnYZww-8d36a344-31a2-e9e9-1543-cca782ef7901.png|738]]

```cpp
/* 冒泡排序 */
void bubbleSort(vector<int> &nums) {
// 外循环：未排序区间为 [0, i]
	for (int i = nums.size() - 1; i > 0; i--) {
	// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
		for (int j = 0; j < i; j++) {
			if (nums[j] > nums[j + 1]) {
				// 交换 nums[j] 与 nums[j + 1]
				// 这里使用了 std::swap() 函数
				swap(nums[j], nums[j + 1]);
			}
		}
	}
}
```

# 效率优化
如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 flag 来监测这种情况，一旦出现就立即返回。
经过优化，冒泡排序的最差和平均时间复杂度仍为 𝑂(𝑛2) ；但当输入数组完全有序时，可达到最佳时间复杂度 𝑂(𝑛) 。
```cpp
/* 冒泡排序（标志优化）*/
void bubbleSortWithFlag(vector<int> &nums) {
// 外循环：未排序区间为 [0, i]
	for (int i = nums.size() - 1; i > 0; i--) {
		bool flag = false; // 初始化标志位
		// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
		for (int j = 0; j < i; j++) {
			if (nums[j] > nums[j + 1]) {
				// 交换 nums[j] 与 nums[j + 1]
				// 这里使用了 std::swap() 函数
				swap(nums[j], nums[j + 1]);
				flag = true; // 记录交换元素
			}
		}
		if (!flag)
			break; // 此轮冒泡未交换任何元素，直接跳出
	}
}
```

# 算法特性
- 时间复杂度为 𝑂(𝑛2)、自适应排序：各轮“冒泡”遍历的数组长度依次为 𝑛 − 1、𝑛 − 2、…、2、1 ，总和为 (𝑛 − 1)𝑛/2 。在引入 flag 优化后，最佳时间复杂度可达到 𝑂(𝑛) 。
- 空间复杂度为 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。
- 稳定排序：在“冒泡”过程中遇到相等元素不交换。