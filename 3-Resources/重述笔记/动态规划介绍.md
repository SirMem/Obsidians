---
Project: "[[动态规划|动态规划]]"
Status: 🟨
tags:
  - Resources
Deadline: 
CreateTime: 
Connected: 
---

# 动态规划和其他子问题分解算法的区别
我们学习了动态规划是如何通过子问题分解来求解问题的。实际上，子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。
- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作为一个子问题。
动态规划常用来求解最优化问题
# 动态规划的特性
## 最优子结构
大问题的（最优）解可以由小问题的（最优）解推出，在这个题中，大问题f（n)的解可以由小问题 f(n 一2)和 f(n－ 1)的解推出。注意在问题拆解过程中不能无限递归。
## 无后效性
未来与过去无关，一旦得到了一个小问题的解，如何得到它的解的过程不影响大问题的求解。在这个题中，要求出 f(n)，只需要知道 f(n－ 1)和 f(n－2)的值，而它们到底是怎么得到的已经不关键了。
## 状态
求解过程进行到了哪一步，可以理解为一个子问题
## 转移
从一个状态（小问题）的（最优）解推导出另一个状态（大问题）的（最优）解的过程。
## 边界
边界决定最优子结构
## 重叠子问题

# 动态规划的经典例子
# 动态规划解题思路
# 问题判断
如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常就适合用动态规划求解。然而，我们很难从问题描述上直接提取出这些特性。因此我们通常会放宽条件，先观察问题是否适合使用回溯（穷举）解决。

## 使用模板
创建哈希表或者数组保存子问题的解
```cpp
dp[i] = dp[i - 1] + j
```j当前状态是可以改变的
