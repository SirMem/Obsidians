---
Project: "[[å“ˆå¸Œè¡¨|å“ˆå¸Œè¡¨]]"
Status: ğŸŸ¨
tags:
  - Resources
Deadline: 2024-03-17
CreateTime: 2024-03-17
Connected: 
---
# å“ˆå¸Œå†²çª
## å®šä¹‰
å“ˆå¸Œå‡½æ•°çš„ä½œç”¨æ˜¯å°†æ‰€æœ‰ key æ„æˆçš„è¾“å…¥ç©ºé—´æ˜ å°„åˆ°æ•°ç»„æ‰€æœ‰ç´¢å¼•æ„æˆçš„è¾“å‡ºç©ºé—´ï¼Œè€Œè¾“å…¥ç©ºé—´å¾€å¾€è¿œå¤§äºè¾“å‡ºç©ºé—´ã€‚å› æ­¤ï¼Œç†è®ºä¸Šä¸€å®šå­˜åœ¨â€œå¤šä¸ªè¾“å…¥å¯¹åº”ç›¸åŒè¾“å‡ºâ€çš„æƒ…å†µ

å½“è¾“å…¥çš„ key åä¸¤ä½ç›¸åŒæ—¶ï¼Œå“ˆå¸Œå‡½æ•°çš„è¾“å‡ºç»“æœä¹Ÿç›¸åŒã€‚ä¾‹å¦‚
```
12836 % 100 = 36
20336 % 100 = 36
```

æˆ‘ä»¬å°†è¿™ç§å¤šä¸ªè¾“å…¥å¯¹åº”åŒä¸€è¾“å‡ºçš„æƒ…å†µç§°ä¸ºã€Œå“ˆå¸Œå†²çª hash collisionã€ã€‚

## è§£å†³æ–¹æ³•

### é“¾å¼åœ°å€
ã€Œé“¾å¼åœ°å€ separate chainingã€å°†å•ä¸ªå…ƒç´ è½¬æ¢ä¸ºé“¾è¡¨ï¼Œå°†é”®å€¼å¯¹ä½œä¸ºé“¾è¡¨èŠ‚ç‚¹ï¼Œå°†æ‰€æœ‰å‘ç”Ÿå†²çªçš„é”®å€¼å¯¹éƒ½å­˜å‚¨åœ¨åŒä¸€é“¾è¡¨ä¸­ã€‚
![[BAvMXOSKbrXnYZww-6d2fb0e1-7bcb-04b3-b278-3b0ba07df4fd.png|725]]

```cpp
/* é“¾å¼åœ°å€å“ˆå¸Œè¡¨ */
class HashMapChaining {
	private:
		int size; // é”®å€¼å¯¹æ•°é‡
		int capacity; // å“ˆå¸Œè¡¨å®¹é‡
		double loadThres; 	// è§¦å‘æ‰©å®¹çš„è´Ÿè½½å› å­é˜ˆå€¼
		int extendRatio; 	// æ‰©å®¹å€æ•°
		vector<vector<Pair *>> buckets; // æ¡¶æ•°ç»„
	public:
		/* æ„é€ å‡½æ•° */
		HashMapChaining() : size(0), capacity(4), loadThres(2.0 / 3), extendRatio(2) {
			buckets.resize(capacity);
		}
		/* ææ„æ–¹æ³• */
		~HashMapChaining() {
			for (auto &bucket : buckets) {
				for (Pair *pair : bucket) {
					// é‡Šæ”¾å†…å­˜
					delete pair;
			}
		}
		/* å“ˆå¸Œå‡½æ•° */
		int hashFunc(int key) {
			return key % capacity;
		}
		/* è´Ÿè½½å› å­ */
		double loadFactor() {
			return (double)size / (double)capacity;
		}
		/* æŸ¥è¯¢æ“ä½œ */
		string get(int key) {
			int index = hashFunc(key);
			// éå†æ¡¶ï¼Œè‹¥æ‰¾åˆ° key åˆ™è¿”å›å¯¹åº” val
			for (Pair *pair : buckets[index]) {
				if (pair->key == key) {
					return pair->val;
				}
			}
			// è‹¥æœªæ‰¾åˆ° key åˆ™è¿”å› nullptr
			return nullptr;
		}
		/* æ·»åŠ æ“ä½œ */
		void put(int key, string val) {
		// å½“è´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œæ‰§è¡Œæ‰©å®¹
			if (loadFactor() > loadThres) {
				extend();
			}
			int index = hashFunc(key);
			// éå†æ¡¶ï¼Œè‹¥é‡åˆ°æŒ‡å®š key ï¼Œåˆ™æ›´æ–°å¯¹åº” val å¹¶è¿”å›
			for (Pair *pair : buckets[index]) {
				if (pair->key == key) {
					pair->val = val;
					return;
				}
			}
			// è‹¥æ— è¯¥ key ï¼Œåˆ™å°†é”®å€¼å¯¹æ·»åŠ è‡³å°¾éƒ¨
			buckets[index].push_back(new Pair(key, val));
			size++;
		}
		/* åˆ é™¤æ“ä½œ */
		void remove(int key) {
			int index = hashFunc(key);
			auto &bucket = buckets[index];
			// éå†æ¡¶ï¼Œä»ä¸­åˆ é™¤é”®å€¼å¯¹
			for (int i = 0; i < bucket.size(); i++) {
				if (bucket[i]->key == key) {
					Pair *tmp = bucket[i];
					bucket.erase(bucket.begin() + i); // ä»ä¸­åˆ é™¤é”®å€¼å¯¹
					delete tmp;
					// é‡Šæ”¾å†…å­˜
					size--;
					return;
				}
			}
		}
		/* æ‰©å®¹å“ˆå¸Œè¡¨ */
		void extend() {
			// æš‚å­˜åŸå“ˆå¸Œè¡¨
			vector<vector<Pair *>> bucketsTmp = buckets;
			// åˆå§‹åŒ–æ‰©å®¹åçš„æ–°å“ˆå¸Œè¡¨
			capacity *= extendRatio;
			buckets.clear();
			buckets.resize(capacity);
			size = 0;
			// å°†é”®å€¼å¯¹ä»åŸå“ˆå¸Œè¡¨æ¬è¿è‡³æ–°å“ˆå¸Œè¡¨
			for (auto &bucket : bucketsTmp) {
				for (Pair *pair : bucket) {
					put(pair->key, pair->val);
					// é‡Šæ”¾å†…å­˜
					delete pair;
				}
			}
		}
		/* æ‰“å°å“ˆå¸Œè¡¨ */
		void print() {
			for (auto &bucket : buckets) {
				cout << "[";
				for (Pair *pair : bucket) {
					cout << pair->key << " -> " << pair->val << ", ";
				}
				cout << "]\n";
			}
		}
}
		
```
å½“é“¾è¡¨å¾ˆé•¿æ—¶ï¼ŒæŸ¥è¯¢æ•ˆç‡ ğ‘‚(ğ‘›) å¾ˆå·®ã€‚æ­¤æ—¶å¯ä»¥å°†é“¾è¡¨è½¬æ¢ä¸ºâ€œAVLæ ‘â€æˆ–â€œçº¢é»‘æ ‘â€ï¼Œä»è€Œ
å°†æŸ¥è¯¢æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–è‡³ ğ‘‚(log ğ‘›) ã€‚
### å¼€æ”¾å¯»å€
ã€Œå¼€æ”¾å¯»å€ open addressingã€ä¸å¼•å…¥é¢å¤–çš„æ•°æ®ç»“æ„ï¼Œè€Œæ˜¯é€šè¿‡â€œå¤šæ¬¡æ¢æµ‹â€æ¥å¤„ç†å“ˆå¸Œå†²çªï¼Œæ¢æµ‹æ–¹å¼ä¸»è¦åŒ…æ‹¬çº¿æ€§æ¢æµ‹ã€å¹³æ–¹æ¢æµ‹ã€å¤šæ¬¡å“ˆå¸Œç­‰ã€‚
#### çº¿æ€§æ¢æµ‹
##### æ“ä½œ
æ’å…¥å…ƒç´ ï¼šé€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—æ•°ç»„ç´¢å¼•ï¼Œè‹¥å‘ç°æ¡¶å†…å·²æœ‰å…ƒç´ ï¼Œåˆ™ä»å†²çªä½ç½®å‘åçº¿æ€§éå†ï¼ˆæ­¥é•¿é€šå¸¸ä¸º 1 ï¼‰ï¼Œç›´è‡³æ‰¾åˆ°ç©ºä½ï¼Œå°†å…ƒç´ æ’å…¥å…¶ä¸­ã€‚
æŸ¥æ‰¾å…ƒç´ ï¼šè‹¥å‘ç°å“ˆå¸Œå†²çªï¼Œåˆ™ä½¿ç”¨ç›¸åŒæ­¥é•¿å‘åçº¿æ€§éå†ï¼Œç›´åˆ°æ‰¾åˆ°å¯¹åº”å…ƒç´ ï¼Œè¿”å› value å³å¯ï¼›å¦‚æœé‡åˆ°ç©ºä½ï¼Œè¯´æ˜ç›®æ ‡é”®å€¼å¯¹ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œè¿”å›None ã€‚
##### ç¼ºç‚¹
ä¸èƒ½ç›´æ¥åˆ é™¤å…ƒç´ ã€‚åˆ é™¤å…ƒç´ ä¼šåœ¨æ•°ç»„å†…äº§ç”Ÿä¸€ä¸ªç©ºä½ï¼Œå½“æŸ¥æ‰¾è¯¥ç©ºä½ä¹‹åçš„å…ƒç´ æ—¶ï¼Œè¯¥ç©ºä½å¯èƒ½å¯¼è‡´ç¨‹åºè¯¯åˆ¤å…ƒç´ ä¸å­˜åœ¨ã€‚ä¸ºæ­¤ï¼Œé€šå¸¸éœ€è¦å€ŸåŠ©ä¸€ä¸ªæ ‡å¿—ä½æ¥æ ‡è®°å·²åˆ é™¤å…ƒç´ ã€‚ä¸èƒ½ç›´æ¥åˆ é™¤å…ƒç´ ã€‚

å®¹æ˜“äº§ç”Ÿèšé›†ã€‚æ•°ç»„å†…è¿ç»­è¢«å ç”¨ä½ç½®è¶Šé•¿ï¼Œè¿™äº›è¿ç»­ä½ç½®å‘ç”Ÿå“ˆå¸Œå†²çªçš„å¯èƒ½æ€§è¶Šå¤§ï¼Œè¿›ä¸€æ­¥ä¿ƒä½¿è¿™ä¸€ä½ç½®çš„èšå †ç”Ÿé•¿ï¼Œå½¢æˆæ¶æ€§å¾ªç¯ï¼Œæœ€ç»ˆå¯¼è‡´å¢åˆ æŸ¥æ”¹æ“ä½œæ•ˆç‡åŠ£åŒ–ã€‚
##### ä»£ç å®ç°
ä½¿ç”¨ä¸€ä¸ªå›ºå®šçš„é”®å€¼å¯¹å®ä¾‹ removed æ¥æ ‡è®°å·²åˆ é™¤å…ƒç´ ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ä¸€ä¸ªæ¡¶å†…çš„å…ƒç´ ä¸ºNoneæˆ–removed æ—¶ï¼Œè¯´æ˜è¿™ä¸ªæ¡¶æ˜¯ç©ºçš„ï¼Œå¯ç”¨äºæ”¾ç½®é”®å€¼å¯¹

åœ¨çº¿æ€§æ¢æµ‹æ—¶ï¼Œæˆ‘ä»¬ä»å½“å‰ç´¢å¼• index å‘åéå†ï¼›è€Œå½“è¶Šè¿‡æ•°ç»„å°¾éƒ¨æ—¶ï¼Œéœ€è¦å›åˆ°å¤´éƒ¨ç»§ç»­éå†ã€‚

```cpp
/* å¼€æ”¾å¯»å€å“ˆå¸Œè¡¨ */
class HashMapOpenAddressing {
	private:
		int size; 	// é”®å€¼å¯¹æ•°é‡
		int capacity;// å“ˆå¸Œè¡¨å®¹é‡
		double loadThres; // è§¦å‘æ‰©å®¹çš„è´Ÿè½½å› å­é˜ˆå€¼
		int extendRatio; // æ‰©å®¹å€æ•°
		vector<Pair *> buckets; // æ¡¶æ•°ç»„
		Pair *removed; // åˆ é™¤æ ‡è®°
	public:
		/* æ„é€ æ–¹æ³• */
		HashMapOpenAddressing() {
			// æ„é€ æ–¹æ³•
			size = 0;
			capacity = 4;
			loadThres = 2.0 / 3.0;
			extendRatio = 2;
			buckets = vector<Pair *>(capacity, nullptr);
			removed = new Pair(-1, "-1");
		}
		/* å“ˆå¸Œå‡½æ•° */
		int hashFunc(int key) {
			return key % capacity;
		}
		/* è´Ÿè½½å› å­ */
		double loadFactor() {
			return static_cast<double>(size) / capacity;
		}
		/* æŸ¥è¯¢æ“ä½œ */
		string get(int key) {
			int index = hashFunc(key);
			// çº¿æ€§æ¢æµ‹ï¼Œä» index å¼€å§‹å‘åéå†
			for (int i = 0; i < capacity; i++) {
				// è®¡ç®—æ¡¶ç´¢å¼•ï¼Œè¶Šè¿‡å°¾éƒ¨è¿”å›å¤´éƒ¨
				int j = (index + i) % capacity;
				// è‹¥é‡åˆ°ç©ºæ¡¶ï¼Œè¯´æ˜æ— æ­¤ key ï¼Œåˆ™è¿”å› nullptr
				if (buckets[j] == nullptr)
					return nullptr;
				// è‹¥é‡åˆ°æŒ‡å®š key ï¼Œåˆ™è¿”å›å¯¹åº” val
				if (buckets[j]->key == key && buckets[j] != removed)
					return buckets[j]->val;
				}
			return nullptr;
		}
		/* æ·»åŠ æ“ä½œ */
		void put(int key, string val) {
			// å½“è´Ÿè½½å› å­è¶…è¿‡é˜ˆå€¼æ—¶ï¼Œæ‰§è¡Œæ‰©å®¹
			if (loadFactor() > loadThres)
				extend();
			int index = hashFunc(key);
			// çº¿æ€§æ¢æµ‹ï¼Œä» index å¼€å§‹å‘åéå†
			for (int i = 0; i < capacity; i++) {
				// è®¡ç®—æ¡¶ç´¢å¼•ï¼Œè¶Šè¿‡å°¾éƒ¨è¿”å›å¤´éƒ¨
				int j = (index + i) % capacity;
				// è‹¥é‡åˆ°ç©ºæ¡¶ã€æˆ–å¸¦æœ‰åˆ é™¤æ ‡è®°çš„æ¡¶ï¼Œåˆ™å°†é”®å€¼å¯¹æ”¾å…¥è¯¥æ¡¶
				if (buckets[j] == nullptr || buckets[j] == removed) {
					buckets[j] = new Pair(key, val);
					size += 1;
					return;
				}
			// è‹¥é‡åˆ°æŒ‡å®š key ï¼Œåˆ™æ›´æ–°å¯¹åº” val
				if (buckets[j]->key == key) {
					buckets[j]->val = val;
					return;
				}
			}
		}
		/* åˆ é™¤æ“ä½œ */
		void remove(int key) {
			int index = hashFunc(key);
			// çº¿æ€§æ¢æµ‹ï¼Œä» index å¼€å§‹å‘åéå†
			for (int i = 0; i < capacity; i++) {
				// è®¡ç®—æ¡¶ç´¢å¼•ï¼Œè¶Šè¿‡å°¾éƒ¨è¿”å›å¤´éƒ¨
				int j = (index + i) % capacity;
				// è‹¥é‡åˆ°ç©ºæ¡¶ï¼Œè¯´æ˜æ— æ­¤ key ï¼Œåˆ™ç›´æ¥è¿”å›
				if (buckets[j] == nullptr)
					return;
				// è‹¥é‡åˆ°æŒ‡å®š key ï¼Œåˆ™æ ‡è®°åˆ é™¤å¹¶è¿”å›
				if (buckets[j]->key == key) {
					delete buckets[j]; // é‡Šæ”¾å†…å­˜
					buckets[j] = removed;
					size -= 1;
					return;
				}
			}
		}
		/* æ‰©å®¹å“ˆå¸Œè¡¨ */
		void extend() {
			// æš‚å­˜åŸå“ˆå¸Œè¡¨
			vector<Pair *> bucketsTmp = buckets;
			// åˆå§‹åŒ–æ‰©å®¹åçš„æ–°å“ˆå¸Œè¡¨
			capacity *= extendRatio;
			buckets = vector<Pair *>(capacity, nullptr);
			size = 0;
			// å°†é”®å€¼å¯¹ä»åŸå“ˆå¸Œè¡¨æ¬è¿è‡³æ–°å“ˆå¸Œè¡¨
			for (Pair *pair : bucketsTmp) {
				if (pair != nullptr && pair != removed) {
					put(pair->key, pair->val);
				}
			}
		}
		/* æ‰“å°å“ˆå¸Œè¡¨ */
		void print() {
			for (auto &pair : buckets) {
				if (pair != nullptr) {
					cout << pair->key << " -> " << pair->val << endl;
				} else {
					cout << "nullptr" << endl;
				}
			}
		}
};
```