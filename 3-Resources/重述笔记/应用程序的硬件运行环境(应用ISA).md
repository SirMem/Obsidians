---
Project: "[[4-Archives/Stopping/操作系统|操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 
Connected: 
---

# 应用程序和操作系统的权限
与用户态的应用程序类似，操作系统本身也是一个程序：两者都由大扯指令组成，运行在由处理器、内存和各种设备组成的硬件环境中。 与应用程序不同的是，操作系统具有更高的权限，可以支配所有的硬件资源；而低权限的应用程序往往只能使用部分硬件资源。

为此，处理器为操作系统提供了专门的特权运行环境，使得操作系统除了可以像应用程序一样对硬件资源进行普通操作之外，还可以进行特权操作，从而有能力管理不同的应用程序，同时也有机会为应用程序提供硬件资源的抽象，并通过系统调用的方式向应用提供服务

![[raVzvbusFpmvqlHI-572bb670-12d5-25df-4a6d-745fdeaf8641.png|967]]

# 引入
操作系统的主要任务之一是管理应用程序，而当应用程序运行在硬件上时，硬件（主要是处理器）会保存诸多状态，比如，程序当前执行到哪条指令，上一条指令是否发生溢出，函数调用依赖的栈在内存中的什么位置，等等。 在应用程序的启动、切换以及退出阶段，操作系统需要对这些保存在硬件上的状态进行初始化、保存／恢复、清除等操作。


# 程序的运行：用指令序列控制处理器
## Q&A
对熟悉 C 语言等高级编程语言的程序员来说，将源代码构建成可执行程序然后运行
是一件非常自然的事情。为什么硬件不能直接运行 C 语言的源代码呢？同样一份源代码 ， 在 Linux 下编译出的二进制程序，放到 Windows 上是否能运行呢？二进制程序在硬件中究竟是如何执行的呢？

## 从 C语言代码到汇编指令再到机器指令
[[8086汇编]]
高级语言的表达能力是很强的，它允许程序员使用变址、循环、函数这些强大的抽
象来构建需要的逻辑。 如果想让处理器直接理解和执行高级语言代码，就需要在处理器内部实现解析这些高级语言语义的逻辑，这会带来难以想象的硬件复杂度，使得处理器的体积和设计难度显著增大。

因此，硬件设计者选择让处理器支持一套格式相对固定、功能相对简单、通常采用二进制编码的机器指令 (Machine Instruction. 简称指令），然后通过机器指令的有机组合去实现高级语言中复杂的语义与功能。

例如， C 语言中的一条 return a + b 语句包含两个操作 ： 对两个数求和，以及将结果返回给调用者。 这两个操作分别对应两条机器指令，其编砃分别为 0x2000000b 和 0xc0035fd6, 处理器通过解析指令编码来“读懂”指令的内容，从而执行相应的操作。

显然，为了便于机器理解而设计的指令并不适合程序员理解。 为此，处理器设计者
为每一条机器指令设计了与其唯一对应的汇编指令 (Assembly Instruction)。0x2000000b 和 Oxc0035fd6 两条机器指令所对应的汇编指
令分别写作 add w0, w1, w0 和 ret 。 其中的 w0 和 wl1 指示了变量 a 和 b 在处理器中存放的位置，以及它们相加的结果将要存放的位置； ret 则对应从当前函数返回的功能。

![[raVzvbusFpmvqlHI-10ecf33d-2545-998e-e8cc-72254c98c441.png|1547]]

## 程序控制硬件的接口与规范：指令集架构 (ISA)
应用程序对计算机硬件的控制，无论是让处理器进行加减运算，从内存读取数据或
将数据写入内存，还是访问硬盘、网卡、键盘、显示器等外部设备，都是通过将相应的机器指令发送给处理器执行来实现的。

关于这些机器指令的格式、行为及处理器在执行中的状态有一个规范，称为处理器的指令集架构 ( lnstruction Set Architecture. ISA) 。

换句话说， lSA 就是处理器向软件提供的接口 。 通过将处理器的实现与接口<font color="#c0504d">解耦</font>，程序员只需要面向 ISA 进行编程，而不用关注处理器硬件的实现细节

# 程序计数器和指令的执行顺序
处理器运行应用程序的流程非常简单：首先从可执行程序中取出第一条指令，根据
ISA 的规范韶析这条指令并执行相应的操作，然后取出下一条指令并重复上述过程。那每次执行完一条指令后，处理器如何知道接下来应该执行哪一条指令？主要有两种方式：顺序执行和跳转执行。
![[raVzvbusFpmvqlHI-581034db-3908-4a34-23a0-1938d7b2402f.png|1473]]

## 顺序执行
处理器内部有一个程序计数器 ( Program Counter. PC)，专门用于记录即将执行的下
一条指令在程序中的位置。 

在应用程序执行之前，操作系统会先将其可执行文件加载到内存中，然后将 PC 的值设置为可执行文件中第一条指令所在的内存位置。 接下来，当处理器从 PC 指向的内存位置取出并解析一条指令后，会将该指令的长度加到当前 PC 的值上，使 PC 指向下一条指令。 这样一来，程序的指令就会按顺序一条接一条地被处理器取出、解析并执行。

## 跳转执行
C 语言中的条件语句 if 会根据条件是否满足来选择执行 if 后的逻辑还是 else 后的逻辑。 在顺序执行模式中，处理器的下一条指令永远是确定的；然而，在执行条件语句时，处理器在进行条件判断后所执行的下一条指令存在两种可能，这意味着至少有一种情况需要用顺序执行以外的方式去实现。

为此， ISA 提供了一种将 PC 值修改为由程序指定的目标位置的方式，称为控制流跳转。又称跳转执行。

# 处理数据:寄存器、运算和访存
数据处理，包括对数据的加、减、乘、除、 与、或、异或、移位等操作，是处理器
提供的基础功能。

## 寄存器：处理器内部的高速存储单元
寄存器是处理器内部的存储单元。 相比内存，寄存器的主要特点是访问速度快、容
量小。 从应用的角度来看，寄存器主要可以分为两大类。

一类是可以存储任意数据的寄存器，称为通用寄存器 (General-Purpose Register) 。对于不同的汇编指令，通用寄存器的用法可能不同：在进行运算时，它们可以用来存储源数据或运算结果；在读写内存时，它们可以用来存储要访问的内存位置 ； 在调用函数时，它们可以用来传递参数。 

另一类是特殊寄存器，用来保存一些特定的数据，比如下一条执行指令的内存位置、栈顶的位置、条件码等。

![[raVzvbusFpmvqlHI-3890b63b-02f8-149d-8fe7-251068603f8e.png|918]]

## 处理器内部的数据运算和移动
程序员用C语言编程时，可以用一行表达式来完成复杂的计算，并用计算结果为某个变量赋值。

汇编指令没有如此强大的表达能力，而是会将表达式拆解成移位、按位异或和乘法这样的基本运算，每个基本运算都由一条数据处理指令完成。

常用的数据处理指令主要包括算术运算、逻辑运算、移位和数据搬移等类型，这类指令使用寄存器中存储的源数据进行算术或逻辑运算,并将结果存储到另一个寄存器中。

![[raVzvbusFpmvqlHI-1014ca95-67d4-fb60-c64c-ff9a2a77af6d.png|1832]]
![[raVzvbusFpmvqlHI-1b7820ec-d96c-5ce5-cbcc-83c5eab89a21.png|1853]]

### 例子:哈希函数
![[raVzvbusFpmvqlHI-b54474af-151a-3a47-b1a5-43447cec8ae9.png|1840]]

在这段代码中， C 语言源代码中共有五个算术操作，包括重复了两遍的右移和异或操作，以及一个加法操作。 对应到汇编代码中，内容相同的第 2 行和第5 行都是同时完成了右移 (asr) 和异或 (eor 目的操作数, 源操作数1, 源操作数2, asr #立即数) 操作，而第 3 行将加法操作的操作数加载到寄存器，再由第 4 行完成加法 ( add) 操作。

## 处理器视角下的内存
在执行程序的过程中，处理器往往需要与内存进行数据交换。 程序中的绝大部分数
据都是存放在内存中的，处理器在进行运算之前需要先将数据从内存加载到寄存器，计算完成后再将结果从寄存器写回内存。 因此， [[应用程序的硬件运行环境(应用ISA)#程序控制硬件的接口与规范：指令集架构 (ISA)|ISA]] 需要提供内存的加载指令与存储指令 ，分别实现内存的读取与写入功能，合称为访存指令。

![[raVzvbusFpmvqlHI-eadb5442-2e32-c47c-127c-9277ab0fda18.png|1842]]

### 例子:swap函数（指针)
```
void swap(int* a, int* b)
{
	int temp = *a;
	*a = *b;
	*b = temp;
}

swap:
	ldr w3, [x1]
	ldr w2, [x0]
	str w3, [x0]
	str w2, [x1]
	ret
```

从处理器的视角来看，内存就是一个很大的数组，数组中的每个元素为 1 字节，数
组的索引称为内存地址 (Memory Address) 。 在使用加载指令和存储指令访问内存时，指令需要指定所访问的内存地址；处理器解析指令得到地址，并根据地址在内存中找到对应的数据，这个过程称为寻址 (Addressing) 。

寻址可以有不同的模式，在 AArch64架构中，寻址主要包括两种模式，分别称作偏移量寻址 (Offset Addressing) 与索引寻址 (Index Addressing) 。 两种寻址方式都涉及基地址 (base) 和偏移量 (offset) 。 偏移址寻址的格式为 [base, offset] ，以基地址和偏移量之和作为目标内存地址。

索引寻址则可以进一步分为前索引寻址 （格式为 [base, offset]!）和后索引寻址（格式为[base], offset)，两者都将基地址作为目标内存地址，并分别在寻址操作前后将基地址的值更新为基地址与偏移量之和。

上面例子中的 [ x0] 和 [x1] 使用的就是偏移量寻址，这里的 x0 和 x1 寄存器的值被作为基地址，偏移扭则被省略了。

## 条件结构:程序分支和条件码
在 ISA 的支持下，程序可以通过判断一个条件是否满足来决定是否需要跳转到另一条指令的位置，从而实现条件分支和循环等复杂程序设计中不可或缺的结构。 这牵涉两个重要功能：跳转到目标代码位置，以及根据条件判断决定是否执行下一条指令。

### 例子:幂函数
```
int power(int x, unsigned int n)
{
 int result = 1;
 for(unsigned  int i = n; i > 0; i--)
	 result *= x;
 return result;
}

power:
	move w2, w0
	mov w0, 1
	cbz w1, .L1
.L3:
	mul w0, w0, w2
	subs w1, w1, #1  根据减法运算的结果更新条件码,在 AArch64架构中，算术逻辑运算指令只有加上 s 后缀才会更新条件码的值
	bne .L3
.L1:
	ret
```

在函数名 power 之外还有两个标签 (Label)，分别是 ".L3" 和 “.L1” 。 这些标签在汇编语言中专门用来定位某处汇编代码或数据的地址，对它们的引用会在汇编程序到可执行程序的转变过程中被翻译为真实的地址，而它们本身不会出现在可执行程序中 。“.L3'' 指示的是mul w0, w0, w2 指令的地址，".L1" 指示的是 ret 指令的地址。

### bne
它根据前一条指令执行的状态（如结果是否为零、计算过程中是否产生溢出）来判断自己的条件是否满足，若满足则跳转。 在这里，指令中的 "b" 代表 “Branch", " ne" 代表 “Not Equal" ，其语义是“当运算结果与零不相等时跳转＂ 。
### cbz
根据本条指令内置计算的执行状态而非前一条指令的执行状态进行条件判断。 指令中的 "c" 代表"Compare", "z" 代表 ”Zero"，因此该指令在 w1 的值为零时会跳转到 “.L1", 否则继续顺序执行。

### 条件判断与条件分支(Condition Flag)
对于 bne 这种没有内置计算功能的指令而言，上一条指令的执行状态是如何传达
给它的呢？一种简单的想法是为每一种可能的条件设置一个寄存器（或某个寄存器中的一位），并根据上一条指令的执行状态设置这些寄存器（或位） 。

常见的 ISA 确实采用了类似的设计，只不过会将所有复杂的条件表示为寥寥几个特征的组合，这样就只需要记录每次条件计算是否表现出这些特征，大大减少了条件计算的开销。这些特征统称为条件码 (Condition Flag) ， 一般会被实现为记录程序运行状态的状态寄存器（如 x86 的FLAGS 、 AArch64 的 PSTATE) 中的若干个位。

虽然在不同架构中的命名有所区别，但条件码一般只包含四位．分别表示计算结果的正负、计算结果是否为零、计算是否产生进位或借位以及计算是否产生有符号溢出 。

在 AArch64 架构中，这四个条件码分别称为 N (Negative) 、 Z (Zero) 、 C (Carry) 、 V (Overflow) 。 
![[raVzvbusFpmvqlHI-a71cbb27-d001-433c-2638-8ff270cc5fe2.png|1823]]

### 条件分支指令如何根据条件码的值决定是否需要跳转 
编译器生成的 subs w1, w1, #1 指令既完成了i-- 的操作，又更新了条件码的值。 由于 i 被声明为一个非负的无符号变量， C 语言源代码中 i > 0 的判定条件与 “i-- 的结果不为零”事实上是同时成立的，因此汇编代码可以通过判定 subs, w1,w1, #1 指令得到的结果是否等千零来决定是否要离开循环。

bne . L3 指令正是发挥了这个作用： NE 条件成立的条件是 Z= 0, 即上条指令（在这里是 subs w1, w1,#1 ) 计算结果不为零。 如果条件成立，说明 1 还没有减小到零，那么控制流会跳转回while 循环的开头(. L3) 并开始下一次循环；反之，说明循环条件已经不成立了 ， 因此不进行跳转，控制流离开 whi l e 循环。 如果 i 是一个有符号变量的话，编译器会生成不同的跳转条件（例如 bgt) 以明确地表达 i > 0 这一条件。

## 函数的调用、返回与栈
与前面的计算、访存和跳转相比，高级语言中的函数这一抽象在汇编语言层面的实现更为复杂。首先，函数的调用与返回意味着控制流在调用者与被调用者之间的交接， ISA 一般会提供专门的函数调用指令与返回指令来完成这项任务。

其次，函数在运行过程中需要占用部分内存来存放调用参数和局部变量等数据， ISA 采用运行时栈(Runtime Stack) 为每个函数的实例分配可供临时使用的内存，并在函数实例返回后释放内存。

### 例子:简单的平方函数与立方函数
```
itn square(int n)
{
	return n * n;
}

int cube(int n)
{
	ruturn n * square(n);
}

square:
	mul w0,w0,w0
	ret 
cube:
	stp x29, x30, [sp, -32] ! # 前索引寻址
	mov x29, sp
	str x19, [sp , 16]
	mov w19, w0
	bl square 
	mul	w0, w0, w19
	ldr x19, [sp, 16]
	ldp x29, x30, [sp], 32 #后索引寻址
	ret
	
```

### 函数的调用指令与返回指令(LR,FR)
函数的涸用与返回过程涉及调用者与被调用者之间的控制流交接。 具体而言 ， 调用者需要知道被词用者的第一行代码地址， 以跳转到被调用者的代码区域； 被调用者也必须知道调用代码的位置，这样在执行完成后才能返回调用处，使调用者可以继续执行。

前者相对容易，只要用一个标签表示函数名 ， 前文提到的跳转执行就可以实现这一功能 ； 后者比较复杂，因为同一个函数可能被不同的调用者调用，所以被调用者无法在实际被调用之前确定调用代码的位置。

因此，处理器需要在发生函数调用时，将调用指令后的下一条指令地址保存在某个位置，从而在被调用者运行返回指令时，可以从该位置取出地址以继续执行——这个地址被称为返回地址 (Return Address)。 由此可见，函数调用指令需要完成两个任务：跳转到目标函数和保存返回地址。

尽管跳转的方式基本相同，但不同架构保存返回地址的方式却有着不小的差异。

例如， x86 架构中的函数调用指令 (call) 会直接将返回地址保存到内存，返回指令
( ret) 则会从同一个内存位置读取返回地址，并跳转到要返回的代码处。

AArch64 架构中的函数调用指令 (bl) 会将返回地址保存在一个特定的寄存器中，返回指令 ( ret )则会从该寄存器中读取地址并跳转过去。在 AArch64上实现为通用寄存器中的 X30 寄存器，别名为 <font color="#ff0000">LR (Link Register) </font>。

![[raVzvbusFpmvqlHI-5eedcddc-c089-35eb-3f9b-e70950a4df0d.png|1398]]

如果被调用的函数在执行过程中又词用了其他函数，那么 LR 寄存器的值会被覆盖，这个问题该如何解决呢？ 事实上，编译器会在每个函数调用指令之前和之后某处生成额外的代码，分别完成“将 LR 的旧值保存到内存”和“将内存中保存的值恢复到LR" 两个任务。注意，如果一个函数中没有对其他函数的调用（例如上例中的 square 函数），编译器就无须保存和恢复 LR 的值。

### 运行时栈:保存函数中的局部状态
每个函数在运行期间（从被调用到返回前）都需要一段内存来存放其局部状态，例
如被调用时传入的实际参数、函数内声明的局部变量，等等。

由于函数的调用可以嵌套，程序执行过程中往往存在多个未返回的函数，这些函数占用的内存区域被按照调用顺序排列在一起，<font color="#ff0000">新被调用的函数从这个序列的尾部申请内存，已经返回的函数释放自已占用的内存。</font>

考虑到函数调用的模式是“先被调用者后返回＂，这些排列好的内存区域事实上可以被看作栈结构，其中先被调用的函数对应的内存区域更靠近栈底，也就更晚出栈（被释放） 。 我们将这个结构称为运行时栈或函数栈，在操作系统语境下一般简称＂栈＂ 。
#### SP
处理器一般会设置一个专门的<font color="#ff0000">栈寄存器</font>来存放指向栈顶的指针（SP)——栈指针 (Stack
Pointer)，它指示着当前运行时栈的大小 ： 大于栈指针的地址是已经分配给某个函数的，而小于栈指针的地址是未分配的

在运行过程中，函数可以通过增大与减小栈指针的值分别在栈上分配与释放内存。
#### 栈帧和FP
每个函数在栈上拥有的连续内存空间称为函数的栈帧 (Stack Frame) 。 当前函数的栈帧在内存中的起始位置称为帧指针 (Frame Pointer, FP ) ， 一般由一个寄存器来专门保存，如 AArcb64 架构将 FP 保存在 X29 通用寄存器。

编译器在生成函数的汇编代码时，会分别向函数的开头与末尾插入创建栈帧与释放栈帧的代码，从而保证生命周期已经结束的函数所占用的内存能够被正确地回收。

![[raVzvbusFpmvqlHI-af9bc537-eab9-08bc-b37c-7f54ceea208d.png|1639]]

由于 FP 和 LR 寄存器在处理器中都只有一份，因此每个函数都需要在覆盖这些值之前保存它们，并在自己的生命周期结束前（即返回前）恢复它们。

AArch64 平台编译器生成的代码一般会借助前文介绍过的索引寻址，使得访存指令可以在保存或恢复 FP和 LR 的值的同时减小或增大 SP 寄存器的值，从而用一条指令完成 “FP/LR 值的保存与恢复”和＂栈帧的创建与释放”两个任务。

例如， cube 函数开头的代码 stp x29,x30, [sp, -32] ！将 SP 的值减小 0x32 字节（创建大小为 32 字节的栈帧），并将 FP 和 LR 保存到更新后的 SP 值指示的位置，也就是栈帧的低地址处。

返回前的代码 ldp x29, x30, [sp], 32 则将 SP 的值增大 0x32 字节（释放栈帧），并从更新前的 SP 值指示位置恢复 FP 和 LR 的值。 值得注意的是，这两条指令在函数中的位憤、数据在寄存器和内存间的流动方向以及对 SP 的修改都是完全对称的，这是为了在函数的生命周期结束后消除它对栈和寄存器状态的影响。

# 函数的调用惯例
## 调用惯例
事实上，调用者与被淜用者之间需要交接的不仅是控制流，还有参数、返回值等数据。 另外，由于调用者与被调用者共用同一组通用寄存器，它们还需要协调寄存器的分配，并在必要的时候对使用中出现冲突的寄存器进行保存和恢复。

调用者和被调用者之间应当如何协调并不是由硬件的 ISA 决定的。而是由软件的调用惯例 ( Calling Convention ) 来规范的，并由编译器来实现。 调用者与被调用者双方只有遵循调用惯例，才不至于在使用处理器时产生冲突，从而正确地完成数据的交接。

调用惯例是函数调用过程中调用者与被涸用者双方需要遗循的规范。涉及调用惯例中栈帧的创建与回收、 [[应用程序的硬件运行环境(应用ISA)#函数的调用指令与返回指令(LR,FR)|LR和FP]] 的保存与恢复等部分。调用前后通用寄存器应当由谁来保存，以及参数
与返回值如何在调用者与被调用者间传递。

## 寄存器保持: 位置与方式 
由于所有的函数都共享同一批通用寄存器，不同的函数对通用寄存器的使用难免发生冲突。为防止调用者存放在通用寄存器中的值被覆盖，调用惯例通常将通用寄存器划分成两部分，一部分由调用者保存 ( Caller-saved )，另一部分由被调用者保存 ( Callee­-saved ) 。

具体而言，调用者需要在调用函数前保存一些通用寄存器的值，并允许被调用者随意使用这些寄存器；另一些通用寄存器的值则需要在调用前后保持一致，因此被调用者在修改这些寄存器的值之前需要先保存原值，并在返回前进行寄存器值的恢复。

在 AArch64 架构中， X9~X15 由调用者保存， X19 ~ X28 由被调用者保存。例如，cube 函数使用了一个由被调用者保存的寄存器 (X19)，因此在使用之前将它的值保存到栈帧中(str x19, [sp,16]，这部分称为寄存器保存区），并在返回前进行了相应的恢复工作 (ldr x19, [sp, 16] ） 。

## Q&A
(a) 调用者保存的寄存器和被调用者保存的寄存器中 ， 哪一种适合存放生命周期较长、在整个函数内各处都会用到的变量？哪一种适合存放只是在一小段代码中临时用到的变量？

(b) 为什么不让调用者保存所有的寄存器，或让被调用者保存全部的寄存器？

## 参数与返回值
函数调用期间，调用者和被调用者双方进行数据交换的方式主要有两种：调用者向被调用者传递参数，以及被调用者向调用者返回返回值。

例如 AArch64 架构中会分别用 X0~X7 来传递前 8个参数，并用 X0 传递返回值，如果有更多的参数则会保存到栈上（这部分称为参数构造区） 

例如，在 cube 函数中，第一个参数 n 的值就放在 w0 中 。 由于n被直接作为参数传递给了 square 函数，第 9 行代码没有进行额外的参数准备就直接用 bl 指令调用了square 函数。 再观察 square 函数的代码．可以发现它将乘法的结果同样放在了 w0中，作为返回值传递回 cube 函数。

## 完整的栈帧结构
每个函数除了在栈帧中保存 FP 和 LR 的旧值外，还会利用栈帧中的不同区域来分
别存储调用时传递的实际参数、函数内部分配的局部变量、需要保存的寄存器值等
数据

![[raVzvbusFpmvqlHI-9ea733a5-192d-2e94-52e0-fcf63569fb39.png|1792]]


![[raVzvbusFpmvqlHI-e3239365-125e-d4f5-3525-1769428722b5.png|946]]


并非所有函数都需要栈帧。 换句话说，栈帧中的每个区域都是可选的。

考虑前面例子中的 square 函数，首先，它不包含对其他函数的调用，因此不需要
担心 LR 与 FP 的值被覆盖的问题，也就不需要保存 LR 与 FP 的值

其次，它也不需要参数构造区来准备调用时需要传递的参数。 X9 ~ X15 寄存器足以存放它的所有局部变量，因此用不到需要被调用者保存的寄存器，也就不需要寄存器保存区和局部变量区。

它的形式参数在生命周期内仅被使用一次，因此不需要参数保存区。 这样一来，对于这个函数来说栈帧中的每个部分都没有存在的必要，编译器也就不会为它分配栈帧了 。