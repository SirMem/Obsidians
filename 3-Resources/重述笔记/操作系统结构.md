---
Project: "[[4-Archives/Stopping/操作系统]]"
Status: 
tags:
  - Resources
Deadline: 2024-04-20
CreateTime: 2024-04-11
Connected: 
---
# 操作系统的机制与策略

策略表示“要做什么“,机制表示“如何做到＂ 。

对于计箕机登录认证系统而言，机制包括输入处理、策略文件管理、桌面启动加载等，策略则包括什么用户、以什么权限登录等。

另一个例子是操作系统的调度系统，策略包括先到先服务 (First-Come-First­Service)、时间片轮转 (Round Robin )、最短截止时间优先 (Earl iest Deadline First)、完全公平调度 (Completely Fair Scheduling) 等，机制则包括调度队列的设计 、 调度实体的表
示（如线程）与时钟的中断处理等。

![[raVzvbusFpmvqlHI-b104be02-2b04-69cf-9cf6-3518fb4e2a72.png|1800]]

通过分离机制与策略，操作系统一方面可以通过设置多种不同的策略来适应不同的应用需求，而不需要重新实现对应的具体机制 ； 另一方面也可以通过持续优化具体的机制来不断完善对具体策略的支持。

## Q&A
如何控制操作系统的复杂性？
什么是机制？什么是策略？为什么要将二者尽可能分离？
操作系统内核有哪些典型的架构？
# 操作系统复杂性的管理方法
## Q&A
什么是 M.A.L.H 方法？
分层与层级有哪些区别？
## M.A.L.H方法
管理系统复杂性的重要方法是 M.A L.H 方法，即模块化 (Modularity)、抽象(Abstraction )、分层 ( Layering) 和层级 ( Hierarchy ) 。
### 模板化
模块化是通过分而治之 (Divide and Conquer) 原则，将一个复杂系统分解为一系列通过明确定义的接口进行交互的模块，并严格保障模块之间的界限。

模块划分并不是越细越好，过多的模块反而会因为模块之间联系过多而无益千复杂性的控制；划分要充分考虑高内聚和低耦合，使模块具有较好的独立性。

现代操作系统都存在一定程度的模块化结构，包括进程管理、内存管理、网络协议栈、设备驱动等。

### 抽象
抽象是在模块化的基础上将接口与内部实现分离，从而使模块之间只需通过抽象的接口进行相互调用，而无须关心各个模块间的内部实现。

设计良好的抽象应该尽可能依从模块间的自然边界，并尽可能减少模块间的交互，从而减少错误在模块间的传递，提高整体系统的开发效率、质量与性能等。

例如， UNIX 系列操作系统所提供的虚拟内存为物理内存提供了良好的抽象，使应用程序无须关心物理地址的具体位置，而只需要针对独立的、连续的虚拟地址空间进行设计。

#### 模板化和抽象联系
##### 宽进严出原则
模块的接口应该容忍各种可能的检入，抑制错误甚至恶意的输入，避免错误或恶意输入的效果在模块内传播，并且尽可能严格地控制模块对外的输出，从而减少错误在模块间的传播。

### 分层
分层是通过将模块按照一定的原则进行层次划分，约束每层内模块间与跨层次模块间的交互方式，从而有效地减少模块之间的交互。

通常的原则是： 一个模块只能和同层模块以及相邻的上层或下层模块进行交互，而不能跨层和再上一层或再下一层的模块进行交互。

分层也是构建复杂系统的一个重要方式：确定层级后，我们可以先构建底层的模块，然后利用底层模块提供的功能与服务进一步构建上层的模块。

![[raVzvbusFpmvqlHI-027e644e-111f-9f09-f16e-e13cfb591751.png|1395]]


对于一个已经构建好的复杂系统，分层也是一个很好的解决问题的方式。
例如，针对数据中心的服务器性能越来越强大但利用率低下且管理困难等问题，系统虚拟化通过在操作系统之下再构建一层虚拟机监控器层，有效地提升了资源利川率，提高了性能与错误隔离的能力， 并且降低了管理难度。

### 层级
层级是另外一种模块的组织方式：首先将一些功能相近的模块组成一个具有清晰接口的自包含子系统，然后再将这些子系统递归式地组成一个具有清晰接口的更大的子系统。

分层和层级这两个概念有点像，有些时候不容易区分。简要而言，分层是指不同类模块之间的层次化，而层级则是指同类模块之间的分层。两种方法可以组合起来一起降低模块的复杂性。 例如，操作系统包括内核层、系统服务层与应用柜架层等，而操作系统内核中则可以通过如上的层级方式进行组织 。

# 操作系统内核架构
## Q&A
操作系统的内核有哪些常见的架构？
MS-DOS的架构有什么优点和缺点？
一个应用能否运行在多个内核之上？
微内核与宏内核到底孰优孰劣？

## 常见的操作系统内核架构
![[raVzvbusFpmvqlHI-ecb6e2f0-adb7-53f0-a810-fb0e6fa92ab9.png|1573]]

## 简要结构(MS-DOS)
一些功能较为简单的操作系统会选择将应用程序与操作系统放笠在同一个地址空间(Address Space) 中，以同样的权限运行，无须底层硬件提供复杂的内存管理、特权级隔离等功能。

MS-DOS (Microsoft Disk Operating System) 是采用简要结构的一个典型例子。该结构的一个优势在于，应用程序对操作系统服务的调用无须切换地址空间和权限层级，因此更为高效。但缺点也同样明显：缺乏良好的隔离能力，任何一个应用或操作系统模块出现间题，均有可能使整个系统崩溃。

随着操作系统功能的不断增加，简要结构会使操作系统的设计与实现难度越来越高，难以持续演进。

### MS-DOS结构示图
尽管缺乏隔离能力，但简要结构的操作系统依然采用了一定的模块化与层次结
构以降低复杂性.
![[raVzvbusFpmvqlHI-fe348483-f0fb-03f1-89a6-d6f7249d5507.png|892]]

MSDOS.Sys 模块通过命令行接口与用户交互，并负责与设备驱动交互以实现对硬件设备的管理； I/O 子系统( IO.Sys) 实现对硬件设备 I/O 访问的管理，并以 I/O 请求作为抽象，为 MSDOS.Sys和驱动程序 I/O 提供服务。

### 简要操作系统控制的硬件
除了 MS-DOS 外， 当前一些采用简要结构的操作系统还包括 FreeRTOS与µC/OS等。 这些操作系统主要运行在微控制单元 (MicroController Unit, MCU) 等相对比较简单的硬件上，这些硬件通常没有提供现代意义上的内存管理单元 (Memory Management Unit. MMU)，隔离能力较弱或缺失，难以运行 （往往也不需要运行）复杂的操作系统

## 宏内核
宏内核 (Monolithic Kernel) 又称单内核，其特征是操作系统内核的所有模块（包括进程调度、内存管理、文件系统、设备驱动等）均运行在内核态，具备直接操作硬件的能力，这类操作系统包括 UNIX/Linux 、 FreeBSD 等。
![[raVzvbusFpmvqlHI-5f7d6cf9-cdb7-c3b1-aa18-48afe37e2630.png|971]]

### 宏内核架构M.A.L.H方法控制复杂性
由于操作系统内核的功能日趋复杂，宏内核架构的操作系统也逐步采用 M.A.L.H 方法来控制其不断增加的复杂性。

## 微内核
### 定义
在宏内核架构下，所有内核校块均运行在特权级， 一个单点的错误就可能导致整个系统崩溃或者被攻破。 而系统很难避免 Bug。虽然很多缺陷在正常运行时不会被触发，部分缺陷即使触发也不会引起严重后果，但对千一个千万行代码级的软件而言，潜在的重大缺陷数量也是触目惊心的。

对宏内核架构的操作系统进行解耦，将单个功能或模块（如文件系统、设备驱动等）从内核中拆分出来，作为一个独立的服务 (Service) 部署到独立的非特权运行环境中；内核仅保留极少的功能，为这些服务提供通信等基础能力，使其能够互相协作以完成操作系统必需的功能。 这种架构被称为微内核(Microkernel) 。

在微内核架构下，服务与服务之间是完全隔离的，单个服务即使出现故障或受到攻击，也不会直接导致整个操作系统崩溃或被攻破，从而能有效提高操作系统的可靠性与安全性。 此外，微内核架构实现了机制与策略的进一步分离，可更方便地为不同场景定制不同的服务，从而更好地适应不同的应用需求。

### 最小化原则
应尽可能将操作系统的功能放置在内核态以外，只有在将其放在内核态以外会影响整个系统的功能时，才能被放置在内核态。 

## 外核
### 概念
操作系统内核在硬件管理方面的两个主要功能是资源抽象与多路复用 (Multiplexing) 。其中，对硬件资源的抽象存在两方面的问题 : 
1. 过度的硬件资源抽象可能会带来较大的性能损失，违反“抽象但不隐藏能力”(Abstract but don't hide power) 原则。
2. 操作系统所提供的硬件资源抽象是针对所有应用的通用抽象，这些抽象对一些具体的应用 （ 如数据库、 Web 服务器等）来说往往不是最优的选择。

外核（Exokernel）是一种特殊的操作系统架构。它的主要思想是将硬件资源的管理权交给应用程序，而不是由操作系统内核统一管理。这样做的目的是为了提高系统的运行效率和灵活性。

在许多场景中，应用比操作系统更了解该如何抽象与使用硬件资源，因此，应当由应用来尽可能地控制对硬件资源的抽象。

![[raVzvbusFpmvqlHI-1869ea16-371a-5f28-dd95-44bda6b0c5df.png|1005]]

### 库操作系统
库操作系统（Library Operating System，简称 LibOS）是根据某类应用的特殊需求，由某一高级编程语言将原本属于操作系统内核的某些资源管理功能，如文件磁盘 I/O、网络通信等，按照模块化的要求，以库的形式提供给应用程序的特殊操作系统。

它能代替操作系统内核合理地管理和控制所涉及的计算机资源，并将所涉及的计算机资源直接暴露给应用程序，让应用程序直接访问底层（虚拟）硬件，以便应用程序能够高效地运行

外核架构的劣势在于， LibOS 通常是为某种应用定制的，缺乏跨场景的通用性，应用生态差。 因此，外核架构较难用千功能要求复杂、生态与接口丰富的场景

## 多内核架构

多内核架构是指一种集成了多个独立处理核心的中央处理器（CPU）。每个处理核心都是一个独立的、完整的处理器，可以执行指令、管理数据和执行计算任务。多核处理器的设计旨在提高处理器的整体性能，通过并行执行多个任务来加速计算

![[raVzvbusFpmvqlHI-cf3c60d5-602f-7ee1-0aae-a15ab7b6249a.png|1280]]



通过这种架构，多内核可以避免传统操作系统架构中复杂的隐式共享带来的性能可扩展性瓶颈，并且由于不同处理器核上运行的操作系统节点是独立的而且可以不同，从而非常容易支持异构处理器架构。

多内核架构的不足之处在于：不同节点之间的状态存在冗余，导致一定的资源开销；上层应用必须使用多内核提供的进程间通信接口才能进行交互，需要移植现有应用才能适应多内核架构；绝对性能方面并不一定存在优势。

## 混合内核架构
由于设计需求的多样化，现实中的操作系统往往融合了多种架构的设计思想。

![[raVzvbusFpmvqlHI-5591805c-72c3-d307-da05-0541a98aff7b.png|1846]]
