---
Project: "[[4-Archives/Stopping/操作系统|操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-17
Connected: 
---

# 介绍
链接(linking)是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行 。 链接可以执行于编译时 (compile time), 也就是在源代码被翻译成机器代码时；也可以执行于加载时 Cload time), 也就是在程序被加载器 (load­er) 加载到内存并执行时；甚至执行于运行时 (run time), 也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器 (linker) 的程序自动执行的。

链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译 (separate com-pilation)成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。
## 学习链接的优点
- 理解链接器将帮助你构造大型程序。构造大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。除非你理解链接器是如何解析引用、什么是库以及链接器是如何使用库来解析引用的，否则这类错误将令你感到迷惑和挫败。
- 理解链接器将帮助你避免一些危险的编程错误 。 Linux 链接器解析符号引用时所做的决定可以不动声色地影响你程序的正确性 。 在默认情况下，错误地定义多个全局变最的程序将通过链接器，而不产生任何警告信息 。 由此得到的程序会产生令人迷惑的运行时行为，而且非常难以调试。
- 理解链接将帮助你理解语言的作用域规则是如何实现的。例如，全局和局部变量之间的区别是什么？ 当你定义一个具有 static 属性的变量或者函数时，实际到底意味着什么？
- 理解链接将帮助你理解其他重要的系统概念。 链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，比如加载和运行程序、虚拟内存、分页、内存映射。
- 理解链接将使你能够利用共享库 。 多年以来，链接都被认为是相当简单和无趣的。然而，随着共享库和动态链接在现代操作系统中重要性的日益加强，链接成为一个复杂的过程，为掌握它的程序员提供了强大的能力 。
# 编译器驱动程序
![[eDqKLfGvNLCndwWt-d8379f7a-59d7-cdba-40fc-b7eac51716e1.png|862]]
大多数编译系统提供编译器驱动程序 (compiler driver), 它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。
比如，要用 GNU 编译系统构造示例程序，我们就要通过在 shell 中输入下列命令来调用 GCC 驱动程序：
- linux> gcc -Og -o prog main.c sum.c

![[eDqKLfGvNLCndwWt-80b0833d-7c99-78be-8443-1d9c5f190c89.png|506]]
此图概括了驱动程序在将示例程序从ASCII码源文件翻译成可执行目标文件时的行为。驱动程序首先运行C预处理器，它将C的源程序main.c翻译成一个ASCII码的中间文件main.i:
- cpp[other arguments] main.c /tmp/main.i
接下来，驱动程序运行 C 编译器(cc1), 它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s:
- cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s
然后,驱动程序运行汇编器 (as), 它将 main.s 翻译成一个<font color="#ff0000">可重定位目标文件</font>(relo-catable object file)main.o
- as [other arguments] -o /tmp/main.o /tmp/main.s

驱动程序经过相同的过程生成 sum.o。最后，它运行链接器程序 ld, 将 main.o 和sum.o 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件 (executable ob-ject file)prog:
- ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
要运行可执行文件prog,在Linux shell 的命令行上输入它的名字
- linux> ./prog
shell调用操作系统中一个叫做加载器 (loader ) 的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

# 静态链接
像 Linux LD 程序这样的静态链接器 (static linker) 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。

输入的可重定位目标文件由各种不同的代码和数据节(sec tion) 组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变鼠在另一节中，而未初始化的变量又在另外一节中 。

为了构造可执行文件，链接器必须完成两个主要任务：
- 符号解析(symbol resolution) 。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言 中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
- 重定位 (relocation) 。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置 。 链接器使用汇编器产生的重定位条目 (relocation entry) 的详细指令，不加甄别地执行这样的重定位 。
# 目标文件
目标文件有三种形式
- 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件 。
- 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行 。
- 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说， 一个目标模块 (object module)就是一个字节序列，而一个目标文件 (ob­ject file)就是一个以文件形式存放在磁盘中的目标模块 。

目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。从贝尔实验室诞生的第一个 Unix 系统使用的是 a.o江格式（直到今天，可执行文件仍然称为 a.out 文件）。 Windows 使用可移植可执行 (Portable Executable, PE) 格式。 MacOS-x 使用 Mach-O 格式。现代 x86-64 Linux 和 Unix 系统使用可执行可链接格式 (Execut­able and Linkable Format, ELF) 。

# 可重定位目标文件 
![[eDqKLfGvNLCndwWt-b7b98ea9-2701-024f-0c71-118edcc8b6fe.png|347]]
图 7-3 展示了一个典型的 ELF 可重定位目标文件的格式。 ELF 头(ELF header) 以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 
![[Pasted image 20240421103216.png]]
## ELF header 
![[Pasted image 20240421101217.png]]
ELF信息表
![[Pasted image 20240421101318.png]]
ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如 x86-64) 、节头部表(section header table) 的文件偏移，以及节头部表中条目的大小和数最。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目 (entry) 。

## Section 
夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：
- .text: 已编译程序的机器代码。

- .rodata：只读数据，比如printf语句中的格式串和开关语句的跳转表
- 
- .data:已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不出现在 .data 节中，也不出现在 .bss 节中。

- .bss:未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0 。

- .syrntab: 一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .syrntab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，. syrntab 符号表不包含局部变量的条目。

- .rel.text: 一个 .text节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。

- .rel. data: 被模块引用或定义的所有全局变最的重定位信息。一般而言，任何已初始化的全局变最，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。

- .debug: 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

- .line: 原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。

- .strtab: 一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。
- COMMON : 存放未初始化的全局变量，与bss区别极小，可以看作bss的替代

## 节头表
ELF 文件中的节头表包含了关于文件中各个节（sections）的信息，比如节的名称、偏移量、大小、属性等。每个节都有一个相应的节头表条目，用于描述该节的属性和位置信息。节头表提供了对文件中不同部分的结构化描述，允许程序在加载时找到和处理不同类型的节。
# 符号和符号表
## 内容
![[Pasted image 20240421103125.png]]

## 局部变量在栈
局部变量符号由栈管理，链接器对此不感兴趣
## 三种符号
由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C函数和全局变量。

由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。

只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。 这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。


# 符号解析
编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。

![[eDqKLfGvNLCndwWt-d09778f4-8f4c-cdda-1287-59fa06ba3c79.png|808]]
![[eDqKLfGvNLCndwWt-abc455ed-40fe-d21e-28e9-30a9791e92c5.png|822]]

## 链接器如何解析多重定义的全局符号
在编译时，编译器向汇编器输出每个全局符号，或者是强 (strong) 或者是弱 (weak),而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。
### 强弱符号
强符号:函数和已初始化的全局变量
弱符号:未初始化的全局变量
根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名：
- 不允许有多个同名的强符号。
- 如果有一个强符号和多个弱符号同名，那么选择强符号。
- 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。这是一个非常致命的错误
![[Pasted image 20240421104526.png]]
int占四个字节，double占八个字节，执行f()会覆盖x和y的值

## 与静态库链接
### 定义
将所有相关的目标模块集合打包成为一个单独的文件(file)，称为静态库 (static library), 它可以用做链接器的输入。

相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用 C 标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接：
- linux> gcc main.c /usr/lib/libm.a /usr/lib/libc.a

在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小 。 另一方面，应用程序员只需要包含较少的库文件的名字（实际上， C 编译器驱动程序总是传送 libc .a 给链接器， 所以前面提到的对 libc.a 的引用是不必要的） 。

在 Linux 系统中，静态库以一种称为存档 (archive) 的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。

### 例子:创建静态库
![[eDqKLfGvNLCndwWt-221030ac-6825-5093-7068-02783863a4e4.png|854]]

要创建这些函数的一个静态库，我们将使用 AR 工具，如下：
- linux> gcc -c addvec.c multvec.c
- linux> ar rcs libvector.a addvec.o multvec.o 
![[eDqKLfGvNLCndwWt-1d5a71e5-7f7c-9fdb-4d3f-852e429f807e.png|851]]
为了创建这个可执行文件，我们要编译和链接输入文件main.o和libvector.a
- linux> gcc -c main2.c
- linux> gcc -static -o prog2c main2.o ./libvector.a 

![[eDqKLfGvNLCndwWt-5332f786-08de-df9b-a2f5-c2874f01c5cb.png|856]]

## 链接器如何使用静态库来解析引用
https://www.bilibili.com/video/BV1oS4y1T7Uf/?spm_id_from=333.788&vd_source=8b450300cfa6415cb0312754cf65ba30
![[Pasted image 20240421105703.png]]
链接器引用静态库的规则通常包括以下步骤：

1. **指定静态库路径**：在编译器或链接器的命令行参数中指定静态库所在的路径。这通常使用 `-L` 参数来实现。

2. **指定静态库名**：在编译器或链接器的命令行参数中指定要链接的静态库的名称。通常使用 `-l` 参数，后跟静态库的名称，但不包括文件扩展名。例如，如果静态库文件名为 `libexample.a`，则可以使用 `-lexample` 来指定。

3. **链接器搜索顺序**：链接器会按照一定的搜索顺序查找静态库。通常，链接器会首先搜索命令行中指定的库路径，然后是系统默认的库路径。搜索顺序十分重要，如果搜索顺序错误则会导致U集合存在元素导致编译错误，通常库使用必须将它们放到命令行末尾
4. ![[Pasted image 20240421110116.png]]

5. **符号解析**：链接器将查找并解析程序中使用的函数、变量等符号。如果在程序中引用了某个符号，但该符号在目标文件或静态库中未定义，链接器将会报错。

6. **链接**：当链接器找到静态库中所需的符号并解析成功后，它将把静态库中的目标文件中的代码与程序中的其他目标文件进行链接，生成最终的可执行文件。

# 重定位
## 步骤
重定位节和符号定义
重定位节中的符号引用
## 重定位节和符号定义 
![[Pasted image 20240421111205.png]]
## 重定位节中的符号引用

### 重定位条目
当汇编器遇到最终位置不确定的符号引用时，它就产生一个重定位条目

重定位条目用来告诉链接器在合成可执行文件时应该如何修改这个引用

关于代码的重定位条目放在.rel.text中，对于已初始化数据的重定位条目放在.rel.data中
![[Pasted image 20240421112014.png]]
1）**offset --> f**，f指立即数0x0位置的偏移量，即要修改的引用位置离main的偏移量  
2）**type --> RX86_64PC32**，重定位条目一共有32种type，R_X86_64_PC32表明重定位的引用使用32位PC相对地址  
3）**symbol --> sum**，表明调用的符号是sum，在本例中是个函数  
4）**addend --> 5**，这个addend可能会带来疑惑，它代表引用位置与下一条指令的相对位置关系，在此例中就是引用的偏移量 0xf 减去下一指令的偏移量 0x13 得到 -0x4，在链接器进行具体计算时我们需要用到它
### 相对位置重定位条目引用
[00:05:22](ziyunote://play?path=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1JL411L7ku%2F%3Fspm_id_from%3D333.788%26vd_source%3D8b450300cfa6415cb0312754cf65ba30&time=00:05:22)
![[Pasted image 20240421112745.png]]
存储PC值
![[Pasted image 20240421113150.png]]
求相对值
![[Pasted image 20240421113225.png]]
### 绝对位置重定位条目引用
![[Pasted image 20240421112625.png]]
![[Pasted image 20240421112720.png]]

# 可执行文件

## 可执行文件的ELF格式
![[eDqKLfGvNLCndwWt-a5395368-08bb-d255-6134-cc511e3b1a33.png|650]]
### 内存加载
![[Pasted image 20240422162939.png]]
代码段和数据段被加载到内存中，符号表不会

### Segment header table
![[eDqKLfGvNLCndwWt-131ba98d-3f67-89a8-f79e-92332ce0b706.png|866]]
r代表可读,w代表可写,-代表不可执行
memsz比filesz大八个字节用来存储.bss section数据

## 可执行程序加载运行(加载器)
要运行可执行目标文件 prog, 我们可以在 Linux shell 的命令行中输入它的名字：
- linux> ./prog 

因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog 是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器 (loader) 的操作系统代码来运行它 。 任何Linux 程序都可以通过调用 execve 函数来调用加载器。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。

实际上，由于 .data 段有对齐要求（见 7. 8 节），所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化(ASLR, 参见 3. 10. 4 节）。虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。

当加载器运行时，它创建类似千图 7-15 所示的内存映像。 在程序头部表的引导下， 加载器将可执行文件的片 (chunk) 复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是_start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。` _start` 函数调用系统启动函数让__libc_start_main, 该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。

![[Pasted image 20240422165247.png]]

# 动态链接共享库
## 静态库缺陷
1. 静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。
2. 几乎每个 C 程序都使用标准 I /0 函数，比如 printf 和 scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中 。 在一个运行上百个进程的典型系统上，这将是对稀缺的内存系统资源的极大浪费。

## 共享库
共享库 (shared Ii brary)是致力千解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。

这个过程称为动态链接(dynamic linking) , 是由一个叫做动态链接器 (dynamic linker)的程序来执行的 。 共享库也称为共享目标 (shared object), 在 Linux 系统中通常用 .so后缀来表示。微软的操作系统大最地使用了共享库，它们称为 DLL(动态链接库）。

![[eDqKLfGvNLCndwWt-ae4bf44b-2a7f-ee82-2ec9-1076d97222cb.png|472]]

为了构造图 7-6 中示例向量例程的共享库 libvector.so, 我们调用编译器驱动程序，给编译器和链接器如下特殊指令：
- linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c 
-fpic 选项指示编译器生成与位置无关的代码
-shared选项指示链接器创建一个共享的目标文件。


一旦创建了这个库，随后就要将它链接到图 7-7 的示例程序中：
- linux> gcc -o prog21 main2.c ./libvector.so 

这样就创建了一个可执行目标文件 prog21, 而此文件的形式使得它在运行时可以和libvector.so 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程

没有任何libvector. so的代码和数据节真的被复制到可执行文件 prog21 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。










