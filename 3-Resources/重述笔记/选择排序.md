---
Project: "[[排序]]"
Status: 🟨
tags:
  - Resources
Deadline: 2024-03-18
CreateTime: 2024-03-18
Connected:
---
# 选择排序的基本内容

「选择排序 selection sort」的工作原理非常直接：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。

设数组的长度为 𝑛 ，选择排序的算法流程如图所示
1. 初始状态下，所有元素未排序，即未排序（索引）区间为 [0, 𝑛 − 1] 。
2. 选取区间 [0, 𝑛 − 1] 中的最小元素，将其与索引 0 处元素交换。完成后，数组前 1 个元素已排序。
3. 选取区间 [1, 𝑛 − 1] 中的最小元素，将其与索引 1 处元素交换。完成后，数组前 2 个元素已排序。
4. 以此类推。经过 𝑛 − 1 轮选择与交换后，数组前 𝑛 − 1 个元素已排序。
5. 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。
![[BAvMXOSKbrXnYZww-3f8e0ff4-7691-4407-79b6-9b4f80ba9b1c.png|941]]
![[BAvMXOSKbrXnYZww-06204643-9c2f-e681-88d7-c6fe91f24ba7.png|936]]
```cpp
/* 选择排序 */
void selectionSort(vector<int> &nums) {
	int n = nums.size();
	// 外循环：未排序区间为 [i, n-1]
	for (int i = 0; i < n - 1; i++) {
	// 内循环：找到未排序区间内的最小元素
		int k = i;
		for (int j = i + 1; j < n; j++) {
			if (nums[j] < nums[k])
			k = j; // 记录最小元素的索引
		}
	// 将该最小元素与未排序区间的首个元素交换
		swap(nums[i], nums[k]);
	}
}
```

## 算法特性
- 时间复杂度为 𝑂(𝑛<sup>2</sup>)、非自适应排序：外循环共 𝑛 − 1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛 − 1、…、3、2 轮内循环，求和为(𝑛−1)(𝑛+2)/2 。
- 空间复杂度 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。
- 非稳定排序：如图所示，元素 nums[i] 有可能被交换至与其相等的元素的右边，导致两者相对顺序发生改变。
- ![[BAvMXOSKbrXnYZww-e85c7ae3-903c-4440-cab6-1dfc4cf2a909.png|485]]

