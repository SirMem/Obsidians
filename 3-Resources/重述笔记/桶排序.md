---
Project: "[[排序]]"
Status: 🟨
tags:
  - Resources
Deadline: 2024-03-20
CreateTime: 2024-03-20
Connected:
---
# 桶排序基本内容

「桶排序 bucket sort」是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。
# 算法流程
考虑一个长度为 𝑛 的数组，元素是范围 [0, 1) 的浮点数。
1. 初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。
2. 对每个桶分别执行排序（本文采用编程语言的内置排序函数）。
3. 按照桶的从小到大的顺序，合并结果。
![[BAvMXOSKbrXnYZww-043ad60e-60b9-a84c-784f-4132a5f779af.png|715]]
```cpp
/* 桶排序 */
void bucketSort(vector<float> &nums) {
	// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素
	int k = nums.size() / 2;
	vector<vector<float>> buckets(k);
	// 1. 将数组元素分配到各个桶中
	for (float num : nums) {
		// 输入数据范围 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]
		int i = num * k;
		// 将 num 添加进桶 bucket_idx
		buckets[i].push_back(num);
	}
	// 2. 对各个桶执行排序
	for (vector<float> &bucket : buckets) {
			// 使用内置排序函数，也可以替换成其他排序算法
			sort(bucket.begin(), bucket.end());
		}
		// 3. 遍历桶合并结果
		int i = 0;
		for (vector<float> &bucket : buckets) {
			for (float num : bucket) {
				nums[i++] = num;
			}
	}
}
```

# 算法特性
桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。
- 时间复杂度 𝑂(𝑛 + 𝑘) ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛/𝑘 。假设排序单个桶使用 𝑂( 𝑛/𝑘 log 𝑛/𝑘 ) 时间，则排序所有桶使用 𝑂(𝑛 log 𝑛/𝑘 ) 时间。当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛) 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛 + 𝑘) 时间。
- 自适应排序：在最坏情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛<sup>2</sup>) 时间。
- 空间复杂度 𝑂(𝑛 + 𝑘)、非原地排序：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。
桶排序是否稳定取决于排序桶内元素的算法是否稳定。

# 桶排序的优化
桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，关键在于将元素均匀分配到各个桶中，因为实际数据往往不是均匀分布的。
为实现平均分配，我们可以先设定一个大致的分界线，将数据粗略地分到 3 个桶中。分配完毕后，再将元素较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等。这种方法本质上是创建一个递归树，目标是让叶节点的值尽可能平均。
![[BAvMXOSKbrXnYZww-5d6a3dab-a5be-8ee8-df5c-acba08d2ac4f.png|714]]
