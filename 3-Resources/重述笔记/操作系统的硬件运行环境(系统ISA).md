---
Project: "[[4-Archives/Stopping/操作系统]]"
Status: 🟨
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-12
Connected: 
---
# Q&A
为什么要区分用户态与内核态？两者的运行环境有什么区别？

什么是中断、异常和系统调用 ？

用户态和内核态之间是如何切换的？ CPU 和内核分别做了哪些操作？

为什么操作系统内核的启动代码要用汇编语言而非 C 语言编写？
系统 ISA 的许多指令（比如读取MPIDR) 在 C 语言中并没有对应的语句，因此只能用汇编语言编写 。 另一个原因是， C 语言所依赖的运行时栈在系统刚启动的阶段尚未建立起来， SP 寄存器也没有初始化，所以现阶段还无法运行 C 语言的函数调用 。
# 引入
操作系统的硬件运行环境是应用程序硬件运行环境的超集：除了运算、访存、函数调用等基本功能外，还包括一些只有操作系统才有权限执行的功能，比如对 CPU 中断的开关、对频率的调整、对内存的配置、对设备的操作等。

这些功能之所以只允许操作系统使用，是因为它们会影响系统全局的状态而不仅仅是某一个应用程序的状态。

为了区分操作系统与应用程序的不同运行环境，现代 CPU 通常会提供不同的特权级，让用户程序运行在低特权级，操作系统运行在更高的特权级，并限制只有高特权级才能执行特权操作。 同时， CPU 也提供了在低特权级与高特权级之间的切换机制。

# 特权级别与系统ISA
为了区分应用程序和操作系统的运行权限 ， CPU 为两者提供了不同的特权级别：用户态 ( User-mode) 和内核态 ( Kernel-mode ) 。 
ISA 作为 CPU 向软件提供的接口，也对应地分为用户 ISA 与系统 ISA。 在用户态运行的软件只能使用用户 ISA, 在内核态运行的软件则可以同时使用系统 ISA 和用户 ISA。

用户 ISA 包括通用寄存器、栈寄存器、条件码寄存器、运算指令等。而系统 ISA 则包含系统状态、系统寄存器与系统指令。

其中，系统状态包括当前 CPU 的特权级别、 CPU 发生错误时引发错误的指令地址、程序运行状态等。 存储这些状态的寄存器称为系统寄存器 ( System Register )，这些寄存器只能由运行在内核态的软件通过系统指令来访问 。

运行在内核态的操作系统可通过系统 ISA 来管理系统的硬件以及应用程序。 当运行在用户态的应用程序需要操作外部设备（比如向屏幕输出 “hello, world”) 时，需要向操作系统提出申请，由其代为完成。 

如果应用程序试图强行在用户态执行系统 ISA 中独有的系统指令，处理器会制止这次操作，并切换到内核态，由操作系统来决定应该如何处理这次越权操作（通常是中止该应用）。

## 案例分析: ARM的特权级别和系统ISA
### ARM的特权级别
真实的 CPU 并不一定只有用户态和内核态两种特权级别 。以 AArch64 为例介绍 CPU 特权级别和系统 ISA 的一种具体实现。
![[raVzvbusFpmvqlHI-b87239a5-720f-466c-71d8-847510ae11b0.png|1164]]

如图所示，AArch64 中的特权级别被称为异常级别 ( Exception Level, EL )，共分为 4 个级别，其中应用程序运行在 EL0 ,操作系统运行在 EL1 。 CPU 当前的特权级状态保存在 PSTATE 寄存器中，当 CPU 发生状态切换的时候，该寄存器中的状态会随之更新。 4 个级别具体如下：
1. EL0: 用户态，应用程序通常运行在该特权级别。
2. EL1: 内核态，操作系统通常运行在该特权级别。
3. EL2：用于虚拟化场景， 虚拟机监控器 (Virtual Machine Monitor, VMM 、也称为Hypervisor) 通常运行在该特权级别。
4. EL3: 与安全特性 TrustZone 相关，负责普通世界 (Normal World) 和安全世界(Secure World) 之间的切换，本章主要集中在普通世界。

TrustZone 是从 ARMv6 架构开始引入的安全特性，如今已被广泛使用 。 该特性从逻辑上将整个系统分为安全世界和普通世界，计算资源可以被划分到这两个世界。

安全世界可以不受限制地访问所有的计算资源，而普通世界不能访问被划分到安全世界的计算资源。
### 系统ISA
对于许多 ISA 来说，当 CPU 在内核态运行用户 ISA （比如函数调用）时，一般会使用用户 ISA 的寄存器（比如 SP) 。 这也是为什么从用户态切换到内核态时，首先需要将用户态寄存器的值保存到内存。

AArch64 则采用了略微不同的方法：为一些常用的用户态寄存器在不同特权级提供不同的硬件副本。

例如，对于栈寄存器 SP,AArcb64 提供了 SP_EL0（用户态栈寄存器）与 SP_EL1（内核态栈寄存器） 。 其中 ，用户态在函数调用时使用 SP_EL0, 无法访问 SP_EL1; 内核态则使用 SP_EL1, 但也有权限读写 SP_EL0。 这么设计的好处在于，当 CPU 从用户态切换到内核态时，内核代码无须保存 SP_EL0 寄存器中的值，在切换回用户态时也无须恢复，从而可以降低切换的时延。

AArch64 的系统寄存器负责保存硬件系统状态，以及为操作系统提供管理硬件的接口 。系统 ISA 提供了 mrs(Move to Register from State register) 和 msr 两条特权指令 , 其作用是从系统寄存器中读取值（获取系统信息）或向系统寄存器中写入值（控制系统状态） 。

系统 ISA 的指令只有在特权态才能运行， CPU 在执行相关指令前会先根据 PSTATE 中的状态来判断是否合法。例如，
当 PSTATE 记录当前运行级别为 ELO 时， CPU 运行的指令无权访问 ELR_EL1系统寄存器。由于 AArch64 有多个特权级，因此对于系统寄存器，也需要通过类似的后缀来表明
这些寄存器在哪一个特权级下使用

![[raVzvbusFpmvqlHI-67852ab0-8d0d-40c5-4f15-a23440902c94.png|1823]]

# 异常机制与异常向量表
## Q&A
为什么要称为“异常“机制呢？
因为对应用程序来说，大部分时间都是在用户态执行代码，只有出现特殊情况，比如需要获得键盘输入 、 在显示器输出字符、被硬件产生的中断打断 、 发生应用程序无法处理的错误等，才需要“下陷”到内核态去处理。
因此从应用程序的角度来看，下陷到内核是因为出现“异常"情况，需要内核处理，处理完成后恢复“正常”，应用继续运行。 在内核中处理异常情况的代码通常称为异常处理程序 (Exception handler)

虽然这里说“异常”是从应用程序的角度来看的，但实际上 CPU 在内核态运行代码时也可能发生异常事件，同样会由内核的异常处理程序进行处理，唯一的区别是不需要“下陷＂，即切换特权级——因为已经在内核态了 。 这种在异常处理时发生异常的情况通常是比较少见的，如果出现三次递归，在一些处理器平台（如 x86) 则会被认为是严重错误，即 “Triple-Fault” 。
## 引入
在提供多个特权级的同时， CPU 还需要提供在不同特权级之间切换的机制在 AArch64 平台，用户态与内核态的切换使用的是异常机制。其中，从用户态切换至内核态的过程称为陷入或下陷 (Trap)，从内核态切换至用户态的过程称为“从内核态返回＂ 。

## 触发CPU异常机制的事件
### 中断
在用户程序正常执行的过程中， CPU 可能收到一些来自外部的事件，如硬件时钟会周期性地发出信号。 这些事件会强行打断正在运行的程序，使 CPU 下陷到内核态由操作系统处理，之后恢复用户程序，从被打断的位置继续执行，整个过程中用户程序并不会意识到自已被打断过。 这类来自 CPU 外部的事件一般称为中断(Interrupt) 。
### 异常
程序在执行中可能会遇到一些自身无法处理的间题，例如执行了一条格式错误的非法指令，或试图将数据写入只读的内存区域。 这些事件同样会触发下陷，操作系统处理完成后，应用程序继续执行。 若操作系统无法处理，则可强行终止程序，甚至触发重启。这类来自 CPU 内部的事件一般称为异常 ( Exception ) 。
### 主动异常
用户程序主动触发异常，向操作系统发出执行特定操作的诸求, CPU 通常会为这种情况提供一条特殊的指令（如 AArch64 的 SVC 指令。 这种情况就是系统调用(System Call) 。 因为系统调用也是在 CPU 内部发生的，所以系统调用也可以被看作异常的一种。

### 异常控制流
异常机制的控制流是不受应用程序控制的： 一方面，发生异常后跳转的目的地址不由应用程序控制；另一方面，这种控制流突变可能在应用程序毫无准备的情况下随时发生

![[raVzvbusFpmvqlHI-6b6283df-dc63-c283-81bb-394ea4efa1a7.png|1127]]

如图展示了发生异常时控制流在应用与内核之间的切换过程。 在异常机制中，控制流变化的特殊性还体现在如何返回用户态上。 在用户态发生函数调用时，被调用者返回后，会执行调用代码之后的下一条代码。 

而在异常机制中，操作系统返回用户态后可能有两种情况：一种情况是执行应用程序触发下陷的指令（如系统调用 SVC) 之后的下一条指令，另一种悄况是重新执行触发下陷的指令本身

当系统发生异常事件导致“下陷”到内核态时， CPU 只允许从固定的入口(内存空间)开始执行。 为此，操作系统需要提前将代码的入口地址”告诉＂处理器。 对不同类型的异常事件， CPU 通常支持设翌不同的入口 。 这些入口通常以一张表的形式记录在内存中，也就是异常向量表 ，由操作系统负责构造。

在系统启动后，操作系统会将异常向量表的内存地址写入 CPU 上的一个特殊寄存器——异常向最表基地址寄存器 （如 AArch64 中的VBAR_EL1寄存器），然后开启中断，这样便完成了异常机制的初始化。

异常向量表定义的其实是操作系统的“入口＂ 。 在初始化完成之后，操作系统之所以需要运行，是因为发生了异常事件需要处理。 换句话说，如果应用程序运行一切“正常＂，没有发生任何“异常” 事件，那么操作系统就没有机会
运行。

在这种情况下，如果有一个应用程序运行了 “while (true);" 的空循环，没有任何系统调用，也不会运行出错，是不是就会独占 CPU, 使操作系统永远没有机会运行呢？ 还好，这种情况并不会发生，因为还有中断。 操作系统在运行应用程序之前，会先设置好硬件时钟以某个固定的频率（如每秒1000 次）产生中断，从而保证在应用运行一定时间 (如 1ms) 之后，一定会通过异常机制回到操作系统。 通过时钟中断，操作系统牢牢地把握住了运行的主动权。

### 不同架构的中断与异常
不同体系结构表示中断和异常的术语有所差异。 ARM 架构将中断称为“异步异常＂，而将异常称为“同步异常＂ 。 这是因为中断是由硬件（如时钟）产生的，对 CPU来说任何时候都可能发生，所以是异步；而异常是由软件产生的，对 CPU 来说，在某种条件下执行到某条指令一定会发生，所以是同步。 

x86 架构则采用类似的术语，相对来说使用更为普遍，如表所示。 另一个不同之处在于： ARM 的“异常向量表”,x86 称之为＂中断向量表” 。
![[raVzvbusFpmvqlHI-af584d0b-6ff3-075b-1fdb-62c53fa3fd5e.png|1731]]

# 用户态与内核态的切换
在用户态与内核态的切换过程中，有许多任务需要完成。 这些任务大致归为两类：一类是保存用户程序的状态，一类是准备操作系统的运行环境。 其中， 需要保存的状态主要是用户程序与操作系统共同使用、可能被操作系统覆盖的处理器状态。

准备操作系统的运行环境则包含更加复杂的操作。
第一，为了处理异常事件，需要准备许多与异常事件相关的信息，例如异常平件的种类、触发事件的指令地址等；

第二 ，由于操作系统所使用的栈不同于应用程序的栈，因此需要找到并切换至操作系统使用的栈；

第三，根据不同的异常事件找到对应的异常处理函数地址，并跳转过去执行。 不同处理器通常为每种异常悄况分配好了编号。根据异常编号，处理器便能自动在前文提到的异常向最表中找到对应的处理程序并进行跳转。

![[raVzvbusFpmvqlHI-ce9586c5-6c89-69fc-5fb1-ac5053278627.png|1897]]

## 汇编指令下陷与返回
svc下陷
eret返回

# 系统调用
系统调用是操作系统提供给应用程序的接口 。 例如， printf 函数就是通过 write系统调用来实现的。 系统调用是一种用户程序主动触发的异常，与一般的异常不同，系统调用需要在用户态与内核态之间传递一些额外的信息，例如用户程序提供的参数，以及操作系统给出的返回值。

对应用程序来说，系统调用与普通的函数词用看上去十分类似，区别在于： 普通的被调用者与询用者都在用户态，共用一个栈；

而系统调用的调用者在用户态，被调用者在内核态，两者使用不同的栈。 因此系统询用的参数和返回值等信息，需要遵守一套与普通函数调用不同的调用惯例。

![[raVzvbusFpmvqlHI-7fabf6c2-256b-b914-2b03-66029c222416.png|1698]]

## 优化
系统调用作为应用程序调用操作系统的入口，其性能也非常重要。 然而，不同于传统的函数调用，系统调用的过程复用了异常机制，因此不可避免地需要执行<font color="#ff0000">特权级切换 、上下文保存等</font>操作，导致其时延比普通的函数调用高 1 到 2 个数量级。 对于需要频繁进行系统调用的应用来说，这是很大的性能开销。

可以通过在用户态和内核态之间共享一小块内存的方式，在应用与内核之间创建一条新的通道。 具体来说又可以分为两种方法。
第一种方法是内核将一部分数据通过只读的形式共享给应用，允许应用直接读取。
第二种方法则是允许应用以“向某一块内存页写入请求＂的方式发起系统调用，并
通过轮询来等待系统调用完成。