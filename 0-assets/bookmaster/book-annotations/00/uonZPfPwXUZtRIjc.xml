<?xml version="1.0" encoding="UTF-8"?><xfdf xmlns="http://ns.adobe.com/xfdf/" xml:space="preserve"><fields/><annots><underline page="13" rect="36.970,232.800,307.440,248.880" color="#A6A1E6" flags="print" name="666059b8-82e4-07d5-daff-99543f8bd452" title="Guest" subject="下划线" date="D:20240329174429+08'00'" creationdate="D:20240329174429+08'00'" coords="203.56400000000002,248.88,307.44019999999995,248.88,203.56400000000002,243.12,307.44019999999995,243.12,36.97,238.56,223.92079999999999,238.56,36.97,232.8,223.92079999999999,232.8"><contents>这时，就需要有一个能够将汇编指
令转换成机器指令的翻译程序，这样的程序我们称其为编译器</contents></underline><underline page="13" rect="148.570,131.223,221.290,142.667" color="#A6A1E6" flags="print" name="50a70ed6-89aa-600b-dcce-84d3edb7e604" title="Guest" subject="下划线" date="D:20240329174455+08'00'" creationdate="D:20240329174455+08'00'" coords="148.57,142.66690000000006,221.2902,142.66690000000006,148.57,131.22250000000003,221.2902,131.22250000000003"><contents>汇编语言的组成</contents></underline><underline page="15" rect="65.040,257.715,181.930,265.440" color="#A6A1E6" flags="print" name="81abc753-6aaf-7bb2-b431-00f008841a01" title="Guest" subject="下划线" date="D:20240329175055+08'00'" creationdate="D:20240329175055+08'00'" coords="65.04,265.44,181.93,265.44,65.04,257.715,181.93,257.715"><contents>器件的选择，读或写的命令（控制信息）；</contents></underline><underline page="15" rect="189.220,203.040,285.610,208.800" color="#A6A1E6" flags="print" name="6685710d-1575-bd25-1f0a-73866298a21a" title="Guest" subject="下划线" date="D:20240329175115+08'00'" creationdate="D:20240329175115+08'00'" coords="189.22000000000003,208.79999999999995,285.61,208.79999999999995,189.22000000000003,203.03999999999996,285.61,203.03999999999996"><contents>地址总线、控制总线和数据总线</contents></underline><underline page="16" rect="36.970,55.200,307.930,71.040" color="#A6A1E6" flags="print" name="ecf40d8e-af72-c48c-a0f7-b6c9c981aed4" title="Guest" subject="下划线" date="D:20240329175510+08'00'" creationdate="D:20240329175510+08'00'" coords="50.879999999999995,71.04000000000002,307.9302,71.04000000000002,50.879999999999995,65.27999999999997,307.9302,65.27999999999997,36.97,60.7201,151.4408,60.7201,36.97,55.19999999999999,151.4408,55.19999999999999"><contents>一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU
最多可以寻找 2 的 N 次方个内存单元。</contents></underline><square page="20" rect="62.440,57.150,287.020,227.100" color="#007A3B" flags="print" name="d1d981b5-947e-fa51-85c6-c70cdc83162c" title="Guest" subject="矩形" date="D:20240330204037+08'00'" creationdate="D:20240330204034+08'00'"/><underline page="21" rect="36.970,351.610,307.450,367.440" color="#A6A1E6" flags="print" name="1e900e39-962e-f007-abab-44c7a62b622b" title="Guest" subject="下划线" date="D:20240330204125+08'00'" creationdate="D:20240330204125+08'00'" coords="50.88240000000002,367.44029739999996,307.45000000000005,367.44029739999996,50.88240000000002,361.91999999999996,307.45000000000005,361.91999999999996,36.97,357.37,303.6006,357.37,36.97,351.61,303.6006,351.61"><contents>这也就是说， CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作
一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。</contents></underline><square page="21" rect="37.430,82.740,311.650,335.380" color="#007A3B" flags="print" name="98db0330-e219-0781-27c9-486157a723ae" title="Guest" subject="矩形" date="D:20240330204135+08'00'" creationdate="D:20240330204132+08'00'"/><underline page="23" rect="36.720,367.680,307.450,393.120" color="#A6A1E6" flags="print" name="4ea9dac8-910d-b42e-e969-048d0aaeaf30" title="Guest" subject="下划线" date="D:20240330204450+08'00'" creationdate="D:20240330204450+08'00'" coords="48.720000000000006,393.12,307.45,393.12,48.720000000000006,388.32,307.45,388.32,36.720000000000006,382.8,307.44000000000005,382.8,36.720000000000006,378,307.44000000000005,378,36.720000000000006,372.48,169.44,372.48,36.720000000000006,367.68,169.44,367.68"><contents>最终运行程序的是 CPU, 我们用汇编语言编程的时候，必须要从 CPU 的角度考虑问题。对 CPU 来
讲，系统中的所有存储器中的存储单元都处千一个统一的逻辑存储器中，它的容杂受 CPU 寻址能力的限
制。 这个逻辑存储器即是我们所说的内存地址空间。</contents></underline><underline page="24" rect="37.440,290.890,307.440,306.960" color="#A6A1E6" flags="print" name="114880c7-b4e4-b30c-859c-8772ffd0f0cc" title="Guest" subject="下划线" date="D:20240330204608+08'00'" creationdate="D:20240330204608+08'00'" coords="133.68,306.96,307.44019999999995,306.96,133.68,301.2,307.44019999999995,301.2,37.44,296.65,284.88,296.65,37.44,290.89,284.88,290.89"><contents>CPU 中的主要部件是寄存器。寄存器是 CPU 中程序员可
以用指令读写的部件。程序员通过改变各种寄存器中 的 内容来实现对 CPU 的控制。</contents></underline><square page="27" rect="32.460,172.110,315.660,258.230" color="#007A3B" flags="print" name="f0e2fbdc-9246-d20c-4c66-057f52e9a332" title="Guest" subject="矩形" date="D:20240330205114+08'00'" creationdate="D:20240330205113+08'00'"/><underline page="27" rect="112.800,138.960,298.330,144.480" color="#A6A1E6" flags="print" name="c099729d-4f1b-e71e-885f-9f9db40af957" title="Guest" subject="下划线" date="D:20240330205128+08'00'" creationdate="D:20240330205128+08'00'" coords="112.8,144.4801,298.33000000000004,144.4801,112.8,138.96000000000004,298.33000000000004,138.96000000000004"><contents>mov ax, 18 和 MOVAX, 18 的含义相同 ： bx 和 BX 的含义相同。</contents></underline><underline page="28" rect="36.970,303.360,195.130,309.120" color="#A6A1E6" flags="print" name="36dca5a6-e2eb-568d-04a4-990a311f6bd4" title="Guest" subject="下划线" date="D:20240330205320+08'00'" creationdate="D:20240330205320+08'00'" coords="36.97,309.12,195.13000000000002,309.12,36.97,303.36,195.13000000000002,303.36"><contents>高位的 1 不能在 ax 中保存， ax 中的数据为： 044CH 。</contents></underline><highlight page="28" rect="36.970,65.520,307.440,81.360" color="#FFCD45" flags="print" name="65cd911c-14ee-39f1-c1a9-7de5f8520dda" title="Guest" subject="高亮" date="D:20240330205521+08'00'" creationdate="D:20240330205521+08'00'" coords="130.81,81.36009999999999,307.44,81.36009999999999,130.81,75.84000000000003,307.44,75.84000000000003,36.97,71.27999999999997,136.898,71.27999999999997,36.97,65.51999999999998,136.898,65.51999999999998"><contents>这里的丢失，指的是进位值不能在 8 位寄存器中保存，但
是 CPU 并不真的丢弃这个进位值</contents></highlight><underline page="29" rect="50.880,365.290,278.580,371.050" color="#A6A1E6" flags="print" name="12fd56ef-1dfd-80af-099f-82288beafa9f" title="Guest" subject="下划线" date="D:20240330205855+08'00'" creationdate="D:20240330205855+08'00'" coords="50.879999999999995,371.04999999999995,278.58000000000004,371.04999999999995,50.879999999999995,365.28999999999996,278.58000000000004,365.28999999999996"><contents>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</contents></underline><square page="26" rect="51.560,368.610,289.120,448.620" color="#007A3B" flags="print" name="e040f224-1516-3c1c-7838-95eb04ea8328" title="Guest" subject="矩形" date="D:20240330205919+08'00'" creationdate="D:20240330205917+08'00'"/><underline page="31" rect="36.720,351.850,307.200,367.200" color="#A6A1E6" flags="print" name="e97aa3b6-f930-4f9e-ba8e-54ceb97659a5" title="Guest" subject="下划线" date="D:20240330210300+08'00'" creationdate="D:20240330210300+08'00'" coords="237.0112,367.2001,307.2001,367.2001,237.0112,361.68,307.2001,361.68,36.720000000000006,357.37010000000004,279.6005,357.37010000000004,36.720000000000006,351.85,279.6005,351.85"><contents>所有的内存单元构成的
存储空间是一个一维的线性空间 ， 每一个内存单元在这个空间中都有唯一的地址</contents></underline><squiggly page="31" rect="133.920,66.480,301.200,72.000" color="#E44234" flags="print" name="4aa82cb3-0700-47e4-13ae-933c2ca65cc8" title="Guest" subject="曲线" date="D:20240330210445+08'00'" creationdate="D:20240330210445+08'00'" coords="133.92,72.00009999999997,301.2,72.00009999999997,133.92,66.48000000000002,301.2,66.48000000000002"><contents>两个 1 6 位地址合成的方法来形成一个 20 位的物理地址。</contents></squiggly><underline page="31" rect="51.020,189.152,180.720,217.450" color="#A6A1E6" flags="print" name="23f46e1d-b9cf-8a59-0b49-6be86a4d4b93" title="Guest" subject="下划线" date="D:20240330210548+08'00'" creationdate="D:20240330210548+08'00'" coords="65.04,217.45,180.72,217.45,65.04,209.79247750000002,180.72,209.79247750000002,51.02,207.13009999999997,146.17,207.13009999999997,51.02,199.23247750000002,146.17,199.23247750000002,51.02,196.57,174.49020000000002,196.57,51.02,189.15247750000003,174.49020000000002,189.15247750000003"><contents>运算器一次最多可以处理 1 6 位的数据 ；
• 寄存器的最大宽度为 1 6 位；
• 寄存器和运算器之间的通路为 1 6 位。</contents></underline><underline page="33" rect="36.970,104.640,307.440,120.720" color="#A6A1E6" flags="print" name="8474f117-c14f-e0f0-2b79-2c63314cff1b" title="Guest" subject="下划线" date="D:20240330210933+08'00'" creationdate="D:20240330210933+08'00'" coords="50.879999999999995,120.72000000000003,307.44,120.72000000000003,50.879999999999995,114.96000000000004,307.44,114.96000000000004,36.97,110.39999999999998,108.48,110.39999999999998,36.97,104.63999999999999,108.48,104.63999999999999"><contents>更一般地说， 8086CPU 的这种寻址功能是 “基础地址＋偏移地址＝物理地址“ 寻址模
式的一种具体实现方案 。</contents></underline><underline page="35" rect="36.970,411.850,307.440,427.930" color="#A6A1E6" flags="print" name="11ad2b2a-f98f-c85e-53c2-b6af2c9274df" title="Guest" subject="下划线" date="D:20240330211052+08'00'" creationdate="D:20240330211052+08'00'" coords="71.7603,427.93,307.44,427.93,71.7603,422.17,307.44,422.17,36.97,417.61,224.29289999999997,417.61,36.97,411.85,224.29289999999997,411.85"><contents>内存并没有分段，段的划分来自千 CPU, 由千 8086CPU 用“基础地址（段地
址x l 6)＋偏移地址＝物理地址”的方式给出内存单元的物理地址</contents></underline><squiggly page="36" rect="36.720,288,72.960,296.400" color="#E44234" flags="print" name="cdb4e4c8-7eca-fd37-5021-5be7f82ff83b" title="Guest" subject="曲线" date="D:20240330211326+08'00'" creationdate="D:20240330211326+08'00'" coords="36.720000000000006,296.4,72.96,296.4,36.720000000000006,288,72.96,288"><contents>检测点 2.2</contents></squiggly><text page="36" rect="233.970,247.990,264.970,278.990" color="#FFCD45" flags="print,nozoom,norotate" name="8049192d-c33e-c626-8ae8-8a780871293c" title="Guest" subject="注释" date="D:20240330212318+08'00'" creationdate="D:20240330212315+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;在这个问题中，我们知道物理地址是 20000H，我们需要找到段地址（SA）的最小和最大值，使得我们可以通过偏移地址找到这个物理地址。\\n\\n物理地址的计算公式是：物理地址 = 段地址 * 16 + 偏移地址。\\n\\n因此，偏移地址的计算公式是：偏移地址 = 物理地址 - 段地址 * 16。\\n\\n偏移地址是16位的，所以它的最大值是 FFFFH。因此，我们可以得到段地址的最小值和最大值：\\n\\n- SA 的最小值：当偏移地址最大（即 FFFFH）时，SA 的值最小。所以，SAmin = (20000H - FFFFH) / 16 = 1001H。\\n\\n- SA 的最大值：当偏移地址为0时，SA 的值最大。所以，SAmax = 20000H / 16 = 2000H。\\n\\n所以，如果想用偏移地址找到存放在内存 20000H 单元中的数据，段地址 SA 应满足的条件是，最小为 1001H，最大为 2000H。这样，无论 SA 取值在这个范围内的哪一个值，都可以通过一个合适的偏移地址找到 20000H 单元。\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>在这个问题中，我们知道物理地址是 20000H，我们需要找到段地址（SA）的最小和最大值，使得我们可以通过偏移地址找到这个物理地址。

物理地址的计算公式是：物理地址 = 段地址 * 16 + 偏移地址。

因此，偏移地址的计算公式是：偏移地址 = 物理地址 - 段地址 * 16。

偏移地址是16位的，所以它的最大值是 FFFFH。因此，我们可以得到段地址的最小值和最大值：

- SA 的最小值：当偏移地址最大（即 FFFFH）时，SA 的值最小。所以，SAmin = (20000H - FFFFH) / 16 = 1001H。

- SA 的最大值：当偏移地址为0时，SA 的值最大。所以，SAmax = 20000H / 16 = 2000H。

所以，如果想用偏移地址找到存放在内存 20000H 单元中的数据，段地址 SA 应满足的条件是，最小为 1001H，最大为 2000H。这样，无论 SA 取值在这个范围内的哪一个值，都可以通过一个合适的偏移地址找到 20000H 单元。</contents></text><underline page="36" rect="36.970,163.680,307.691,179.280" color="#A6A1E6" flags="print" name="9ba39f47-eb66-b8ab-3048-7c300981f312" title="Guest" subject="下划线" date="D:20240330212510+08'00'" creationdate="D:20240330212510+08'00'" coords="155.29,179.27999999999997,307.6906,179.27999999999997,155.29,173.51999999999998,307.6906,173.51999999999998,36.97,169.44,300.96999999999997,169.44,36.97,163.68,300.96999999999997,163.68"><contents>这里，需要看一下，是什么部件提供段地址。段地
址在 8086CPU 的段寄存器中存放。 8086CPU 有 4 个段寄存器 ： CS 、 DS 、 SS 、 ES。</contents></underline><underline page="36" rect="138.721,84.240,259.690,90" color="#A6A1E6" flags="print" name="38b7592c-13ea-2cea-466e-46c3ae03197b" title="Guest" subject="下划线" date="D:20240330212622+08'00'" creationdate="D:20240330212622+08'00'" coords="138.72096,90,259.68999999999994,90,138.72096,84.24000000000001,259.68999999999994,84.24000000000001"><contents>设 CS 中的内容为 M, IP 中的内容为 N,</contents></underline><text page="36" rect="236.570,94.110,267.570,125.110" color="#FFCD45" flags="print,nozoom,norotate" name="a381d251-99a8-a66b-aa90-d264714a6ef7" title="Guest" subject="注释" date="D:20240330213003+08'00'" creationdate="D:20240330213000+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;偏移地址可以存储在多个地方，这取决于它们的用途。例如，指令指针寄存器（IP）存储的是下一条要执行的指令的偏移地址。其他偏移地址可能存储在通用寄存器或索引寄存器中。\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>偏移地址可以存储在多个地方，这取决于它们的用途。例如，指令指针寄存器（IP）存储的是下一条要执行的指令的偏移地址。其他偏移地址可能存储在通用寄存器或索引寄存器中。</contents></text><underline page="43" rect="36.970,318.960,307.440,335.050" color="#A6A1E6" flags="print" name="494a83c3-b50e-4276-cdfb-87108954528e" title="Guest" subject="下划线" date="D:20240330213650+08'00'" creationdate="D:20240330213650+08'00'" coords="181.6653,335.04999999999995,307.44,335.04999999999995,181.6653,329.28999999999996,307.44,329.28999999999996,36.97,324.71999999999997,100.80080000000001,324.71999999999997,36.97,318.96,100.80080000000001,318.96"><contents>我们可以说 ， CPU 将 CS:IP 指向的内存单
元中的内容看作指令，</contents></underline><underline page="43" rect="36.720,160.810,307.450,176.880" color="#A6A1E6" flags="print" name="bfc2e3bb-56a3-7a07-7123-e6d9593405c3" title="Guest" subject="下划线" date="D:20240330213731+08'00'" creationdate="D:20240330213731+08'00'" coords="71.28,176.88,307.45000000000005,176.88,71.28,171.12,307.45000000000005,171.12,36.720000000000006,166.33010000000002,66.73,166.33010000000002,36.720000000000006,160.81,66.73,160.81"><contents>mov 指令不能用千设置 CS 、 IP 的值，原因很简单，因为 8086CPU 没有提供这
样的功能。</contents></underline><underline page="43" rect="95.760,140.170,125.040,145.690" color="#A6A1E6" flags="print" name="fca27c30-ce5c-d56f-088c-0e0a4bca43a8" title="Guest" subject="下划线" date="D:20240330213741+08'00'" creationdate="D:20240330213741+08'00'" coords="95.76,145.69009999999997,125.04,145.69009999999997,95.76,140.16999999999996,125.04,140.16999999999996"><contents>jmp 指令。</contents></underline><underline page="43" rect="36.970,72.720,307.450,88.800" color="#A6A1E6" flags="print" name="465bd9a8-acfa-456c-9476-d1f2e3132d2c" title="Guest" subject="下划线" date="D:20240330213945+08'00'" creationdate="D:20240330213945+08'00'" coords="53.53,88.80000000000001,307.45,88.80000000000001,53.53,83.04000000000002,307.45,83.04000000000002,36.97,78.24009999999998,60.72,78.24009999999998,36.97,72.72000000000003,60.72,72.72000000000003"><contents>勹mp 段地址偏移地址”指令的功能为 ． 用指令中给出的段地址修改 cs , 偏移地址
修改 IP 。</contents></underline><square page="34" rect="31.340,142.910,326.640,227.770" color="#007A3B" flags="print" name="a356e664-be2b-0d18-347a-ef0a959877e6" title="Guest" subject="矩形" date="D:20240330214058+08'00'" creationdate="D:20240330214057+08'00'"/><square page="37" rect="18.530,309.200,346,467.480" color="#007A3B" flags="print" name="bc2f0b42-8fb9-ce02-c944-8c32f9ccb193" title="Guest" subject="矩形" date="D:20240330214111+08'00'" creationdate="D:20240330214109+08'00'"/><underline page="45" rect="36.720,197.040,307.450,233.760" color="#A6A1E6" flags="print" name="09e592c5-b9cd-2606-1387-327bb05c5a63" title="Guest" subject="下划线" date="D:20240330214335+08'00'" creationdate="D:20240330214335+08'00'" coords="142.1201,233.76,307.45,233.76,142.1201,228,307.45,228,36.97,223.44,307.2001,223.44,36.97,217.68,307.2001,217.68,36.720000000000006,213.13,307.45,213.13,36.720000000000006,207.37,307.45,207.37,36.97,202.56009999999998,50.57,202.56009999999998,36.97,197.03999999999996,50.57,197.03999999999996"><contents>在编程时，可以根据需要，将一组内存单元定义为一个
段。我们可以将长度为 N(N,S 64KB)的一组代码 ， 存在一组地址连续 、 起始地址为 1 6 的
倍数的 内存单元中 ，我们可以认为，这段内存是用来存放代码的 ， 从而定义了一个代码
段。</contents></underline><square page="46" rect="42.320,31.510,298.960,125.060" color="#007A3B" flags="print" name="5c29be27-5c2f-63a1-89b7-682780edff41" title="Guest" subject="矩形" date="D:20240330214952+08'00'" creationdate="D:20240330214951+08'00'"/><underline page="58" rect="36.970,277.200,229.691,313.680" color="#A6A1E6" flags="print" name="0b42d633-1a62-790e-8505-3c82a2f7a947" title="Guest" subject="下划线" date="D:20240331150619+08'00'" creationdate="D:20240331150619+08'00'" coords="124.2552,313.67999999999995,229.68,313.67999999999995,124.2552,307.91999999999996,229.68,307.91999999999996,36.97,303.1301,229.69060000000002,303.1301,36.97,297.61,229.69060000000002,297.61,37.21,293.28,225.12,293.28,37.21,287.52,225.12,287.52,36.97,282.96,139.76999999999998,282.96,36.97,277.2,139.76999999999998,277.2"><contents>在内存中存储时，由千内存单元是
字节单元（一个单元存放一个字节），则一个字要用两个地址连续
的内存单元来存放，这个字的低位字节存放在低地址单元中 ，
高位字节存放在高地址单元中 。</contents></underline><underline page="58" rect="126.934,133.930,266.214,139.450" color="#A6A1E6" flags="print" name="3f4ea143-3c5c-af81-d380-f28208a5aed6" title="Guest" subject="下划线" date="D:20240331150854+08'00'" creationdate="D:20240331150854+08'00'" coords="126.93360000000001,139.45010000000002,266.214,139.45010000000002,126.93360000000001,133.93,266.214,133.93"><contents>起始地址为 N 的字单元简称为 N 地址字单元</contents></underline><underline page="58" rect="36.720,150,307.691,176.880" color="#A6A1E6" flags="print" name="22d0405e-e6cf-3c8f-d0d1-7ebdb421e5d6" title="Guest" subject="下划线" date="D:20240331151200+08'00'" creationdate="D:20240331151200+08'00'" coords="126.96000000000001,176.88,307.691,176.88,126.96000000000001,171.12,307.691,171.12,36.97,166.32999999999998,307.2001,166.32999999999998,36.97,160.57,307.2001,160.57,36.720000000000006,155.76,115.20000000000002,155.76,36.720000000000006,150,115.20000000000002,150"><contents>字单元，即存放一个字型数据(1 6 位）的内存单元，由两个地
址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中
存放字型数据的低位字节。</contents></underline><underline page="59" rect="206.880,219.600,238.080,225.360" color="#A6A1E6" flags="print" name="b0fce95e-625b-d69e-a0da-92aecf2a1787" title="Guest" subject="下划线" date="D:20240331151256+08'00'" creationdate="D:20240331151256+08'00'" coords="206.88000000000002,225.36,238.0803,225.36,206.88000000000002,219.60000000000002,238.0803,219.60000000000002"><contents>DS 寄存器</contents></underline><underline page="60" rect="36.970,427.450,307.451,443.520" color="#A6A1E6" flags="print" name="d45e1c0d-2a55-dcf0-6318-1c76a933aaba" title="Guest" subject="下划线" date="D:20240331151747+08'00'" creationdate="D:20240331151747+08'00'" coords="279.0044,443.52,307.45079999999996,443.52,279.0044,437.76,307.45079999999996,437.76,36.97,432.9701,202.56000000000003,432.9701,36.97,427.45,202.56000000000003,427.45"><contents>指令执行
时， 8086CPU 自动取 ds 中的数据为内存单元的段地址 。</contents></underline><underline page="59" rect="53.530,47.760,272.954,53.280" color="#A6A1E6" flags="print" name="a0ddeead-a0a2-a352-9bde-eb23c11bfa6b" title="Guest" subject="下划线" date="D:20240331151828+08'00'" creationdate="D:20240331151828+08'00'" coords="53.53,53.280100000000004,135.36,53.280100000000004,53.53,47.75999999999999,135.36,47.75999999999999,143.76,53.280100000000004,272.9544,53.280100000000004,143.76,47.75999999999999,272.9544,47.75999999999999"><contents>“[…］”表示一个内存单元， “ [ …］” 中的 0 表示内存单元的偏移地址。</contents></underline><underline page="60" rect="36.470,277.200,307.450,303.610" color="#A6A1E6" flags="print" name="4bd4708e-dfc1-9a69-4404-df724cbb115d" title="Guest" subject="下划线" date="D:20240331152112+08'00'" creationdate="D:20240331152112+08'00'" coords="65.76,303.61,307.20029999999997,303.61,65.76,297.85,307.20029999999997,297.85,36.47,293.28,307.45000000000005,293.28,36.47,286.1247782,307.45000000000005,286.1247782,36.97,282.96,282.48,282.96,36.97,277.2,282.48,277.2"><contents>8086CPU 不支持将数据直接送入段寄存器的操作， ds 是一个段寄存器，所以
mov ds, lOOOH 这条指令是非法的。那么如何将 1000H 送入 ds 呢？只好用一个寄存器来进
行中转，即先将 1000H 送入一个一般的寄存器，如 bx, 再将 bx 中的内容送入 ds 。</contents></underline><underline page="61" rect="110.880,409.680,203.770,422.400" color="#A6A1E6" flags="print" name="61c262fd-89c5-3cb2-9a0a-5b5f69c06529" title="Guest" subject="下划线" date="D:20240331153038+08'00'" creationdate="D:20240331153038+08'00'" coords="113.64009999999999,422.40000000000003,192.2402,422.40000000000003,113.64009999999999,417.6,192.2402,417.6,110.88,414.2401,203.77,414.2401,110.88,409.68,203.77,409.68"><contents>1 000 : 0 处的字型数据送入 ax
;ex 中的 16 位数据送到 1000 : 0 处</contents></underline><underline page="65" rect="56.987,72.961,184.800,79.099" color="#A6A1E6" flags="print" name="77b1a8b5-0ebe-67a9-e47f-33473356d21c" title="Guest" subject="下划线" date="D:20240331154506+08'00'" creationdate="D:20240331154506+08'00'" coords="56.9871514,79.0990898,184.80040000000002,79.0990898,56.9871514,72.9609782,184.80040000000002,72.9609782"><contents>[ address]表示一个偏移地址为 addJ·ess 的内存单元。</contents></underline><underline page="69" rect="136.090,437.760,257.760,443.280" color="#A6A1E6" flags="print" name="537d26a4-cf2e-d5cf-13de-b84485b3c865" title="Guest" subject="下划线" date="D:20240331160338+08'00'" creationdate="D:20240331160338+08'00'" coords="136.09,443.2801,257.76,443.2801,136.09,437.76,257.76,437.76"><contents>lOOOOH~lOOOFH 这段内存当作栈来使用。</contents></underline><underline page="70" rect="164.280,308.640,245.290,314.400" color="#A6A1E6" flags="print" name="4ab11c86-8a84-a208-4105-f8778e27c221" title="Guest" subject="下划线" date="D:20240331160425+08'00'" creationdate="D:20240331160425+08'00'" coords="164.2804,314.40000000000003,245.29,314.40000000000003,164.2804,308.64000000000004,245.29,308.64000000000004"><contents>段寄存器 SS 和寄存器 SP</contents></underline><squiggly page="71" rect="36.720,70.560,306.962,98.400" color="#E44234" flags="print" name="cdec5d39-56ae-824a-6b93-7a1dbd8376fd" title="Guest" subject="曲线" date="D:20240331161357+08'00'" creationdate="D:20240331161357+08'00'" coords="50.65,98.39999999999998,200.88,98.39999999999998,50.65,92.63999999999999,200.88,92.63999999999999,50.57,87.43708979999997,306.9625,87.43708979999997,50.57,80.18297819999998,306.9625,80.18297819999998,36.720000000000006,76.32,53.28,76.32,36.720000000000006,70.56,53.28,70.56"><contents>( 1 ) 将 SS:SP 指向的内存单元处的数据送入 ax 中：
(2) SP~SP+2 , SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的
栈顶 。</contents></squiggly><underline page="80" rect="36.720,323.040,307.440,339.120" color="#A6A1E6" flags="print" name="8409794d-bd5f-dbd2-8846-e6901f56ad99" title="Guest" subject="下划线" date="D:20240331162132+08'00'" creationdate="D:20240331162132+08'00'" coords="273.61,339.12,307.44,339.12,273.61,333.35808000000003,307.44,333.35808000000003,36.720000000000006,328.8,272.15999999999997,328.8,36.720000000000006,323.04,272.15999999999997,323.04"><contents>如果再次压
栈，栈顶将环绕，覆盖了原来栈中的内容。 所以一个栈段的容星最大为 64KB .</contents></underline><text page="79" rect="176.340,169.390,207.340,200.390" color="#FFCD45" flags="print,nozoom,norotate" name="decd8837-0c6f-cf99-480f-bc7e7b4687d3" title="Guest" subject="注释" date="D:20240331163110+08'00'" creationdate="D:20240331163108+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;当达到最大地址FFFFH之后，再加1会回到地址空间的起始位置，即地址0000H。这种现象称为地址环绕或地址回卷\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>当达到最大地址FFFFH之后，再加1会回到地址空间的起始位置，即地址0000H。这种现象称为地址环绕或地址回卷</contents></text><underline page="88" rect="50.880,151.680,268.801,173.756" color="#A6A1E6" flags="print" name="dff67b7e-c07a-ab3a-c3b7-5396bf130243" title="Guest" subject="下划线" date="D:20240331195643+08'00'" creationdate="D:20240331195643+08'00'" coords="51.11,173.75559999999996,80.16,173.75559999999996,51.11,165.72039999999998,80.16,165.72039999999998,50.879999999999995,157.20010000000002,268.8007,157.20010000000002,50.879999999999995,151.68,268.8007,151.68"><contents>1 伪指令
在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。</contents></underline><squiggly page="89" rect="36.970,401.520,307.440,427.690" color="#E44234" flags="print" name="0828a60b-9271-0802-40e9-63cf54747256" title="Guest" subject="曲线" date="D:20240331195721+08'00'" creationdate="D:20240331195721+08'00'" coords="50.65,427.69010000000003,302.8915,427.69010000000003,50.65,422.17,302.8915,422.17,36.97,417.37010000000004,307.44000000000005,417.37010000000004,36.97,411.85,307.44000000000005,411.85,36.97,407.28,112.8002,407.28,36.97,401.52,112.8002,401.52"><contents>segment 和 ends 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，
必须要用到的一对伪指令。 segment 和 ends 的功能是定义一个段， segment 说明一个段开
始， ends 说明一个段结束</contents></squiggly><underline page="89" rect="50.810,326.455,269.040,349.667" color="#A6A1E6" flags="print" name="feeb480f-7244-d0c4-7bc8-56b80a77c31a" title="Guest" subject="下划线" date="D:20240331195837+08'00'" creationdate="D:20240331195837+08'00'" coords="50.809999999999995,349.66728979999993,99.94505339999999,349.66728979999993,50.809999999999995,342.52477819999996,99.94505339999999,342.52477819999996,120.48,348.48009999999994,269.04019999999997,348.48009999999994,120.48,343.91999999999996,269.04019999999997,343.91999999999996,50.809999999999995,333.5972898,89.3546828,333.5972898,50.809999999999995,326.4547782,89.3546828,326.4547782,120.48,332.4101,209.76,332.4101,120.48,327.85,209.76,327.85"><contents>codesg segment
； 定义一个段，段的名称为 “codesg", 这个段从此开始
codesg ends
； 名称为 “codesg" 的段到此结束</contents></underline><underline page="89" rect="36.720,286.570,307.441,312.720" color="#A6A1E6" flags="print" name="91f0dc28-a224-0f4c-7eea-9331338818e2" title="Guest" subject="下划线" date="D:20240331195939+08'00'" creationdate="D:20240331195939+08'00'" coords="50.879999999999995,312.7201,307.44089999999994,312.7201,50.879999999999995,307.2,307.44089999999994,307.2,36.97,302.65,307.44059999999996,302.65,36.97,296.89,307.44059999999996,296.89,36.720000000000006,292.33,281.76,292.33,36.720000000000006,286.57,281.76,286.57"><contents>一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使
用 。 我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源
程序中所有将被计算机所处理的信息 ： 指令、数据、栈，被划分到了不同的段中 。</contents></underline><underline page="89" rect="36.720,167.520,302.880,183.610" color="#A6A1E6" flags="print" name="0ed87233-6757-93cd-d450-563801dae91b" title="Guest" subject="下划线" date="D:20240331200034+08'00'" creationdate="D:20240331200034+08'00'" coords="148.57,183.61,302.88,183.61,148.57,177.85000000000002,302.88,177.85000000000002,36.720000000000006,173.27999999999997,302.88,173.27999999999997,36.720000000000006,167.51999999999998,302.88,167.51999999999998"><contents>ends 是和 segment 成对使用的，标记一个段的结束，
ends 的含义可理解为 “ end segment " 。 我们这里讲的 end 的作用是标记整个程序的结束 。</contents></underline><underline page="89" rect="36.630,115.680,307.451,142.080" color="#A6A1E6" flags="print" name="f1dea79c-3983-c4dd-a21f-925f1b097665" title="Guest" subject="下划线" date="D:20240331200111+08'00'" creationdate="D:20240331200111+08'00'" coords="186.9225,142.08000000000004,306.96000000000004,142.08000000000004,186.9225,136.32000000000005,306.96000000000004,136.32000000000005,36.63,131.74728979999998,307.4512,131.74728979999998,36.63,124.6047782,307.4512,124.6047782,36.720000000000006,121.44,173.28,121.44,36.720000000000006,115.68,173.28,115.68"><contents>某一段寄存器和程序中的某一个用
segment. .. ends 定义的段相关联 。 通过 assume 说明这种关联，在需要的情况下，编译程
序可以将段寄存器和某一个具体的段相联系 。</contents></underline><underline page="90" rect="60.240,434.400,118.800,440.160" color="#A6A1E6" flags="print" name="a2109720-c31a-ba75-4292-18afe012e45b" title="Guest" subject="下划线" date="D:20240331200225+08'00'" creationdate="D:20240331200225+08'00'" coords="60.24,440.15999999999997,118.80000000000001,440.15999999999997,60.24,434.4,118.80000000000001,434.4"><contents>源程序中的 “ 程序 ”</contents></underline><underline page="90" rect="50.650,130.570,94.080,136.330" color="#A6A1E6" flags="print" name="3ab390d3-6546-f23e-b202-f7d011bb0f84" title="Guest" subject="下划线" date="D:20240331200426+08'00'" creationdate="D:20240331200426+08'00'" coords="50.65,136.32999999999998,94.08,136.32999999999998,50.65,130.57,94.08,130.57"><contents>4 程序的结构</contents></underline><underline page="92" rect="36.970,236.400,302.890,252.490" color="#A6A1E6" flags="print" name="056902a8-eb87-8570-8268-da0a6dc7dfac" title="Guest" subject="下划线" date="D:20240331200711+08'00'" creationdate="D:20240331200711+08'00'" coords="106.2216,252.48999999999998,302.8903,252.48999999999998,106.2216,246.73,302.8903,246.73,36.97,242.16,140.22,242.16,36.97,236.4,140.22,236.4"><contents>一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，
我们称这个过程为 ： 程序返回 。</contents></underline><underline page="92" rect="50.390,187.637,92.958,201.659" color="#A6A1E6" flags="print" name="6a98592f-e7c5-84fe-9d01-1f8b3980e90e" title="Guest" subject="下划线" date="D:20240331200738+08'00'" creationdate="D:20240331200738+08'00'" coords="50.39,201.6592898,92.9575336,201.6592898,50.39,195.63277819999996,92.9575336,195.63277819999996,50.809999999999995,193.9986,75.1957088,193.9986,50.809999999999995,187.6374,75.1957088,187.6374"><contents>mov ax , 4c00H
int 21H</contents></underline><square page="92" rect="29.190,40.530,319.750,112.830" color="#007A3B" flags="print" name="12ff90ba-ea18-c050-2ee9-14d172428430" title="Guest" subject="矩形" date="D:20240331200808+08'00'" creationdate="D:20240331200806+08'00'"/><square page="94" rect="19.090,208.480,325.140,298.300" color="#007A3B" flags="print" name="7d557d38-5245-7ce2-5488-9aeb94d43272" title="Guest" subject="矩形" date="D:20240331200930+08'00'" creationdate="D:20240331200928+08'00'"/><square page="96" rect="19.090,43.670,332.100,199.280" color="#007A3B" flags="print" name="3da1385c-9eb3-6a06-5e1d-6a7d1174763d" title="Guest" subject="矩形" date="D:20240331201131+08'00'" creationdate="D:20240331201128+08'00'"/><square page="101" rect="35.030,61.630,310.090,110.130" color="#007A3B" flags="print" name="c1a9a032-f549-f611-287b-c3e7cf10f0f6" title="Guest" subject="矩形" date="D:20240331201933+08'00'" creationdate="D:20240331201930+08'00'"/><square page="103" rect="37.190,211.880,315.410,435.020" color="#007A3B" flags="print" name="911e4f1a-42bb-7274-6311-84c54222ab4d" title="Guest" subject="矩形" date="D:20240331202332+08'00'" creationdate="D:20240331202331+08'00'"/><underline page="106" rect="50.880,379.200,266.890,384.720" color="#A6A1E6" flags="print" name="9c55b562-f0a6-1237-4f2b-eb5898ef24d9" title="Guest" subject="下划线" date="D:20240401083038+08'00'" creationdate="D:20240401083038+08'00'" coords="50.879999999999995,384.7201,266.89000000000004,384.7201,50.879999999999995,379.2,266.89000000000004,379.2"><contents>[bx]是什么呢？和[O]有些类似， ［0］表示内存单元，它的偏移地址是 0。</contents></underline><squiggly page="106" rect="36.970,184.320,307.451,229.210" color="#E44234" flags="print" name="c284011a-ce12-01ef-cce0-968009213ba9" title="Guest" subject="曲线" date="D:20240401083353+08'00'" creationdate="D:20240401083353+08'00'" coords="50.879999999999995,229.21000000000004,268.32,229.21000000000004,50.879999999999995,223.45000000000005,268.32,223.45000000000005,50.63,215.92680000000001,89.2448,215.92680000000001,50.63,208.56119999999999,89.2448,208.56119999999999,50.65,200.40999999999997,307.45050000000003,200.40999999999997,50.65,194.64999999999998,307.45050000000003,194.64999999999998,36.97,189.8401,156.23999999999998,189.8401,36.97,184.32000000000005,156.23999999999998,184.32000000000005"><contents>[bx] 同样也表示一个内存单元，它的偏移地址在 bx 中，比如下面的指令 ：
mov ax , [bx ]
将一个内存单元的内容送入 ax, 这个内存单元的长度为 2 字节（字单元），存放一个
字，偏移地址在 bx 中，段地址在 ds 中。</contents></squiggly><underline page="106" rect="36.720,63.600,307.450,79.440" color="#A6A1E6" flags="print" name="f4b20b84-30cd-cc8c-233d-3a26e40050fb" title="Guest" subject="下划线" date="D:20240401083514+08'00'" creationdate="D:20240401083514+08'00'" coords="188.53199999999998,79.44,307.45,79.44,188.53199999999998,73.68,307.45,73.68,36.720000000000006,69.36000000000001,143.05,69.36000000000001,36.720000000000006,63.60000000000002,143.05,63.60000000000002"><contents>使用一个描述性的符号”()"来表示一
个寄存器或一个内存单元中的内容 。</contents></underline><square page="107" rect="31.320,30.980,329.030,114.630" color="#007A3B" flags="print" name="e658c7f6-1dca-c1a3-4cef-0bb4afcdd6e8" title="Guest" subject="矩形" date="D:20240401083908+08'00'" creationdate="D:20240401083907+08'00'"/><square page="108" rect="17.950,309.220,331.320,425.320" color="#007A3B" flags="print" name="c7843ab0-38b2-293d-0313-3319f9d13783" title="Guest" subject="矩形" date="D:20240401084216+08'00'" creationdate="D:20240401084214+08'00'"/><underline page="112" rect="36.720,281.520,307.930,380.410" color="#A6A1E6" flags="print" name="4fe7e861-4a0b-5791-8c43-b85a1d614f53" title="Guest" subject="下划线" date="D:20240401084928+08'00'" creationdate="D:20240401084928+08'00'" coords="50.65,380.4101,77.52000000000001,380.4101,50.65,374.89,77.52000000000001,374.89,50.879999999999995,365.04999999999995,307.45,365.04999999999995,50.879999999999995,359.28999999999996,307.45,359.28999999999996,36.97,354.71999999999997,162.72,354.71999999999997,36.97,348.96,162.72,348.96,50.57,338.7270898,80.95561430000001,338.7270898,50.57,331.4729782,80.95561430000001,331.4729782,50.65,323.2801,181.2006,323.2801,50.65,317.76,181.2006,317.76,50.57,310.3135,99.8370278,310.3135,50.57,300.48749999999995,99.8370278,300.48749999999995,50.53,298.5532,307.93,298.5532,50.53,290.23,307.93,290.23,36.720000000000006,287.28,233.53000000000003,287.28,36.720000000000006,281.52,233.53000000000003,281.52"><contents>( I ) 标号
在汇编语言中，标号代表一个地址，程序 5. 1 中有一个标号 s。它实际上标识了一个
地址，这个地址处有一条指令 ： add ax,ax 。
(2) loops
CPU 执行 loops 的时候，要进行两步操作：
CD (cx)~(cx)-1 ;
@ 判断 ex 中的值，不为 0 则转至标号 s 所标识的地址处执行（这里的指令是 add
ax, ax)，如果为 0 则执行下一条指令（下一条指令是 mov ax,4c00h) 。</contents></underline><text page="121" rect="205.670,362.620,236.670,393.620" color="#FFCD45" flags="print,nozoom,norotate" name="0a83b6a2-24dd-154f-f802-75105beaa958" title="Guest" subject="注释" date="D:20240401085637+08'00'" creationdate="D:20240401085616+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;偏移地址处理方式的不同\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>偏移地址处理方式的不同</contents></text><underline page="122" rect="51.850,148.570,300.521,154.330" color="#A6A1E6" flags="print" name="05fe7ad1-1501-bc2c-0740-a4c0e199d68d" title="Guest" subject="下划线" date="D:20240401085650+08'00'" creationdate="D:20240401085650+08'00'" coords="51.849999999999994,154.32999999999998,300.5211,154.32999999999998,51.849999999999994,148.57,300.5211,148.57"><contents>目前的方法是，可将偏移地址送入 bx 寄存器中，用 [bx]的方式来访问内存单元。</contents></underline><underline page="122" rect="36.970,45.370,307.440,71.520" color="#A6A1E6" flags="print" name="4b0bcdc1-d3a0-3bc0-be87-bfca4a332a96" title="Guest" subject="下划线" date="D:20240401085735+08'00'" creationdate="D:20240401085735+08'00'" coords="276.384,71.51999999999998,302.88,71.51999999999998,276.384,65.75999999999999,302.88,65.75999999999999,36.97,61.21010000000001,307.44000000000005,61.21010000000001,36.97,55.69,307.44000000000005,55.69,36.97,50.89010000000002,50.61,50.89010000000002,36.97,45.370000000000005,50.61,45.370000000000005"><contents>这样做，
在汇编源程序中也是可以的，只不过，要在“ [ ] "的前面显式地给出段地址所在的段寄存
器。</contents></underline><underline page="123" rect="48.470,410.161,94.685,417.527" color="#A6A1E6" flags="print" name="5db109c3-06e1-557a-8d18-bd7108a3c6d6" title="Guest" subject="下划线" date="D:20240401085745+08'00'" creationdate="D:20240401085745+08'00'" coords="48.47,417.52680000000004,94.68519999999998,417.52680000000004,48.47,410.1612,94.68519999999998,410.1612"><contents>mov al , ds : [OJ</contents></underline><underline page="124" rect="64.560,411.850,277.450,417.370" color="#A6A1E6" flags="print" name="ac2a78a4-a62a-8b82-cbe9-6ccec5e21700" title="Guest" subject="下划线" date="D:20240401090022+08'00'" creationdate="D:20240401090022+08'00'" coords="64.56,417.37010000000004,277.45000000000005,417.37010000000004,64.56,411.85,277.45000000000005,411.85"><contents>我们到底怎样将 ffff:O~ffff:b 中的 8 位数据，累加到 1 6 位寄存器 dx 中？</contents></underline><underline page="124" rect="37.440,298.080,307.690,314.160" color="#A6A1E6" flags="print" name="4f50f657-2eac-83ff-4651-0311191d1928" title="Guest" subject="下划线" date="D:20240401090213+08'00'" creationdate="D:20240401090213+08'00'" coords="50.5062,314.15999999999997,307.69,314.15999999999997,50.5062,308.4,307.69,308.4,37.44,303.84,292.08,303.84,37.44,298.08,292.08,298.08"><contents>用一个 16 位寄存器来做中介。将内存单元中的 8 位数据赋值到一个 16 位寄存器 ax
中，再将 ax 中的数据加到 dx 上，从而使两个运算对象的类型匹配并且结果不会超界</contents></underline><square page="127" rect="18.070,176.300,296.440,363.640" color="#007A3B" flags="print" name="28a58154-6b96-602b-7d40-77ee47b267c4" title="Guest" subject="矩形" date="D:20240401091045+08'00'" creationdate="D:20240401091043+08'00'"/><underline page="128" rect="109.872,287.520,152.400,293.280" color="#A6A1E6" flags="print" name="07b6a27a-1406-6a53-6594-e701cdac2d67" title="Guest" subject="下划线" date="D:20240401091356+08'00'" creationdate="D:20240401091356+08'00'" coords="109.872,293.28,152.4,293.28,109.872,287.52,152.4,287.52"><contents>段地址在 es 中</contents></underline><underline page="128" rect="39.600,178.810,307.200,194.640" color="#A6A1E6" flags="print" name="ce3f916e-6ab0-df4f-432e-6d1c4bd19088" title="Guest" subject="下划线" date="D:20240401091408+08'00'" creationdate="D:20240401091408+08'00'" coords="50.879999999999995,194.64,307.2,194.64,50.879999999999995,188.88,307.2,188.88,39.6,184.33010000000002,208.56000000000003,184.33010000000002,39.6,178.81,208.56000000000003,178.81"><contents>这些出现在访问内存单元的指令中，用千显式地指明内存单元的段地址的
“ ds”“cs”“ss”“es” ，在汇编语言中称为段前缀。</contents></underline><underline page="128" rect="37.210,49.255,307.441,77.040" color="#A6A1E6" flags="print" name="b5f5be9d-b6ee-44c6-ed20-9b6669a7fe60" title="Guest" subject="下划线" date="D:20240401091521+08'00'" creationdate="D:20240401091521+08'00'" coords="50.879999999999995,77.04000000000002,307.4406,77.04000000000002,50.879999999999995,71.27999999999997,307.4406,71.27999999999997,37.21,66.73000000000002,307.2004,66.73000000000002,37.21,60.97000000000003,307.2004,60.97000000000003,37.44,56.40999999999997,284.1709,56.40999999999997,37.44,49.254778199999976,284.1709,49.254778199999976"><contents>我们以前在 Debug 中，为了讲解上的方便，写过类似的指令 。 但这种做法是不合理
的 ， 因为之前我们并没有论证过 1000: 0 中是否存放着重要的系统数据或代码。如果
1000:0 中存放着重要的系统数据或代码， “mov ds: [O] ,al " 将其改写，将引发错误。</contents></underline><underline page="130" rect="36.970,426,307.210,442.080" color="#A6A1E6" flags="print" name="b60089e9-52a2-f4e5-1029-698fc55e925a" title="Guest" subject="下划线" date="D:20240401091754+08'00'" creationdate="D:20240401091754+08'00'" coords="71.5029,442.08,307.21029999999996,442.08,71.5029,436.32,307.21029999999996,436.32,36.97,431.76,80.64000000000001,431.76,36.97,426,80.64000000000001,426"><contents>在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向
其中写入内容 。</contents></underline><underline page="130" rect="36.720,197.760,303.600,224.640" color="#A6A1E6" flags="print" name="03f01ac2-7df0-1c19-e6c6-e6609a9d99da" title="Guest" subject="下划线" date="D:20240401092042+08'00'" creationdate="D:20240401092042+08'00'" coords="203.29,224.64010000000002,302.89,224.64010000000002,203.29,219.12,302.89,219.12,36.720000000000006,214.08000000000004,303.59999999999997,214.08000000000004,36.720000000000006,208.32000000000005,303.59999999999997,208.32000000000005,36.720000000000006,203.2801,148.33,203.2801,36.720000000000006,197.76,148.33,197.76"><contents>在一般的 PC 机中 ， DOS 方式下，
DOS 和其他合法的程序一般都不会使用 0:200~0:2ff(00200h~002ffh)的 256 个字节的空间。
所以，我们使用这段空间是安全的。</contents></underline><underline page="131" rect="152.880,304.080,216.250,308.880" color="#A6A1E6" flags="print" name="03b4fb4a-7ce2-c3f8-acb7-af03366bc90b" title="Guest" subject="下划线" date="D:20240401092649+08'00'" creationdate="D:20240401092649+08'00'" coords="152.88000000000002,308.88,216.25,308.88,152.88000000000002,304.08,216.25,304.08"><contents>（需要用一个寄存器中转）</contents></underline><underline page="134" rect="36.970,337.920,307.442,354" color="#A6A1E6" flags="print" name="1661fe98-5207-7c97-df2b-0237685bf22d" title="Guest" subject="下划线" date="D:20240401092846+08'00'" creationdate="D:20240401092846+08'00'" coords="50.879999999999995,354,307.44169999999997,354,50.879999999999995,348.24,307.44169999999997,348.24,36.97,343.67999999999995,238.27640000000002,343.67999999999995,36.97,337.91999999999996,238.27640000000002,337.91999999999996"><contents>在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不
会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。</contents></underline><underline page="134" rect="36.970,301.920,307.452,318" color="#A6A1E6" flags="print" name="0a63bda3-3bb9-4165-4dca-b656b9b569cb" title="Guest" subject="下划线" date="D:20240401092923+08'00'" creationdate="D:20240401092923+08'00'" coords="50.65,318,307.4522,318,50.65,312.24,307.4522,312.24,36.97,307.67999999999995,119.64999999999999,307.67999999999995,36.97,301.91999999999996,119.64999999999999,301.91999999999996"><contents>程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在
执行的过程中向系统申诸。</contents></underline><underline page="134" rect="36.970,213.850,307.450,229.680" color="#A6A1E6" flags="print" name="640483aa-e30d-463f-64ef-ac3edcac71de" title="Guest" subject="下划线" date="D:20240401093053+08'00'" creationdate="D:20240401093053+08'00'" coords="93.91319999999999,229.68009999999998,307.4502,229.68009999999998,93.91319999999999,224.15999999999997,307.4502,224.15999999999997,36.97,219.61,267.85,219.61,36.97,213.85000000000002,267.85,213.85000000000002"><contents>大多数有用的程序，都要处理数据，使用栈空间，当然也都必须有指
令，为了程序设计上的清晰和方便，我们一般也都定义不同的段来存放它们 。</contents></underline><underline page="135" rect="36.970,183.600,303.600,199.440" color="#A6A1E6" flags="print" name="d84fb795-01b6-8b79-c615-57801191b607" title="Guest" subject="下划线" date="D:20240401093410+08'00'" creationdate="D:20240401093410+08'00'" coords="233.29,199.44,303.59999999999997,199.44,233.29,194.15999999999997,303.59999999999997,194.15999999999997,36.97,189.36,232.42,189.36,36.97,183.60000000000002,232.42,183.60000000000002"><contents>dw 即 “ define word " 。
在这里，使用 dw 定义了 8 个字型数据（数据之间以逗号分隔），</contents></underline><underline page="136" rect="36.720,81.360,307.440,107.520" color="#A6A1E6" flags="print" name="72d11e9a-5a51-e0eb-f189-0c13c790f812" title="Guest" subject="下划线" date="D:20240401093816+08'00'" creationdate="D:20240401093816+08'00'" coords="110.65620000000001,107.52010000000001,307.44,107.52010000000001,110.65620000000001,102,307.44,102,36.720000000000006,97.44,307.4376,97.44,36.720000000000006,91.68,307.4376,91.68,36.97,86.88009999999997,53.05029999999999,86.88009999999997,36.97,81.36000000000001,53.05029999999999,81.36000000000001"><contents>我们可以看到程序加载到内存中后，所占内存空间的前 1 6 个单元
存放在源程序中用 “ dw" 定义的数据， 后面的单元存放源程序中汇编指令所对应的机器
指令。</contents></underline><underline page="137" rect="193.630,199.681,295.441,206.640" color="#A6A1E6" flags="print" name="6f90caa6-3ec6-a142-7c23-24fa1512711e" title="Guest" subject="下划线" date="D:20240401093906+08'00'" creationdate="D:20240401093906+08'00'" coords="193.63,206.64,295.44100000000003,206.64,193.63,199.68097820000003,295.44100000000003,199.68097820000003"><contents>“ m ov bx, O " 是程序的第一条指令。</contents></underline><underline page="137" rect="37.440,148.810,306.961,164.890" color="#A6A1E6" flags="print" name="f70d34d9-a083-7e42-ff11-c17f7d89979c" title="Guest" subject="下划线" date="D:20240401143741+08'00'" creationdate="D:20240401143741+08'00'" coords="65.28,164.89010000000002,306.9606,164.89010000000002,65.28,159.37,306.9606,159.37,37.44,154.57,52.56,154.57,37.44,148.81,52.56,148.81"><contents>由其他的程序 (Debug 、 command 或其他程序 ）将可执行文件 中 的程序加载入
内存：</contents></underline><underline page="137" rect="89.040,51.120,258.526,56.880" color="#A6A1E6" flags="print" name="c0263179-4eda-5fb2-faf4-3e760d3bdd86" title="Guest" subject="下划线" date="D:20240401144011+08'00'" creationdate="D:20240401144011+08'00'" coords="89.04,56.879999999999995,258.5263,56.879999999999995,89.04,51.120000000000005,258.5263,51.120000000000005"><contents>“ end start " 指明的程序入口，被转化为一个入口地址，</contents></underline><square page="138" rect="36.090,235.700,152.960,368.610" color="#007A3B" flags="print" name="233183af-03d2-5ed7-8437-1e43b577f595" title="Guest" subject="矩形" date="D:20240401144314+08'00'" creationdate="D:20240401144312+08'00'"/><underline page="138" rect="133.217,196.320,226.330,202.080" color="#A6A1E6" flags="print" name="f51c0616-f23b-e3fd-abcf-ddb388a82aa1" title="Guest" subject="下划线" date="D:20240401144421+08'00'" creationdate="D:20240401144421+08'00'" coords="133.2173,202.08000000000004,226.33,202.08000000000004,133.2173,196.32000000000005,226.33,196.32000000000005"><contents>将程序中定义的数据逆序存放 。</contents></underline><square page="139" rect="45.950,183.980,301.660,426.560" color="#007A3B" flags="print" name="450c5ed0-7b28-99b9-9e3f-95c590cc3cc5" title="Guest" subject="矩形" date="D:20240401145310+08'00'" creationdate="D:20240401145304+08'00'"/><underline page="139" rect="64.510,355.450,291.840,397.249" color="#A6A1E6" flags="print" name="15ff0405-6f48-c28e-0efe-b146845045c5" title="Guest" subject="下划线" date="D:20240401145354+08'00'" creationdate="D:20240401145354+08'00'" coords="64.51,397.2492898,242.23767,397.2492898,64.51,391.2227782,242.23767,391.2227782,64.51,384.0492898,185.0726326,384.0492898,64.51,378.0227782,185.0726326,378.0227782,128.65,376.09,291.84000000000003,376.09,128.65,371.28999999999996,291.84000000000003,371.28999999999996,128.65,368.16,271.68100000000004,368.16,128.65,363.36,271.68100000000004,363.36,128.65,360.25,178.0806,360.25,128.65,355.45,178.0806,355.45"><contents>dw 0123h , 0456h , 0789h , Oabch , Odefh , Ofedh , Ocbah , 0987h
dw 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0
； 用 dw 定义 16 个字型数据，在程序加载后，将取得 16 个字的
； 内存空间，存放这 16 个数据 。 在后面的程序中将这段
； 空间当作栈来使用</contents></underline><underline page="139" rect="36.970,72.480,307.452,88.320" color="#A6A1E6" flags="print" name="e750649a-1984-41ac-2bfe-4ba83caf3bc9" title="Guest" subject="下划线" date="D:20240401145515+08'00'" creationdate="D:20240401145515+08'00'" coords="57.4903,88.32010000000002,307.4525,88.32010000000002,57.4903,82.80000000000001,307.4525,82.80000000000001,36.97,78.24000000000001,127.05090000000001,78.24000000000001,36.97,72.48000000000002,127.05090000000001,72.48000000000002"><contents>程序在加载后，将用 32 个字节的内存空间来存放它们。这段内存空间是我们所需
要的，程序将它用作栈空间。</contents></underline><underline page="140" rect="36.720,403.920,307.440,430.330" color="#A6A1E6" flags="print" name="bdda10c9-50e0-ccdf-2255-0043408a7f3e" title="Guest" subject="下划线" date="D:20240401145632+08'00'" creationdate="D:20240401145632+08'00'" coords="50.879999999999995,430.33,307.4403,430.33,50.879999999999995,424.57,307.4403,424.57,36.720000000000006,419.7601,303.36,419.7601,36.720000000000006,414.24,303.36,414.24,36.720000000000006,409.4401,153.36,409.4401,36.720000000000006,403.91999999999996,153.36,403.91999999999996"><contents>可以说，定义了 8 个字型数据 ， 也可以说，开辟了 8 个字的内存空间，这段空间中每
个字单元 中 的数据依次是 ： 0123h 、 0456h 、 0789h 、 Oabch 、 Odefh 、 Ofedh 、 Ocbah 、
0987h 。 因为它们最终的效果是一样的 。</contents></underline><underline page="140" rect="111.520,363.874,266.651,370.800" color="#A6A1E6" flags="print" name="30e18a9b-41b4-2ff8-a609-2a52b37a0e64" title="Guest" subject="下划线" date="D:20240401145828+08'00'" creationdate="D:20240401145828+08'00'" coords="111.52000000000001,370.8,266.6506,370.8,111.52000000000001,363.87357840000004,266.6506,363.87357840000004"><contents>依次用内存 0:0-0:15 单元中的内容改写程序中的数据</contents></underline><underline page="135" rect="36.970,116.640,307.690,163.450" color="#A6A1E6" flags="print" name="b1151aa8-908d-01ea-94a4-9ef6ea208c53" title="Guest" subject="下划线" date="D:20240401150907+08'00'" creationdate="D:20240401150907+08'00'" coords="259.28,163.45010000000002,307.44,163.45010000000002,259.28,157.93,307.44,157.93,36.97,153.12009999999998,307.69,153.12009999999998,36.97,147.60000000000002,307.69,147.60000000000002,36.97,142.81009999999998,307.69,142.81009999999998,36.97,137.28999999999996,307.69,137.28999999999996,36.97,132.4801,307.441,132.4801,36.97,126.96000000000004,307.441,126.96000000000004,37.21,122.1601,238.33,122.1601,37.21,116.63999999999999,238.33,116.63999999999999"><contents>由千它们在代码
段中，程序在运行的时候 CS 中存放代码段的段地址，所以可以从 CS 中得到它们的段地
址。它们的偏移地址是多少呢？因为用 dw 定义的数据处千代码段的最开始，所以偏移地
址为 o, 这 8 个数据就在代码段的偏移 0 、 2 、 4 、 6 、 8 、 A、 C 、 E 处。程序运行时，它们
的地址就是 CS:O 、 CS:2 、 CS:4 、 CS:6 、 CS:8 、 CS:A 、 CS:C 、 CS:E 。</contents></underline><underline page="141" rect="71.359,225.850,198.490,231.610" color="#A6A1E6" flags="print" name="f602cb69-591d-3f9e-2f74-38893832d414" title="Guest" subject="下划线" date="D:20240401151901+08'00'" creationdate="D:20240401151901+08'00'" coords="71.3587,231.61,198.49,231.61,71.3587,225.85000000000002,198.49,225.85000000000002"><contents>应该考虑用多个段来存放数据、代码和栈。</contents></underline><square page="141" rect="45.450,35.190,257.990,168.290" color="#007A3B" flags="print" name="04dbb441-7261-4496-eff9-8f3dc508fe38" title="Guest" subject="矩形" date="D:20240401152103+08'00'" creationdate="D:20240401152101+08'00'"/><square page="142" rect="47.550,266.630,286.250,449.770" color="#007A3B" flags="print" name="b78f3df6-5647-8c82-d37a-dcd2fa969cd2" title="Guest" subject="矩形" date="D:20240401152110+08'00'" creationdate="D:20240401152106+08'00'"/><underline page="141" rect="78.230,53.793,120.783,59.819" color="#A6A1E6" flags="print" name="5847e3de-34da-ca1b-ed26-c6e0ee45f408" title="Guest" subject="下划线" date="D:20240401152620+08'00'" creationdate="D:20240401152620+08'00'" coords="78.23,59.81928979999998,120.7833686,59.81928979999998,78.23,53.79277819999999,120.7833686,53.79277819999999"><contents>mov ax, s t ack</contents></underline><underline page="142" rect="78.230,425.281,117.266,431.419" color="#A6A1E6" flags="print" name="ded99738-699a-19af-a975-ed47f4ef0d10" title="Guest" subject="下划线" date="D:20240401152623+08'00'" creationdate="D:20240401152623+08'00'" coords="78.23,431.41908979999994,117.26612,431.41908979999994,78.23,425.28097819999994,117.26612,425.28097819999994"><contents>mov ax ,data</contents></underline><underline page="142" rect="39.600,151.930,307.451,168" color="#A6A1E6" flags="print" name="2782dd6a-9316-f084-99de-afe05bb925fd" title="Guest" subject="下划线" date="D:20240401152739+08'00'" creationdate="D:20240401152739+08'00'" coords="167.29,168,307.4506,168,167.29,162.24,307.4506,162.24,39.6,157.45010000000002,127.44,157.45010000000002,39.6,151.93,127.44,151.93"><contents>以指令 “mov ax, data " 的含义就是将名称为
" data " 的段的段地址送入 ax</contents></underline><underline page="143" rect="39.600,375.850,302.890,391.440" color="#A6A1E6" flags="print" name="41a9b876-5f8c-5e10-698d-811a93c6830d" title="Guest" subject="下划线" date="D:20240401153012+08'00'" creationdate="D:20240401153012+08'00'" coords="58.21,391.4401,302.89029999999997,391.4401,58.21,385.91999999999996,302.89029999999997,385.91999999999996,39.6,381.13,279.1545,381.13,39.6,375.85,279.1545,375.85"><contents>在汇编源程序 中 ， 可以定义许多的段， 比如在程序 6.4 中 ，定义了 3 个段，
" code " 、 “ data " 和 “ stack " 。我们可以分别安排它们存放代码 、 数据和栈。</contents></underline><underline page="143" rect="36.970,267.360,307.450,309.120" color="#A6A1E6" flags="print" name="4c5870fe-90ab-524e-9223-a7835f5a4987" title="Guest" subject="下划线" date="D:20240401153222+08'00'" creationdate="D:20240401153222+08'00'" coords="50.879999999999995,309.12,307.45000000000005,309.12,50.879999999999995,303.36,307.45000000000005,303.36,36.97,298.56999999999994,123.3606,298.56999999999994,36.97,293.28999999999996,123.3606,293.28999999999996,51.120000000000005,283.21,297.11999999999995,283.21,51.120000000000005,277.45,297.11999999999995,277.45,301.91999999999996,283.21,303.35999999999996,283.21,301.91999999999996,277.45,303.35999999999996,277.45,39.6,272.8801,49.68,272.8801,39.6,267.36,49.68,267.36,54,272.8801,243.36,272.8801,54,267.36,243.36,267.36"><contents>这样命名了之后， CPU 是否就去执行 “code " 段中 的内容， 处理 ” data " 段中的数
据，将 “ stack " 当做栈了呢？
当然不是， 我们这样命名，仅仅是为了使程序便于阅读。这些名称同 “ start " 、
“ s ” 、 “ sO " 等标号一样，仅在源程序中存在， CPU 并不知道它们 。</contents></underline><underline page="143" rect="37.210,194.880,307.440,220.810" color="#A6A1E6" flags="print" name="36f6abb5-97a6-fc34-a31e-8bd609f23f68" title="Guest" subject="下划线" date="D:20240401153247+08'00'" creationdate="D:20240401153247+08'00'" coords="51.120000000000005,220.81009999999998,307.44,220.81009999999998,51.120000000000005,215.28999999999996,307.44,215.28999999999996,37.21,210.72000000000003,307.44019999999995,210.72000000000003,37.21,204.96000000000004,307.44019999999995,204.96000000000004,37.21,200.64,205.44,200.64,37.21,194.88,205.44,194.88"><contents>当然也不是 ， 要知道 assume 是伪指令，是由编译器执行的，也是仅在源程序中存在
的信息， CPU 并不知道它们 。 我们不必深究 assume 的作用， 只要知道需要用它将你定义
的具有一定用途的段和相关的寄存器联系起来就可以了 。</contents></underline><square page="144" rect="42.200,25.640,295.610,96.870" color="#007A3B" flags="print" name="a70f957e-13a9-b3ac-3bb8-e2d34a1e90a8" title="Guest" subject="矩形" date="D:20240401153553+08'00'" creationdate="D:20240401153552+08'00'"/><square page="145" rect="35.710,217.750,307.450,444.990" color="#007A3B" flags="print" name="b282c082-8d5b-4c8d-19b8-22f5de1ee745" title="Guest" subject="矩形" date="D:20240401153630+08'00'" creationdate="D:20240401153554+08'00'"/><underline page="149" rect="64.560,312.525,189.361,319.667" color="#A6A1E6" flags="print" name="001e7481-5205-29dc-1853-e7acb87e0c1d" title="Guest" subject="下划线" date="D:20240401153943+08'00'" creationdate="D:20240401153943+08'00'" coords="64.56,319.66728979999993,189.36059999999998,319.66728979999993,64.56,312.52477819999996,189.36059999999998,312.52477819999996"><contents>and 指令 ： 逻辑与指令，按位进行与运算。</contents></underline><underline page="149" rect="50.572,177.427,185.290,184.570" color="#A6A1E6" flags="print" name="e777b619-7b95-bfe5-8f27-a7475c6ec4ec" title="Guest" subject="下划线" date="D:20240401154114+08'00'" creationdate="D:20240401154114+08'00'" coords="50.57187490000001,184.57,185.29000000000002,184.57,50.57187490000001,177.42693480000003,185.29000000000002,177.42693480000003"><contents>(2) or 指令： 逻辑或指令 ， 按位进行或运算。</contents></underline><underline page="150" rect="36.967,326.170,307.453,362.650" color="#A6A1E6" flags="print" name="c0a68cf5-9a87-196b-6072-e413ce4e5475" title="Guest" subject="下划线" date="D:20240401154259+08'00'" creationdate="D:20240401154259+08'00'" coords="64.7004,362.65,307.21,362.65,64.7004,356.89,307.21,356.89,37.21,352.33,307.4527,352.33,37.21,346.57,307.4527,346.57,36.9674745,342.00232,307.2101745,342.00232,36.9674745,336.24232,307.2101745,336.24232,36.97,331.69010000000003,53.05029999999999,331.69010000000003,36.97,326.17,53.05029999999999,326.17"><contents>而我们要把这些信息存储在计郓机中，就要对其进行编码，将其转化为二进制信
息进行存储。而计算机要将这些存储的信息再显示给我们看，就要再对其进行解码。只要
编码和解码采用同样的规则，我们就可以将人能理解的信息存入到计算机，再从计算机中
取出。</contents></underline><underline page="150" rect="51.540,73.245,82.442,80.387" color="#A6A1E6" flags="print" name="22a1a43b-6547-f163-5fd7-8e4064146152" title="Guest" subject="下划线" date="D:20240401154616+08'00'" creationdate="D:20240401154616+08'00'" coords="51.54,80.38728980000002,58.31817,80.38728980000002,51.54,73.24477819999998,58.31817,73.24477819999998,63.53,80.38728980000002,82.4422955,80.38728980000002,63.53,73.24477819999998,82.4422955,73.24477819999998"><contents>db ' unIX '</contents></underline><underline page="151" rect="36.970,203.760,307.680,219.600" color="#A6A1E6" flags="print" name="b5aef984-c51a-5026-e275-d9be517e03d7" title="Guest" subject="下划线" date="D:20240401155207+08'00'" creationdate="D:20240401155207+08'00'" coords="194.83999999999997,219.60000000000002,307.68,219.60000000000002,194.83999999999997,214.32000000000005,307.68,214.32000000000005,36.97,209.2801,61.21039999999999,209.2801,36.97,203.76,61.21039999999999,203.76"><contents>因 “ ds~OB2D", 所以程序从 0B3DH
段开始，</contents></underline><underline page="151" rect="36.490,339.360,307.200,355.667" color="#A6A1E6" flags="print" name="5240dcb5-8ee6-79dd-3e18-68aa9ad02d4d" title="Guest" subject="下划线" date="D:20240403103442+08'00'" creationdate="D:20240403103442+08'00'" coords="53.4,355.66728979999993,200.5384045,355.66728979999993,53.4,348.52477819999996,200.5384045,348.52477819999996,213.5370076,355.66728979999993,230.17,355.66728979999993,213.5370076,348.52477819999996,230.17,348.52477819999996,241.93,355.19999999999993,245.05,355.19999999999993,241.93,349.91999999999996,245.05,349.91999999999996,252.96,355.19999999999993,307.2001,355.19999999999993,252.96,349.91999999999996,307.2001,349.91999999999996,36.49,344.8801,156.96,344.8801,36.49,339.36,156.96,339.36"><contents>" db'uu!X' " 相当千 “ db 75H 6EH49H 58H ”
“ u ” 、
n 、 “ I " 、 “ X " 的
ASCII 码分别为 75H、 6EH 、 49H 、 58H;</contents></underline><underline page="152" rect="67.680,381.120,233.530,386.400" color="#A6A1E6" flags="print" name="cc791742-86a0-bd81-337e-4ea14986994e" title="Guest" subject="下划线" date="D:20240403103815+08'00'" creationdate="D:20240403103815+08'00'" coords="67.67999999999999,386.4,233.53000000000003,386.4,67.67999999999999,381.12,233.53000000000003,381.12"><contents>“A " 的 ASCII 码是 41H , " a " 的 ASCII 码是 61H 。</contents></underline><underline page="152" rect="138.153,246.730,290.640,252.250" color="#A6A1E6" flags="print" name="ca118d26-ff0f-3434-7047-ea9b42406cb3" title="Guest" subject="下划线" date="D:20240403103943+08'00'" creationdate="D:20240403103943+08'00'" coords="138.153,252.25009999999997,290.64,252.25009999999997,138.153,246.73,290.64,246.73"><contents>将 “a " 的 ASCII 码值减去 20H , 就可以得到 “A ”</contents></underline><underline page="153" rect="75.600,415.943,243.196,421.969" color="#A6A1E6" flags="print" name="f79daf69-22d9-a5a3-0a60-f46aeb5a7e0f" title="Guest" subject="下划线" date="D:20240403104009+08'00'" creationdate="D:20240403104009+08'00'" coords="75.6,421.9692898,243.19570879999998,421.9692898,75.6,415.9427782,243.19570879999998,415.9427782"><contents>如果 (al) &gt;61H, 则为小写字母的 ASCII 码 ， 则 ： sub al , 20H</contents></underline><underline page="152" rect="56.760,72.721,123.861,78.859" color="#A6A1E6" flags="print" name="2712ab61-ea90-bfa5-626c-770a1d91644d" title="Guest" subject="下划线" date="D:20240403104116+08'00'" creationdate="D:20240403104116+08'00'" coords="56.760000000000005,78.85908979999999,123.86084899999999,78.85908979999999,56.760000000000005,72.72097819999999,123.86084899999999,72.72097819999999"><contents>start :mov ax , datasg</contents></underline><text page="152" rect="56.760,47.859,87.760,78.859" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="2712ab61-ea90-bfa5-626c-770a1d91644d" name="4f3a6aec-4203-e2fe-f099-4241d406fe00" title="Guest" subject="注释" date="D:20240403104235+08'00'" creationdate="D:20240403104235+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;dataasg段地址传入ax\\n\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>dataasg段地址传入ax
</contents></text><underline page="154" rect="151.210,368.170,288.010,372.970" color="#A6A1E6" flags="print" name="83c9a07d-e278-3deb-a87e-62053e8c9ebb" title="Guest" subject="下划线" date="D:20240403104631+08'00'" creationdate="D:20240403104631+08'00'" coords="151.20999999999998,372.97,288.01,372.97,151.20999999999998,368.17,288.01,368.17"><contents>将 al 中的 ASCII 码的第 5 位觉为 o, 变为大写字母</contents></underline><underline page="153" rect="36.970,184.810,307.450,210.970" color="#A6A1E6" flags="print" name="4f21dfa5-bda4-5bb3-2f33-fc4664ef5d52" title="Guest" subject="下划线" date="D:20240403104946+08'00'" creationdate="D:20240403104946+08'00'" coords="250.32000000000002,210.96999999999997,307.45,210.96999999999997,250.32000000000002,205.20999999999998,307.45,205.20999999999998,37.21,200.88,307.21000000000004,200.88,37.21,195.12,307.21000000000004,195.12,36.97,190.33010000000002,237.611,190.33010000000002,36.97,184.81,237.611,184.81"><contents>大写字母 ASCII 码
的第 5 位为 o , 小写字母的第 5 位为 1 。 这样 ， 我们就有了新的方法，一个字母，不管它
原来是大写还是小写，将它的第 5 位置 o , 它就必将变为大写字母</contents></underline><underline page="154" rect="80.160,149.760,252.901,155.280" color="#A6A1E6" flags="print" name="f3161d0d-a366-2537-5a23-0f46e2281eac" title="Guest" subject="下划线" date="D:20240403105120+08'00'" creationdate="D:20240403105120+08'00'" coords="80.16,155.2801,252.90050000000002,155.2801,80.16,149.76,252.90050000000002,149.76"><contents>［bx+idata]表示一个内存单元，它的偏移地址为(bx)+idata</contents></underline><underline page="155" rect="36.970,55.440,306.970,70.800" color="#A6A1E6" flags="print" name="00eb05bb-e391-4b53-054f-213f72570ca0" title="Guest" subject="下划线" date="D:20240403105317+08'00'" creationdate="D:20240403105317+08'00'" coords="124.04579999999999,70.80000000000001,306.96999999999997,70.80000000000001,124.04579999999999,65.04000000000002,306.96999999999997,65.04000000000002,36.97,60.96010000000001,73.69,60.96010000000001,36.97,55.44,73.69,55.44"><contents>将 datasg 中定义的第一个字符串转化为大写，第二个字符串
转化为小写。</contents></underline><underline page="156" rect="36.720,104.160,307.450,140.880" color="#A6A1E6" flags="print" name="b80620fd-7cda-2563-ade1-0d9797ad72f0" title="Guest" subject="下划线" date="D:20240403105437+08'00'" creationdate="D:20240403105437+08'00'" coords="72.24000000000001,140.88,307.45,140.88,72.24000000000001,135.12,307.45,135.12,36.720000000000006,130.32010000000002,307.20000000000005,130.32010000000002,36.720000000000006,124.80000000000001,307.20000000000005,124.80000000000001,36.97,120.24000000000001,307.20000000000005,120.24000000000001,36.97,114.48000000000002,307.20000000000005,114.48000000000002,36.97,109.92000000000002,244.33,109.92000000000002,36.97,104.15999999999997,244.33,104.15999999999997"><contents>我们有了 [bx廿data] 的方式，就可以用更简化的方法来完成上面的程序 。 观察
datasg 段中的两个字符串，一个的起始地址为 o , 另一个的起始地址为 5 。 我们可以将这
两个字符串看作两个数组，一个从 0 地址开始存放，另一个从 5 开始存放。 那么我们可以
用 [O+bx]和 [5+bx] 的方式在同一个循环中定位这两个字符串 中的字符 。</contents></underline><underline page="157" rect="89.690,233.063,105.430,239.089" color="#A6A1E6" flags="print" name="8295f45e-34bc-0743-3f97-8c0db23420e3" title="Guest" subject="下划线" date="D:20240403105524+08'00'" creationdate="D:20240403105524+08'00'" coords="89.68966239999999,239.0892898,105.42956319999999,239.0892898,89.68966239999999,233.06277819999997,105.42956319999999,233.06277819999997"><contents>5 [bx]</contents></underline><text page="157" rect="89.690,208.089,120.690,239.089" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="8295f45e-34bc-0743-3f97-8c0db23420e3" name="4048daff-6294-7ad9-fffa-9f4b7c2c6bfd" title="Guest" subject="注释" date="D:20240403105624+08'00'" creationdate="D:20240403105624+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;5[bx] = [bx + 5]\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>5[bx] = [bx + 5]</contents></text><underline page="158" rect="36.970,330.960,307.450,347.050" color="#A6A1E6" flags="print" name="a37a13d9-f1a6-2335-04ec-85954559af14" title="Guest" subject="下划线" date="D:20240403105652+08'00'" creationdate="D:20240403105652+08'00'" coords="50.65,347.04999999999995,307.45,347.04999999999995,50.65,341.28999999999996,307.45,341.28999999999996,36.97,336.4801,59.769999999999996,336.4801,36.97,330.96,59.769999999999996,330.96"><contents>Sl 和 山 是 8086CPU 中和 bx 功能相近的寄存器， si 和 山 不能够分成两个 8 位寄存器
来使用。</contents></underline><underline page="159" rect="36.970,336.480,307.442,362.880" color="#A6A1E6" flags="print" name="1b495247-6d11-7d58-5239-a885d34a3090" title="Guest" subject="下划线" date="D:20240403110405+08'00'" creationdate="D:20240403110405+08'00'" coords="246.7432,362.88,307.44,362.88,246.7432,357.12,307.44,357.12,36.97,352.56,307.4424,352.56,36.97,346.8,307.4424,346.8,36.97,342.0001,53.05029999999999,342.0001,36.97,336.47999999999996,53.05029999999999,336.47999999999996"><contents>我们用 ds : si 指向要
复制的源始字符串，用 ds山 指向复制的目的空间，然后用一个循环来完成复制。代码段
如下。</contents></underline><underline page="160" rect="36.970,242.650,307.442,258.720" color="#A6A1E6" flags="print" name="62f4827c-dbe1-ac6b-0b5f-f37a32b5ae38" title="Guest" subject="下划线" date="D:20240403110901+08'00'" creationdate="D:20240403110901+08'00'" coords="77.75999999999999,258.72,307.4416,258.72,77.75999999999999,252.96,307.4416,252.96,36.97,248.1701,105.371,248.1701,36.97,242.65,105.371,242.65"><contents>我们用 [bx(si 或 山）］和[bx(s] 或 di)+idata]的方式来指明一个内存单元，我们还
可以用更为灵活的方式</contents></underline><underline page="160" rect="50.630,113.565,102.581,120.707" color="#A6A1E6" flags="print" name="cc0ab920-8228-bfd4-251c-67b6965c1f1b" title="Guest" subject="下划线" date="D:20240403111219+08'00'" creationdate="D:20240403111219+08'00'" coords="50.63,120.70728980000001,102.58126,120.70728980000001,50.63,113.56477819999998,102.58126,113.56477819999998"><contents>mov ax , [bx ] [si]</contents></underline><text page="160" rect="50.630,89.707,81.630,120.707" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="cc0ab920-8228-bfd4-251c-67b6965c1f1b" name="e3751d81-74f5-4ee4-6a4a-e82d69603ba2" title="Guest" subject="注释" date="D:20240403111236+08'00'" creationdate="D:20240403111236+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;[bx] [si] = [bx + si]\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>[bx] [si] = [bx + si]</contents></text><underline page="161" rect="50.880,155.760,167.280,161.280" color="#A6A1E6" flags="print" name="741dabf8-5887-77c7-bade-4940eae78dc5" title="Guest" subject="下划线" date="D:20240403112139+08'00'" creationdate="D:20240403112139+08'00'" coords="50.879999999999995,161.2801,167.28,161.2801,50.879999999999995,155.76,167.28,155.76"><contents>[bx+si+idata]和[bx+di+idata]的含义相似</contents></underline><underline page="163" rect="36.970,326.170,307.440,383.280" color="#A6A1E6" flags="print" name="88f924df-9494-8959-51a5-25576eedbfa2" title="Guest" subject="下划线" date="D:20240403112336+08'00'" creationdate="D:20240403112336+08'00'" coords="50.56,383.28,250.56000000000003,383.28,50.56,376.224,250.56000000000003,376.224,50.65,372.96,257.76,372.96,50.65,367.2,257.76,367.2,50.65,362.65,307.43999999999994,362.65,50.65,356.89,307.43999999999994,356.89,36.97,352.0901,93.83999999999999,352.0901,36.97,346.57,93.83999999999999,346.57,50.65,341.7601,148.56,341.7601,50.65,336.24,148.56,336.24,50.65,331.69010000000003,201.36,331.69010000000003,50.65,326.17,201.36,326.17"><contents>(I) [idata]用一个常量来表示地址，可用于直接定位一个内存单元；
(2)[bx]用一个变屈来表示内存地址，可用千间接定位一个内存单元；
(3)[bx+idata]用一个变矗和常阰表示地址，可在一个起始地址的基础上用变歙间接
定位一个内存单元：
(4)[bx+si]用两个变量表示地址 ；
(5)[bx+s计idata]用两个变员和一个常簸表示地址 。</contents></underline><square page="164" rect="56.310,270.560,308.420,423.360" color="#007A3B" flags="print" name="e0218050-92b0-e8bb-02a5-7ee6f3683571" title="Guest" subject="矩形" date="D:20240403112937+08'00'" creationdate="D:20240403112935+08'00'"/><underline page="164" rect="90.570,91.157,109.360,97.519" color="#A6A1E6" flags="print" name="0a989d9f-8f76-2e50-e30f-7cd7af0e7ccc" title="Guest" subject="下划线" date="D:20240403114127+08'00'" creationdate="D:20240403114127+08'00'" coords="90.57,97.51859999999999,109.3602732,97.51859999999999,90.57,91.1574,109.3602732,91.1574"><contents>[bx+3]</contents></underline><text page="164" rect="90.570,66.519,121.570,97.519" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="0a989d9f-8f76-2e50-e30f-7cd7af0e7ccc" name="6b0c79a1-a835-fa04-b40c-2dd88a1de02f" title="Guest" subject="注释" date="D:20240403114149+08'00'" creationdate="D:20240403114149+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;读取内存一个还是多个的情况\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>读取内存一个还是多个的情况</contents></text><underline page="167" rect="36.970,169.930,307.450,196.080" color="#A6A1E6" flags="print" name="d189dc03-4b03-6e49-8989-374877250f0b" title="Guest" subject="下划线" date="D:20240403114423+08'00'" creationdate="D:20240403114423+08'00'" coords="126.624,196.08000000000004,307.2001,196.08000000000004,126.624,190.32000000000005,307.2001,190.32000000000005,37.21,185.76,307.45,185.76,37.21,180,307.45,180,36.97,175.69,286.93,175.69,36.97,169.93,286.93,169.93"><contents>在上面的程序中 ， SI 、 ex 、 ax 、 bx, 显然不能用来暂存 ex 中
的值，因为这些寄存器在循环中也要使用 ： cs 、 ip 、 ds 也不能用，因为 cs : ip 时刻指向当前
指令， ds 指向 datasg 段 ； 可用的就只有 ： dx 、 小、 es 、 ss 、 sp 、 bp 等 6 个寄存器了</contents></underline><underline page="167" rect="36.720,76.800,307.451,103.200" color="#A6A1E6" flags="print" name="aead614d-feee-194c-247d-c97e8b337658" title="Guest" subject="下划线" date="D:20240403114440+08'00'" creationdate="D:20240403114440+08'00'" coords="140.6671,103.20000000000005,307.4512,103.20000000000005,140.6671,97.44,307.4512,97.44,36.97,92.64009999999996,306.9612,92.64009999999996,36.97,87.12,306.9612,87.12,36.720000000000006,82.32010000000002,129.12,82.32010000000002,36.720000000000006,76.80000000000001,129.12,76.80000000000001"><contents>那么可以使用的就是内存了。可以考虑将需要暂存的数
据放到内存单元中，需要使用的时候，再从内存单元中恢复 。 这样我们就需要开辟一段内
存空间。再次改进的程序如下。</contents></underline><underline page="168" rect="36.720,82.560,307.691,98.640" color="#A6A1E6" flags="print" name="91ba0901-8ebc-279b-38a1-42d200346c15" title="Guest" subject="下划线" date="D:20240403114619+08'00'" creationdate="D:20240403114619+08'00'" coords="189.85000000000002,98.63999999999999,307.6912,98.63999999999999,189.85000000000002,92.88,307.6912,92.88,36.720000000000006,88.32,92.952,88.32,36.720000000000006,82.56,92.952,82.56"><contents>一般来说， 在需要暂存数据的时候，我
们都应该使用栈。</contents></underline><underline page="171" rect="50.460,178.321,306.960,237.328" color="#A6A1E6" flags="print" name="53ea26e8-044b-84a5-418a-0790abccb4d5" title="Guest" subject="下划线" date="D:20240403114706+08'00'" creationdate="D:20240403114706+08'00'" coords="51.02,237.3284931,211.91976,237.3284931,51.02,229.9299775,211.91976,229.9299775,217.45000000000002,237.13,306.96000000000004,237.13,217.45000000000002,231.37,306.96000000000004,231.37,64.8,226.81009999999998,80.63999999999999,226.81009999999998,64.8,221.28999999999996,80.63999999999999,221.28999999999996,50.46,233.5833,57.2154,233.5833,50.46,205.4925,57.2154,205.4925,65.04,216.4801,128.88,216.4801,65.04,210.96000000000004,128.88,210.96000000000004,51.02,206.1701,94.0805,206.1701,51.02,197.76997749999998,94.0805,197.76997749999998,51.02,195.8501,121.92,195.8501,51.02,187.9299775,121.92,187.9299775,51.02,185.6868,53.330000000000005,185.6868,51.02,178.32119999999998,53.330000000000005,178.32119999999998,64.8,185.51999999999998,105.3602,185.51999999999998,64.8,179.76,105.3602,179.76"><contents>• 寻址方式 [bx（或 s］ 、 di)+idata] 、［bx+s] （或 di)］ 、
［bx+s]（或 di)订data] 的意义和
应用 ；
.
二重循环问题的处理：
• 栈的应用；
• 大小写转化的方法：
•
and、 or 指令。</contents></underline><underline page="172" rect="50.650,358.570,136.800,374.410" color="#A6A1E6" flags="print" name="aca01ad6-d47f-4a38-eaeb-e99020239947" title="Guest" subject="下划线" date="D:20240403114720+08'00'" creationdate="D:20240403114720+08'00'" coords="50.65,374.4101,136.8005,374.4101,50.65,368.89,136.8005,368.89,50.65,364.0901,130.07999999999998,364.0901,50.65,358.57,130.07999999999998,358.57"><contents>( I ) 处理的数据在什么地方？
(2) 要处理的数据有多长？</contents></underline><square page="172" rect="28.920,60.030,319.420,193.640" color="#007A3B" flags="print" name="8a3a48ae-7181-a196-65d2-03a54898664d" title="Guest" subject="矩形" date="D:20240403114810+08'00'" creationdate="D:20240403114808+08'00'"/><underline page="172" rect="193.547,49.440,307.210,55.200" color="#A6A1E6" flags="print" name="24f46c3e-e7eb-5322-7e8c-8dcc3a0decb8" title="Guest" subject="下划线" date="D:20240403114838+08'00'" creationdate="D:20240403114838+08'00'" coords="193.5467,55.19999999999999,307.21,55.19999999999999,193.5467,49.44,307.21,49.44"><contents>只能以 4 种组合出现： bx 和 si 、 bx 和
162
汇编语言（笫 4 版）
di 、 bp 和 s] 、 bp 和 山。</contents></underline><square page="173" rect="22.010,232.020,326.080,296.520" color="#007A3B" flags="print" name="58a5ff92-135b-83a4-2110-5b0732fb26c8" title="Guest" subject="矩形" date="D:20240403115112+08'00'" creationdate="D:20240403115110+08'00'"/><underline page="173" rect="37.440,162.240,303.360,178.090" color="#A6A1E6" flags="print" name="2f97bc66-1875-f64d-b627-5f76688c944f" title="Guest" subject="下划线" date="D:20240403115147+08'00'" creationdate="D:20240403115147+08'00'" coords="270.24,178.0901,303.36,178.0901,270.24,172.57,303.36,172.57,37.44,167.76009999999997,172.57,167.76009999999997,37.44,162.24,172.57,162.24"><contents>CPU 内部、
内存、端口（端口将在后面的课程中进行讨论）</contents></underline><underline page="174" rect="36.970,411.850,307.450,427.930" color="#A6A1E6" flags="print" name="7cc19176-5030-1c25-cf3e-511d7407b7c2" title="Guest" subject="下划线" date="D:20240403115314+08'00'" creationdate="D:20240403115314+08'00'" coords="50.65,427.93,307.44999999999993,427.93,50.65,422.17,307.44999999999993,422.17,36.97,417.61,168.0009,417.61,36.97,411.85,168.0009,411.85"><contents>对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓冲器中），在汇编语言中称
为· 立即数(idata), 在汇编指令中直接给出。</contents></underline><square page="174" rect="25.340,76.030,326.330,250.070" color="#007A3B" flags="print" name="2075f205-4155-4306-1fac-101bd1e55ad6" title="Guest" subject="矩形" date="D:20240403115458+08'00'" creationdate="D:20240403115457+08'00'"/><underline page="175" rect="156.490,408.480,213.370,417.120" color="#A6A1E6" flags="print" name="0a8ed21a-ff50-8299-506d-b2126aeaacd9" title="Guest" subject="下划线" date="D:20240403115657+08'00'" creationdate="D:20240403115657+08'00'" coords="156.49,417.11999999999995,213.37,417.11999999999995,156.49,408.47999999999996,213.37,408.47999999999996"><contents>寻址方式</contents></underline><underline page="176" rect="109.200,403.450,234.250,409.210" color="#A6A1E6" flags="print" name="5efcc673-6d2f-86e6-6a49-5f259e2f09b2" title="Guest" subject="下划线" date="D:20240403115803+08'00'" creationdate="D:20240403115803+08'00'" coords="109.2,409.21,234.25,409.21,109.2,403.45,234.25,403.45"><contents>可以处理两种尺寸的数据， byte 和 word 。</contents></underline><underline page="176" rect="120.240,361.920,226.330,367.680" color="#A6A1E6" flags="print" name="6f28efb7-bd0b-3e1a-ca86-a9db83b58303" title="Guest" subject="下划线" date="D:20240403115843+08'00'" creationdate="D:20240403115843+08'00'" coords="120.24000000000001,367.67999999999995,226.33,367.67999999999995,120.24000000000001,361.91999999999996,226.33,361.91999999999996"><contents>寄存器指明了指令进行的是字操作 。</contents></underline><underline page="176" rect="36.970,214.800,307.450,230.880" color="#A6A1E6" flags="print" name="3a5d79b0-27c4-63bc-ed38-14309bf2333e" title="Guest" subject="下划线" date="D:20240403115937+08'00'" creationdate="D:20240403115937+08'00'" coords="64.56,230.88,307.45,230.88,64.56,225.12,307.45,225.12,36.97,220.32010000000002,119.04,220.32010000000002,36.97,214.8,119.04,214.8"><contents>在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度， X 在汇编
指令中可以为 word 或 byte 。</contents></underline><underline page="176" rect="37.440,83.760,307.441,99.840" color="#A6A1E6" flags="print" name="f8655264-52f8-8b75-f870-65e6495f2a37" title="Guest" subject="下划线" date="D:20240403190245+08'00'" creationdate="D:20240403190245+08'00'" coords="50.879999999999995,99.84000000000003,307.4408,99.84000000000003,50.879999999999995,94.07999999999998,307.4408,94.07999999999998,37.44,89.51999999999998,138.00000000000003,89.51999999999998,37.44,83.75999999999999,138.00000000000003,83.75999999999999"><contents>在没有寄存器参与的内存单元访问指令中，用 word ptr 或 byte ptr 显性地指明所要访
间的内存单元的长度是很必要的 。</contents></underline><underline page="176" rect="50.630,108.241,124.960,137.899" color="#A6A1E6" flags="print" name="ac488d0d-2c70-fade-0d29-7e3845380da5" title="Guest" subject="下划线" date="D:20240403190304+08'00'" creationdate="D:20240403190304+08'00'" coords="50.63,137.8990898,124.96005000000001,137.8990898,50.63,131.7609782,124.96005000000001,131.7609782,51.06,130.30880000000002,110.2515333,130.30880000000002,51.06,124.05920000000003,110.2515333,124.05920000000003,51.06,122.1488,117.7479607,122.1488,51.06,115.89920000000001,117.7479607,115.89920000000001,50.809999999999995,114.37908980000003,117.9186727,114.37908980000003,50.809999999999995,108.24097820000003,117.9186727,108.24097820000003"><contents>mov byte p t r ds : [OJ , 1
inc byte p t r [bx ]
inc byte ptr ds : [OJ
add byte ptr [bx ] , 2</contents></underline><square page="177" rect="38.350,312.430,255.670,446.130" color="#007A3B" flags="print" name="50d34166-0f4f-cdbf-0346-b7e9014dc210" title="Guest" subject="矩形" date="D:20240403190446+08'00'" creationdate="D:20240403190444+08'00'"/><underline page="177" rect="37.210,239.040,306.960,255.130" color="#A6A1E6" flags="print" name="99b43672-96ab-931c-11b0-1fdf6002b0d3" title="Guest" subject="下划线" date="D:20240403190502+08'00'" creationdate="D:20240403190502+08'00'" coords="198.73,255.13,231.6,255.13,198.73,249.37,231.6,249.37,235.93,255.13,306.96029999999996,255.13,235.93,249.37,306.96029999999996,249.37,37.21,244.56009999999998,208.08,244.56009999999998,37.21,239.04,208.08,239.04"><contents>比如 ， push [ IOOOH]就不用指明访间
的是字单元还是字节单元，因为 push 指令只进行字操作 。</contents></underline><underline page="179" rect="202.810,392.640,220.080,397.440" color="#A6A1E6" flags="print" name="19c88d5c-5fef-b316-6e86-c30cd326b1cd" title="Guest" subject="下划线" date="D:20240403192822+08'00'" creationdate="D:20240403192822+08'00'" coords="202.81,397.44000000000005,220.0802,397.44000000000005,202.81,392.64000000000004,220.0802,392.64000000000004"><contents>ds : bx</contents></underline><text page="179" rect="202.810,366.440,233.810,397.440" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="19c88d5c-5fef-b316-6e86-c30cd326b1cd" name="3d37d2ec-a373-e3e1-affb-40ad80864dc6" title="Guest" subject="注释" date="D:20240403192902+08'00'" creationdate="D:20240403192902+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;一般ds:bx确定段偏移地址头部\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>一般ds:bx确定段偏移地址头部</contents></text><underline page="180" rect="98.250,438.481,125.355,444.619" color="#A6A1E6" flags="print" name="c061173a-546d-aa31-14b4-5dc31c930aff" title="Guest" subject="下划线" date="D:20240403193005+08'00'" creationdate="D:20240403193005+08'00'" coords="98.25,444.6190898,125.354544,444.6190898,98.25,438.4809782,125.354544,438.4809782"><contents>[bx ] . Och</contents></underline><text page="180" rect="98.250,413.619,129.250,444.619" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="c061173a-546d-aa31-14b4-5dc31c930aff" name="fd48eb4c-f56e-ef8b-f7c1-0df533005dac" title="Guest" subject="注释" date="D:20240403193024+08'00'" creationdate="D:20240403193024+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;结构体,类风格\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>结构体,类风格</contents></text><underline page="180" rect="37.440,331.450,307.450,347.280" color="#A6A1E6" flags="print" name="a8322888-c3e4-0171-7427-e5caf7ce1998" title="Guest" subject="下划线" date="D:20240403193043+08'00'" creationdate="D:20240403193043+08'00'" coords="99.84,347.2801,307.45,347.2801,99.84,341.76,307.45,341.76,37.44,337.21,280.752,337.21,37.44,331.45,280.752,331.45"><contents>8086CPU 提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供
了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。</contents></underline><underline page="180" rect="36.970,290.170,302.891,306.000" color="#A6A1E6" flags="print" name="d4a7cff5-ba6d-88f8-15a6-e2bee8a50971" title="Guest" subject="下划线" date="D:20240403193133+08'00'" creationdate="D:20240403193133+08'00'" coords="111.99,306.0001,302.891,306.0001,111.99,300.47999999999996,302.891,300.47999999999996,36.97,295.69010000000003,140.17000000000002,295.69010000000003,36.97,290.17,140.17000000000002,290.17"><contents>用 bx 定位整个结构体， 用 过ala 定位结构体中的某一个数据项，
用 si 定位数组项 中 的每个元素 。</contents></underline><underline page="180" rect="36.970,278.651,302.880,295.690" color="#A6A1E6" flags="print" name="f667f8c1-07d5-05c4-6d3b-023bd531ac0a" title="Guest" subject="下划线" date="D:20240403193204+08'00'" creationdate="D:20240403193204+08'00'" coords="292.68,295.69010000000003,302.87999999999994,295.69010000000003,292.68,290.17,302.87999999999994,290.17,36.97,284.7890898,108.71976000000001,284.7890898,36.97,278.6509782,108.71976000000001,278.6509782"><contents>如 ：
[bx].idata 、 [bx].idata [ si] 。</contents></underline><underline page="180" rect="36.720,152.650,307.440,178.810" color="#A6A1E6" flags="print" name="b98f9193-1b65-61a9-d822-3edacf700320" title="Guest" subject="下划线" date="D:20240403193300+08'00'" creationdate="D:20240403193300+08'00'" coords="92.4,178.81009999999998,302.88,178.81009999999998,92.4,173.28999999999996,302.88,173.28999999999996,36.97,168.4801,307.44,168.4801,36.97,162.96000000000004,307.44,162.96000000000004,36.720000000000006,158.40999999999997,127.2,158.40999999999997,36.720000000000006,152.64999999999998,127.2,152.64999999999998"><contents>默认放在 AX 或 DX 和 AX 中 ，如果除数为 8 位，被除数则为 16 位，
默认在 AX 中存放；如果除数为 16 位，被除数则为 32 位，在 DX 和 AX 中存放， DX 存
放高 16 位， AX 存放低 1 6 位。</contents></underline><underline page="180" rect="36.970,132,302.881,148.080" color="#A6A1E6" flags="print" name="d59130f0-6b84-dae2-da0b-2438a43f5a23" title="Guest" subject="下划线" date="D:20240403193331+08'00'" creationdate="D:20240403193331+08'00'" coords="85.44000000000001,148.08000000000004,302.88100000000003,148.08000000000004,85.44000000000001,142.32000000000005,302.88100000000003,142.32000000000005,36.97,137.76,254.89,137.76,36.97,132,254.89,132"><contents>如果除数为 8 位，则 AL 存储除法操作的商， AH 存储除法操作的余数：
如果除数为 16 位，则 AX 存储除法操作的商， DX 存储除法操作的余数。</contents></underline><square page="181" rect="45.050,419.150,228.050,449.610" color="#007A3B" flags="print" name="355bdca3-35b0-3c32-9b35-06521015ddea" title="Guest" subject="矩形" date="D:20240403193520+08'00'" creationdate="D:20240403193519+08'00'"/><underline page="181" rect="164.170,329.760,182.890,335.520" color="#A6A1E6" flags="print" name="d7d84b26-64bc-6fac-f8bb-598c9fc45f15" title="Guest" subject="下划线" date="D:20240403193834+08'00'" creationdate="D:20240403193834+08'00'" coords="164.17,335.52,182.89,335.52,164.17,329.76,182.89,329.76"><contents>65535,</contents></underline><text page="181" rect="164.170,304.520,195.170,335.520" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="d7d84b26-64bc-6fac-f8bb-598c9fc45f15" name="822cc1d4-e2f5-7a01-31b4-42c704556b62" title="Guest" subject="注释" date="D:20240403193842+08'00'" creationdate="D:20240403193842+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;2^16 -1 \&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>2^16 -1 </contents></text><underline page="180" rect="173.520,183.600,218.400,189.120" color="#A6A1E6" flags="print" name="ff593e70-81f0-74cb-3d33-c7a4b2a115c0" title="Guest" subject="下划线" date="D:20240403194018+08'00'" creationdate="D:20240403194018+08'00'" coords="173.52,189.12009999999998,218.40000000000003,189.12009999999998,173.52,183.60000000000002,218.40000000000003,183.60000000000002"><contents>reg 或内存单元</contents></underline><underline page="181" rect="36.490,69.120,307.680,85.200" color="#A6A1E6" flags="print" name="1e12705a-7f1e-854f-a337-ca2996b18325" title="Guest" subject="下划线" date="D:20240403194044+08'00'" creationdate="D:20240403194044+08'00'" coords="90.48,85.20000000000005,307.68,85.20000000000005,90.48,79.44,307.68,79.44,36.49,74.64009999999996,104.16050000000001,74.64009999999996,36.49,69.12,104.16050000000001,69.12"><contents>db 和 dw 定义字节型数据和字型数据。 dd 是用来定义 dword(double
word , 双字）型数据的。</contents></underline><underline page="182" rect="134.400,175.680,237.850,188.160" color="#A6A1E6" flags="print" name="893c2de9-f37f-1607-19a0-1af9eaa31ac8" title="Guest" subject="下划线" date="D:20240403194142+08'00'" creationdate="D:20240403194142+08'00'" coords="134.4,188.1601,237.8501,188.1601,134.4,183.60000000000002,237.8501,183.60000000000002,134.4,180.24009999999998,237.8501,180.24009999999998,134.4,175.68,237.8501,175.68"><contents>; ds : O 字单元中的低 16 位存储在 ax 中
; ds : 2 字单元中的高 16 位存储在 dx 中</contents></underline><underline page="182" rect="36.970,106.800,307.200,122.880" color="#A6A1E6" flags="print" name="8b56318e-0475-67de-8ce0-50384c0949bb" title="Guest" subject="下划线" date="D:20240403194223+08'00'" creationdate="D:20240403194223+08'00'" coords="50.65,122.88,307.19999999999993,122.88,50.65,117.12,307.19999999999993,117.12,36.97,112.32010000000002,283.7928,112.32010000000002,36.97,106.80000000000001,283.7928,106.80000000000001"><contents>dup 是一个操作符，在汇编语言中同 db 、 dw、 dd 等一样，也是由编译器识别处理的
符号。它是和 db 、 dw、 dd 等数据定义伪指令配合使用的，用来进行数据的重复。</contents></underline><underline page="182" rect="50.880,78,208.800,83.520" color="#A6A1E6" flags="print" name="b4a28f6d-33a5-c602-2114-2abb7b57d782" title="Guest" subject="下划线" date="D:20240403194226+08'00'" creationdate="D:20240403194226+08'00'" coords="50.879999999999995,83.52010000000001,208.8,83.52010000000001,50.879999999999995,78,208.8,78"><contents>定义了 3 个字节，它们的值都是 o , 相当千 db 0, 0 ,0 。</contents></underline><underline page="182" rect="50.820,49.210,302.640,69.679" color="#A6A1E6" flags="print" name="e3c35f00-0fbd-db6e-c5b3-a392cc26352d" title="Guest" subject="下划线" date="D:20240403194234+08'00'" creationdate="D:20240403194234+08'00'" coords="50.82,69.67860000000002,106.1655715,69.67860000000002,50.82,63.31740000000002,106.1655715,63.31740000000002,50.879999999999995,54.73009999999999,134.41,54.73009999999999,50.879999999999995,49.20999999999998,134.41,49.20999999999998,139.68016,54.73009999999999,165.61,54.73009999999999,139.68016,49.20999999999998,165.61,49.20999999999998,170.88016000000002,54.73009999999999,196.8,54.73009999999999,170.88016000000002,49.20999999999998,196.8,49.20999999999998,202.09032000000002,54.73009999999999,302.64,54.73009999999999,202.09032000000002,49.20999999999998,302.64,49.20999999999998"><contents>db 3 dup (0 , 1 , 2)
定义了 9 个字节，它们是 0 、
l 、 2 、 0 、
l 、 2 、 0 、
l 、 2, 相当千 db O, l ,2 ,0, 1 ,2 ,0,l ,2 。</contents></underline><square page="183" rect="43.260,373.860,178.650,420.450" color="#007A3B" flags="print" name="fd29618f-12b9-f1bc-d938-a6509ee80bcd" title="Guest" subject="矩形" date="D:20240403194247+08'00'" creationdate="D:20240403194246+08'00'"/><underline page="184" rect="82.320,247.210,215.760,252.970" color="#A6A1E6" flags="print" name="8cd3344c-8bd8-1bbc-bc33-7d15d9731a88" title="Guest" subject="下划线" date="D:20240403194528+08'00'" creationdate="D:20240403194528+08'00'" coords="82.32,252.96999999999997,215.76,252.96999999999997,82.32,247.20999999999998,215.76,247.20999999999998"><contents>data 段中的数据按如下格式写入到 table 段</contents></underline><underline page="184" rect="48.700,287.281,94.427,293.419" color="#A6A1E6" flags="print" name="5eae394d-1f25-5234-a603-b630ea118448" title="Guest" subject="下划线" date="D:20240403194638+08'00'" creationdate="D:20240403194638+08'00'" coords="48.7,293.41908979999994,94.42701120000001,293.41908979999994,48.7,287.28097819999994,94.42701120000001,287.28097819999994"><contents>table segment</contents></underline><underline page="186" rect="36.970,384.480,307.440,400.560" color="#A6A1E6" flags="print" name="4d4fb47a-e500-da2a-261f-1ac25ed25bfc" title="Guest" subject="下划线" date="D:20240403194734+08'00'" creationdate="D:20240403194734+08'00'" coords="50.65,400.56,307.44,400.56,50.65,394.8,307.44,394.8,36.97,390.0001,173.76,390.0001,36.97,384.47999999999996,173.76,384.47999999999996"><contents>可以修改 IP, 或同时修改 CS 和 IP 的指令统称为转移指令。 概括地讲，转移指令就
是可以控制 CPU 执行内存中某处代码的指令。</contents></underline><underline page="186" rect="65.040,302.890,180.970,328.985" color="#A6A1E6" flags="print" name="8a943552-5f06-aaad-f60a-b9468c53467c" title="Guest" subject="下划线" date="D:20240403194828+08'00'" creationdate="D:20240403194828+08'00'" coords="65.04,328.98539999999997,167.28,328.98539999999997,65.04,312.96,167.28,312.96,65.04,308.4101,180.97,308.4101,65.04,302.89,180.97,302.89"><contents>短转移 IP 的修改范围为－ 1 28~127 。
近转移 IP 的修改范围为－32768~32767 。</contents></underline><underline page="186" rect="50.630,44.935,297.600,67.930" color="#A6A1E6" flags="print" name="a72b3af4-58cf-5b34-4f2a-0caa438d0d62" title="Guest" subject="下划线" date="D:20240403194920+08'00'" creationdate="D:20240403194920+08'00'" coords="164.4606,67.93,297.6,67.93,164.4606,62.170000000000016,297.6,62.170000000000016,50.63,52.089999999999975,167.52,52.089999999999975,50.63,44.93477819999998,167.52,44.93477819999998"><contents>标号 start 和 s 的偏移地址 0 和 3, 所以指令 ：
mov ax,offset start 相当千指令 mov ax,O</contents></underline><underline page="188" rect="50.650,411.600,214.320,427.690" color="#A6A1E6" flags="print" name="d215c535-e437-56c8-90e2-8b930bb21cb9" title="Guest" subject="下划线" date="D:20240403195259+08'00'" creationdate="D:20240403195259+08'00'" coords="64.56,427.69010000000003,112.3203,427.69010000000003,64.56,422.17,112.3203,422.17,50.65,417.6,214.32,417.6,50.65,411.6,214.32,411.6"><contents>转移的目的地址
(2) 转移的距离（段间转移、段内短转移、段内近转移）</contents></underline><underline page="188" rect="36.970,305.290,307.440,321.370" color="#A6A1E6" flags="print" name="f2d6b8ff-0d83-1df6-c32c-dbc1cecd0206" title="Guest" subject="下划线" date="D:20240403195739+08'00'" creationdate="D:20240403195739+08'00'" coords="50.879999999999995,321.37,307.44,321.37,50.879999999999995,315.61,307.44,315.61,36.97,311.04999999999995,283.44,311.04999999999995,36.97,305.28999999999996,283.44,305.28999999999996"><contents>这种格式的 jmp 指令实现的是段内短转移，它对 IP 的修改范围为－ 1 28~ 1 27 , 也就是
说，它向前转移时可以最多越过 1 28 个字节，向后转移可以最多越过 1 27 个字节。</contents></underline><underline page="189" rect="36.970,254.160,307.680,280.317" color="#A6A1E6" flags="print" name="2fa5ba68-9bc9-dbcc-cd63-02fb594d186b" title="Guest" subject="下划线" date="D:20240403195859+08'00'" creationdate="D:20240403195859+08'00'" coords="198.78350000000003,280.31728979999997,307.68,280.31728979999997,198.78350000000003,272.969975,307.68,272.969975,37.21,270,307.44,270,37.21,264.24,307.44,264.24,36.97,259.6801,74.6506,259.6801,36.97,254.16,74.6506,254.16"><contents>带有转移的目的地址（由标号 s 表示）
的，可翻译成机器指令后，怎么目的地址就没了呢？没有了目的地址， CPU 如何知道转
移到哪里呢？</contents></underline><underline page="190" rect="50.570,250.090,252.482,276.970" color="#A6A1E6" flags="print" name="893a9476-5f3d-19a4-2219-dce267c587da" title="Guest" subject="下划线" date="D:20240403200057+08'00'" creationdate="D:20240403200057+08'00'" coords="64.56,276.9701,252.48239999999998,276.9701,64.56,271.45,252.48239999999998,271.45,50.57,266.7270898,220.33,266.7270898,50.57,259.4729782,220.33,259.4729782,50.65,255.85,168.9607,255.85,50.65,250.09,168.9607,250.09"><contents>从 CS :IP 指向内存单元读取指令，读取的指令进入指令缓冲器：
(2) (IP)~(IP)＋所读取指令的长度，从而指向下一条指令 ：
(3) 执行指令。转到 1 , 重复这个过程。</contents></underline><underline page="190" rect="78.096,197.040,168.000,202.560" color="#A6A1E6" flags="print" name="fe1b4d5b-5e2e-3160-182d-e9cb09b6b521" title="Guest" subject="下划线" date="D:20240403200138+08'00'" creationdate="D:20240403200138+08'00'" coords="78.0962,202.56009999999998,168.0003,202.56009999999998,78.0962,197.03999999999996,168.0003,197.03999999999996"><contents>指令码 EB03 进入指令缓冲器</contents></underline><underline page="190" rect="36.720,80.400,307.440,107.280" color="#A6A1E6" flags="print" name="4cce11c0-5867-a136-7f9f-be6ce75c0bcd" title="Guest" subject="下划线" date="D:20240403200309+08'00'" creationdate="D:20240403200309+08'00'" coords="50.65,107.27999999999997,307.44,107.27999999999997,50.65,101.51999999999998,307.44,101.51999999999998,36.97,96.4801,307.2,96.4801,36.97,90.96000000000004,307.2,90.96000000000004,36.720000000000006,85.92009999999999,282.73,85.92009999999999,36.720000000000006,80.39999999999998,282.73,80.39999999999998"><contents>CPU 在执行 EB 03 的时候是根据什么修改的 IP , 使其指向目标指令呢？就是根据指
令码中 的 03。注意，要转移的目的地址是 CS : 000B , 而 CPU 执行 EB 03 时，当前的
(IP)~0008H , 如果将当前的 IP 值加 3 , 使（IP)~OOOBH , CS:IP 就可指向目标指令 。</contents></underline><square page="191" rect="55.800,292.190,300.990,412.230" color="#007A3B" flags="print" name="8d8b7846-c24e-6ad9-b60e-75b4e15663e3" title="Guest" subject="矩形" date="D:20240403200337+08'00'" creationdate="D:20240403200335+08'00'"/><underline page="191" rect="81.360,267.610,228.250,273.370" color="#A6A1E6" flags="print" name="b0207938-3b03-b2a9-54d6-83ce893f2879" title="Guest" subject="下划线" date="D:20240403200458+08'00'" creationdate="D:20240403200458+08'00'" coords="81.36,273.37,228.25,273.37,81.36,267.61,228.25,267.61"><contents>勹mp short 标号”的功能为： （IP)~(IP)+8 位位移 。</contents></underline><underline page="191" rect="36.970,182.650,307.440,199.210" color="#A6A1E6" flags="print" name="85a4311c-ec3f-325e-614c-6577575f56f6" title="Guest" subject="下划线" date="D:20240403200606+08'00'" creationdate="D:20240403200606+08'00'" coords="212.4,199.21000000000004,307.44,199.21000000000004,212.4,192.0547782,307.44,192.0547782,36.97,188.1701,73.67999999999999,188.1701,36.97,182.64999999999998,73.67999999999999,182.64999999999998"><contents>jmp near ptr 标号， 它实现的是
段内近转移。</contents></underline><underline page="191" rect="64.560,250.365,236.650,257.520" color="#A6A1E6" flags="print" name="8a9e9645-6da8-041d-361d-fbad1a9f115e" title="Guest" subject="下划线" date="D:20240403200801+08'00'" creationdate="D:20240403200801+08'00'" coords="64.56,257.52,236.6505,257.52,64.56,250.3647782,236.6505,250.3647782"><contents>8 位位移＝标号处的地址－jmp 指令后的第一个字节的地址：</contents></underline><underline page="191" rect="65.040,128.205,207.610,135.347" color="#A6A1E6" flags="print" name="f2ed76ff-b157-8fa1-ca6a-16ab93e896d1" title="Guest" subject="下划线" date="D:20240403200821+08'00'" creationdate="D:20240403200821+08'00'" coords="65.04,135.3472898,207.60999999999999,135.3472898,65.04,128.20477819999996,207.60999999999999,128.20477819999996"><contents>16 位位移的范围为－32768-32767, 用补码表示</contents></underline><underline page="191" rect="64.311,138.775,244.570,145.917" color="#A6A1E6" flags="print" name="94827d12-3098-a1ac-703c-21873202cfcc" title="Guest" subject="下划线" date="D:20240403200837+08'00'" creationdate="D:20240403200837+08'00'" coords="64.3110147,145.9172898,244.57009999999997,145.9172898,64.3110147,138.77477820000001,244.57009999999997,138.77477820000001"><contents>near ptr 指明此处的位移为 16 位位移，进行的是段内近转移</contents></underline><underline page="192" rect="36.720,156.730,307.799,182.717" color="#A6A1E6" flags="print" name="c5dff81e-f4ee-2c46-8282-e9849ff71212" title="Guest" subject="下划线" date="D:20240403201046+08'00'" creationdate="D:20240403201046+08'00'" coords="133.1724,182.71708980000005,307.79934369999995,182.71708980000005,133.1724,175.46297820000007,307.79934369999995,175.46297820000007,36.720000000000006,172.57,307.6915,172.57,36.720000000000006,165.4147782,307.6915,165.4147782,36.97,162.01,291.36,162.01,36.97,156.73000000000002,291.36,156.73000000000002"><contents>要注意一下 jmp far ptr s 所对应的机器码 ： EA OB 01 BD
OB , 其中包含转移的目的地址 。 “OB 01 BD OB " 是目的地址在指令中的存储顺序，高地
址的 “BDOB " 是转移的段地址 ： OBBDH , 低地址的 “ OB 01 " 是偏移地址： O I OBH。</contents></underline><underline page="192" rect="110.880,115.545,258.730,127.336" color="#A6A1E6" flags="print" name="29c3e84f-981a-f1c7-274b-728fd444d55f" title="Guest" subject="下划线" date="D:20240403201135+08'00'" creationdate="D:20240403201135+08'00'" coords="110.88,127.33620000000002,258.73,127.33620000000002,110.88,115.54500000000002,258.73,115.54500000000002"><contents>转移地址在寄存器中的 jmp 指令</contents></underline><square page="193" rect="39.930,292.540,160.990,345.780" color="#007A3B" flags="print" name="1e6586ca-ab7a-6f27-8c18-92b9414d6a68" title="Guest" subject="矩形" date="D:20240403201248+08'00'" creationdate="D:20240403201246+08'00'"/><underline page="193" rect="36.970,193.930,307.440,210.010" color="#A6A1E6" flags="print" name="f28f351e-9bef-9b15-f86b-b5547eb2b123" title="Guest" subject="下划线" date="D:20240403201603+08'00'" creationdate="D:20240403201603+08'00'" coords="189.89719999999997,210.01010000000002,307.4403,210.01010000000002,189.89719999999997,204.49,307.4403,204.49,36.97,199.45010000000002,129.12,199.45010000000002,36.97,193.93,129.12,193.93"><contents>高地址处的字是转移的目的段地址，低
地址处是转移的目的偏移地址。</contents></underline><underline page="193" rect="146.170,82.769,209.040,89.280" color="#A6A1E6" flags="print" name="f59c95d0-8dff-899a-ce85-4d13496ea8ce" title="Guest" subject="下划线" date="D:20240403201618+08'00'" creationdate="D:20240403201618+08'00'" coords="146.17,89.27999999999997,209.04,89.27999999999997,146.17,82.7688,209.04,82.7688"><contents>CS:IP 指向 0000:0123</contents></underline><text page="193" rect="146.170,58.280,177.170,89.280" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="f59c95d0-8dff-899a-ce85-4d13496ea8ce" name="c017fe46-5e80-01b7-e1f3-11ecf1fed481" title="Guest" subject="注释" date="D:20240403201707+08'00'" creationdate="D:20240403201707+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;高地址和低地址长度差4位\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>高地址和低地址长度差4位</contents></text><text page="193" rect="146.170,58.280,177.170,89.280" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="f59c95d0-8dff-899a-ce85-4d13496ea8ce" name="0dbe81e0-2461-dfa3-2c5a-ef03bedba257" title="Guest" subject="注释" date="D:20240403201732+08'00'" creationdate="D:20240403201732+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;高位为0，低位为0123H\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>高位为0，低位为0123H</contents></text><ink page="193" rect="199.660,92.160,229.820,201.400" color="#E44234" flags="print" name="6c3b6359-b99c-5495-19dd-40ceeb318239" title="Guest" subject="手绘" date="D:20240403201747+08'00'" creationdate="D:20240403201745+08'00'"><inklist><gesture>228.82,200.40000000000003;228.56,199.63;226.77,189.65000000000003;220.12,163.55;216.02,147.68;213.97,135.90000000000003;213.2,131.3;211.93,124.13;211.41,121.82999999999998;210.9,119.78000000000003;210.9,117.99000000000001;210.9,117.73000000000002;210.9,117.47000000000003;210.9,117.22000000000003;210.9,116.96000000000004;210.65,115.43;209.62,112.61000000000001;209.37,110.31;206.55,104.68;205.27,102.12;202.71,97.76999999999998;201.94,96.49000000000001;201.43,95.72000000000003;201.18,94.69999999999999;200.92,93.93;200.66,93.67000000000002;200.66,93.42000000000002;200.66,93.16000000000003</gesture></inklist></ink><underline page="194" rect="56.580,177.611,63.390,183.749" color="#A6A1E6" flags="print" name="1ee477d1-f5f2-0bd6-c017-0a8d73d36b70" title="Guest" subject="下划线" date="D:20240405102134+08'00'" creationdate="D:20240405102134+08'00'" coords="56.58,183.74908979999998,63.390447,183.74908979999998,56.58,177.61097819999998,63.390447,177.61097819999998"><contents>dd</contents></underline><underline page="194" rect="155.760,242.160,243.360,247.920" color="#A6A1E6" flags="print" name="f9a9f38d-c1ec-3fd8-21e6-d30abb6e13e4" title="Guest" subject="下划线" date="D:20240405102724+08'00'" creationdate="D:20240405102724+08'00'" coords="155.76,247.92,243.36,247.92,155.76,242.16,243.36,242.16"><contents>CS :IP 指向程序的笫 一条指令</contents></underline><text page="194" rect="155.760,216.920,186.760,247.920" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="f9a9f38d-c1ec-3fd8-21e6-d30abb6e13e4" name="4bcbafbb-53d7-6313-105e-2190c5177b36" title="Guest" subject="注释" date="D:20240405102746+08'00'" creationdate="D:20240405102746+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;CS:IP指向第一条指令,IIP:0001H\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>CS:IP指向第一条指令,IIP:0001H</contents></text><underline page="195" rect="64.800,437.760,157.200,443.520" color="#A6A1E6" flags="print" name="e87b6988-19b8-c21a-fac3-b63a851a3ee9" title="Guest" subject="下划线" date="D:20240405103433+08'00'" creationdate="D:20240405103433+08'00'" coords="64.8,443.52,157.2,443.52,64.8,437.76,157.2,437.76"><contents>用 Debug 查看内存，结果如下：</contents></underline><underline page="195" rect="86.455,320.170,245.116,325.930" color="#A6A1E6" flags="print" name="d86c114c-c7bf-06bb-f3d0-d0c21bd7b8aa" title="Guest" subject="下划线" date="D:20240405104600+08'00'" creationdate="D:20240405104600+08'00'" coords="86.45490000000001,325.93,245.11579999999998,325.93,86.45490000000001,320.17,245.11579999999998,320.17"><contents>有条件转移指令，所有的有条件转移指令都是短转移</contents></underline><underline page="195" rect="50.880,250.090,223.690,277.680" color="#A6A1E6" flags="print" name="31b83042-4266-ecbe-d74a-e1ea6f3f2278" title="Guest" subject="下划线" date="D:20240405104723+08'00'" creationdate="D:20240405104723+08'00'" coords="50.879999999999995,277.67999999999995,223.69,277.67999999999995,50.879999999999995,271.91999999999996,223.69,271.91999999999996,50.879999999999995,266.4,175.45000000000002,266.4,50.879999999999995,261.12,175.45000000000002,261.12,50.879999999999995,255.85,155.04,255.85,50.879999999999995,250.09,155.04,250.09"><contents>8 位位移＝标号处的地址－jcxz 指令后的第一个字节的地址 ：
8 位位移的范围为－ 1 28~127 , 用补码表示；
8 位位移由编译程序在编译时算出 。</contents></underline><underline page="195" rect="51.120,204.939,138.970,211.189" color="#A6A1E6" flags="print" name="27155ca4-5ea8-a3b7-bc8a-15db9070f84c" title="Guest" subject="下划线" date="D:20240405104736+08'00'" creationdate="D:20240405104736+08'00'" coords="51.120000000000005,211.18880000000001,138.97,211.18880000000001,51.120000000000005,204.93920000000003,138.97,204.93920000000003"><contents>辽 ((ex) ~~ O) jmp short 标号 ；</contents></underline><underline page="196" rect="36.970,353.520,307.452,369.610" color="#A6A1E6" flags="print" name="1c4ad7af-c6e7-e414-006b-f396d131986c" title="Guest" subject="下划线" date="D:20240405105248+08'00'" creationdate="D:20240405105248+08'00'" coords="50.65,369.61,307.4515,369.61,50.65,363.85,307.4515,363.85,36.97,359.28,208.33,359.28,36.97,353.52,208.33,353.52"><contents>loop 指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位
移，而不是目的地址。对 IP 的修改范围都为 ： － 1 28~ 1 27 。</contents></underline><square page="197" rect="42.170,327.690,116.370,369.860" color="#007A3B" flags="print" name="c58a55ed-606d-4daa-1fc8-b633ea01db5d" title="Guest" subject="矩形" date="D:20240405105556+08'00'" creationdate="D:20240405105555+08'00'"/><underline page="198" rect="36.970,383.760,307.450,399.370" color="#A6A1E6" flags="print" name="b25390ef-492b-4cd0-f5f1-072aa2b25f35" title="Guest" subject="下划线" date="D:20240405105854+08'00'" creationdate="D:20240405105854+08'00'" coords="159.85000000000002,399.37010000000004,307.44999999999993,399.37010000000004,159.85000000000002,392.6509782,307.44999999999993,392.6509782,36.97,389.2801,274.5711,389.2801,36.97,383.76,274.5711,383.76"><contents>“jmp 2000:0 I 00 " 的转移指令，是在 Debug 中使
用的汇编指令， 汇编编译器并不认识 。 如果在源程序中使用，编译时也会报错。</contents></underline><underline page="201" rect="50.400,329.520,245.280,345.610" color="#A6A1E6" flags="print" name="9ea820be-6805-67c2-0424-4204b0bb6c7c" title="Guest" subject="下划线" date="D:20240405110807+08'00'" creationdate="D:20240405110807+08'00'" coords="50.4,345.61,223.45000000000002,345.61,50.4,339.85,223.45000000000002,339.85,50.4,335.28,245.28,335.28,50.4,329.52,245.28,329.52"><contents>rel 指令用栈中的数据，修改 IP 的内容，从而实现近转移 ：
retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移 。</contents></underline><underline page="203" rect="37.440,296.170,307.210,312.240" color="#A6A1E6" flags="print" name="fa4a11b3-0681-53ae-58fd-ff9112db4cf5" title="Guest" subject="下划线" date="D:20240405111855+08'00'" creationdate="D:20240405111855+08'00'" coords="50.65,312.23999999999995,307.21,312.23999999999995,50.65,306.47999999999996,307.21,306.47999999999996,37.44,301.93,44.21340000000001,301.93,37.44,296.17,44.21340000000001,296.17"><contents>call 指令不能实现短转移，除此之外， ca]］ 指令实现转移的方法和 jmp 指令的原理相
同</contents></underline><underline page="203" rect="50.650,322.080,166.570,337.920" color="#A6A1E6" flags="print" name="a6fef1c1-8cda-d566-d675-7b905d49e40c" title="Guest" subject="下划线" date="D:20240405111902+08'00'" creationdate="D:20240405111902+08'00'" coords="64.56,337.9201,166.57,337.9201,64.56,332.4,166.57,332.4,50.65,327.6001,80.64000000000001,327.6001,50.65,322.08,80.64000000000001,322.08"><contents>将当前的 IP 或 CS 和 IP 压入栈中：
(2) 转移 。</contents></underline><square page="203" rect="43.480,97.130,175.870,130.800" color="#007A3B" flags="print" name="de9fc41e-f805-17aa-47dd-0b9fd75aa1e9" title="Guest" subject="矩形" date="D:20240405111959+08'00'" creationdate="D:20240405111957+08'00'"/><underline page="203" rect="51.120,62.170,172.560,67.930" color="#A6A1E6" flags="print" name="12b2d184-bf0d-120e-9ab5-ff91fa6f93dd" title="Guest" subject="下划线" date="D:20240405112238+08'00'" creationdate="D:20240405112238+08'00'" coords="51.120000000000005,67.93,172.56,67.93,51.120000000000005,62.170000000000016,172.56,62.170000000000016"><contents>下面的程序执行后， ax 中的数值为多少？</contents></underline><text page="203" rect="51.120,36.930,82.120,67.930" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="12b2d184-bf0d-120e-9ab5-ff91fa6f93dd" name="55678134-a99e-96d5-b85b-18f2cac3324d" title="Guest" subject="注释" date="D:20240405112241+08'00'" creationdate="D:20240405112241+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;(1)6\\n解释，\\n执行完call s 指令被读取完后,ip-&gt;6,然后执行call s指令，将 当前ip的值\\n压入栈，转跳到标号 s ，执行pop ax,此时ax=6\\n\\n\\n\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>(1)6
解释，
执行完call s 指令被读取完后,ip-&gt;6,然后执行call s指令，将 当前ip的值
压入栈，转跳到标号 s ，执行pop ax,此时ax=6


</contents></text><underline page="204" rect="50.650,189.327,75.413,203.609" color="#A6A1E6" flags="print" name="c1d21df1-dd3c-307e-5c7f-c822f6dfa099" title="Guest" subject="下划线" date="D:20240405112418+08'00'" creationdate="D:20240405112418+08'00'" coords="50.65,203.60860000000002,75.1857552,203.60860000000002,50.65,197.24739999999997,75.1857552,197.24739999999997,50.65,195.6886,75.4131412,195.6886,50.65,189.3274,75.4131412,189.3274"><contents>push CS
push IP</contents></underline><square page="205" rect="34.320,304.270,313.490,348.720" color="#007A3B" flags="print" name="6fb5e190-e577-c0ee-47f0-7e748407320e" title="Guest" subject="矩形" date="D:20240405112808+08'00'" creationdate="D:20240405112805+08'00'"/><underline page="209" rect="36.720,226.090,307.450,270.250" color="#A6A1E6" flags="print" name="8d3bbaec-fd71-278e-1dd3-46625a487b1c" title="Guest" subject="下划线" date="D:20240405113757+08'00'" creationdate="D:20240405113757+08'00'" coords="133.4805,270.2501,302.88300000000004,270.2501,133.4805,264.72999999999996,302.88300000000004,264.72999999999996,36.97,260.4001,307.44019999999995,260.4001,36.97,254.88000000000002,307.44019999999995,254.88000000000002,37.44,251.04999999999998,307.44999999999993,251.04999999999998,37.44,245.29,307.44999999999993,245.29,37.44,241.44,307.19999999999993,241.44,37.44,235.68,307.19999999999993,235.68,36.720000000000006,231.6101,87.60000000000001,231.6101,36.720000000000006,226.09000000000003,87.60000000000001,226.09000000000003"><contents>可以写一个具有一定功能的程序段，我们称其为子程序，
在需要的时候，用 call 指令转去执行 。 可是执行完子程序后，如何让 CPU 接着 call 指令
向下执行？ call 指令转去执行子程序之前， call 指令后面的指令的地址将存储在栈中，所
以可在子程序的后面使用 rel 指令， 用栈中的数据设置 IP 的值，从而转到 call 指令后面的
代码处继续执行 。</contents></underline><square page="209" rect="34.980,29.790,280.470,176.240" color="#007A3B" flags="print" name="75603c43-a39e-2294-e876-8fb3e02ca769" title="Guest" subject="矩形" date="D:20240405113815+08'00'" creationdate="D:20240405113814+08'00'"/><underline page="210" rect="36.490,278.400,307.440,304.810" color="#A6A1E6" flags="print" name="4be086e8-963d-958f-733e-85ed43280957" title="Guest" subject="下划线" date="D:20240405113933+08'00'" creationdate="D:20240405113933+08'00'" coords="64.56,304.81,302.88,304.81,64.56,299.05,302.88,299.05,36.97,294.48999999999995,307.4403,294.48999999999995,36.97,288.72999999999996,307.4403,288.72999999999996,36.49,283.9201,177.36,283.9201,36.49,278.4,177.36,278.4"><contents>两个相乘的数 ： 两个相乘的数，要么都是 8 位，要么都是 16 位 。 如果是 8 位，
一个默认放在 AL 中 ， 另一个放在 8 位 reg 或内存字节单元中；如果是 16 位，一个默认在
AX 中，另一个放在 16 位 reg 或内存字单元中。</contents></underline><underline page="210" rect="71.380,136.823,210.720,155.352" color="#A6A1E6" flags="print" name="90279bd9-d874-331a-373b-fc57880eabb3" title="Guest" subject="下划线" date="D:20240405114100+08'00'" creationdate="D:20240405114100+08'00'" coords="71.38,155.35189309999998,210.24020000000002,155.35189309999998,71.38,146.33497750000004,210.24020000000002,146.33497750000004,71.45,144.07708979999995,210.72,144.07708979999995,71.45,136.82297819999997,210.72,136.82297819999997"><contents>(ax)~(ax)*((ds)* l 6+(bx)+(si)+8)结果的低 16 位。
(dx)~(ax)*((ds)* l 6+(bx)+(si)+8)结果的高 16 位 。</contents></underline><underline page="211" rect="50.650,155.520,171.602,171.360" color="#A6A1E6" flags="print" name="7add4d58-1467-cf8f-3c21-556a5d3dad7e" title="Guest" subject="下划线" date="D:20240405114215+08'00'" creationdate="D:20240405114215+08'00'" coords="64.56,171.36,145.44,171.36,64.56,165.60000000000002,145.44,165.60000000000002,50.65,161.0401,171.6016,161.0401,50.65,155.51999999999998,171.6016,155.51999999999998"><contents>将参数 N 存储在什么地方？
(2) 计算得到的数值，存储在什么地方？</contents></underline><square page="211" rect="29.420,57.320,312.830,149.180" color="#007A3B" flags="print" name="7182b4da-b3d1-2e93-d043-94d4e074b8eb" title="Guest" subject="矩形" date="D:20240405114353+08'00'" creationdate="D:20240405114351+08'00'"/><underline page="213" rect="36.720,400.800,307.201,417.120" color="#A6A1E6" flags="print" name="20c11f8c-0c36-1d28-d4f3-13fe7209f2a4" title="Guest" subject="下划线" date="D:20240405120749+08'00'" creationdate="D:20240405120749+08'00'" coords="50.879999999999995,417.12010000000004,307.2012,417.12010000000004,50.879999999999995,411.6,307.2012,411.6,36.720000000000006,406.56,288.7233,406.56,36.720000000000006,400.8,288.7233,400.8"><contents>在这种时候，我们将批砍数据放到内存中，然后将它们所在内存空间的首地址放在寄
存器中，传递给需要的子程序。对千具有批屈数据的返回结果，也可用同样的方法。</contents></underline><underline page="213" rect="71.663,79.200,279.491,84.960" color="#A6A1E6" flags="print" name="5f321782-d75d-a929-de4b-3ed74810e582" title="Guest" subject="下划线" date="D:20240405121143+08'00'" creationdate="D:20240405121143+08'00'" coords="71.6628,84.96000000000004,279.49080000000004,84.96000000000004,71.6628,79.19999999999999,279.49080000000004,79.19999999999999"><contents>除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。</contents></underline><underline page="216" rect="36.970,412.800,307.203,428.650" color="#A6A1E6" flags="print" name="ee8ee40e-00a8-aff6-4993-84821ba0cebd" title="Guest" subject="下划线" date="D:20240405121354+08'00'" creationdate="D:20240405121354+08'00'" coords="64.56,428.65,307.203,428.65,64.56,422.89,307.203,422.89,36.97,418.3201,150.49,418.3201,36.97,412.8,150.49,412.8"><contents>这将给调用子程序的程序的编写造成很大的麻烦，因为必须要小心检查所调用的
子程序中是否有将产生冲突的寄存器 。</contents></underline><underline page="216" rect="36.970,295.200,307.450,311.280" color="#A6A1E6" flags="print" name="e06ac287-c47c-6161-cdfc-bc865074b1cf" title="Guest" subject="下划线" date="D:20240405121412+08'00'" creationdate="D:20240405121412+08'00'" coords="140.74,311.28,307.45,311.28,140.74,305.52,307.45,305.52,36.97,300.96,253.92,300.96,36.97,295.2,253.92,295.2"><contents>在子程序的开始将子程序中所有用到的寄存器中 的 内容
都保存起来，在子程序返回前再恢复 。 可以用栈来保存寄存器中的内容。</contents></underline><square page="215" rect="32.030,207.370,208.550,421.810" color="#007A3B" flags="print" name="fa78a054-4429-edbf-d28e-ea6bdad5500e" title="Guest" subject="矩形" date="D:20240406094424+08'00'" creationdate="D:20240406094422+08'00'"/><text page="215" rect="160.170,367.230,191.170,398.230" color="#FFCD45" flags="print,nozoom,norotate" name="2552a118-a04d-a25c-8439-41b50ce6922f" title="Guest" subject="注释" date="D:20240406094717+08'00'" creationdate="D:20240406094703+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;此代码可能有问题\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>此代码可能有问题</contents></text><square page="216" rect="38.900,86.890,204.300,197.370" color="#007A3B" flags="print" name="3db1fdda-3188-86e4-fceb-967de0511134" title="Guest" subject="矩形" date="D:20240406094843+08'00'" creationdate="D:20240406094842+08'00'"/><underline page="224" rect="102,310.080,121.680,315.840" color="#A6A1E6" flags="print" name="64e01fb3-fc1a-02ec-6dab-110fa05a1e64" title="Guest" subject="下划线" date="D:20240406103416+08'00'" creationdate="D:20240406103416+08'00'" coords="102,315.84,121.6802,315.84,102,310.08,121.6802,310.08"><contents>bp 、 sp</contents></underline><underline page="224" rect="180.490,310.080,186.010,315.840" color="#A6A1E6" flags="print" name="00d0875b-434f-eae4-b123-dc50a3c9df0c" title="Guest" subject="下划线" date="D:20240406103421+08'00'" creationdate="D:20240406103421+08'00'" coords="180.49,315.84,186.0102,315.84,180.49,310.08,186.0102,310.08"><contents>es</contents></underline><underline page="224" rect="36.970,87.360,307.200,102.960" color="#A6A1E6" flags="print" name="65905b8c-de78-34ec-f6c5-14b604c477d5" title="Guest" subject="下划线" date="D:20240406103709+08'00'" creationdate="D:20240406103709+08'00'" coords="280.704,102.96010000000001,307.2,102.96010000000001,280.704,97.44,307.2,97.44,36.97,92.63999999999999,175.44,92.63999999999999,36.97,87.36000000000001,175.44,87.36000000000001"><contents>如果结果
为 o, 那么 z仁I ; 如果结果不为 o, 那么 z仁0 。</contents></underline><underline page="225" rect="36.720,219.120,307.450,245.520" color="#A6A1E6" flags="print" name="89794286-d467-bb80-d039-0e4e2918927b" title="Guest" subject="下划线" date="D:20240406103814+08'00'" creationdate="D:20240406103814+08'00'" coords="151.6806,245.51999999999998,303.35999999999996,245.51999999999998,151.6806,239.76,303.35999999999996,239.76,36.720000000000006,235.21,307.45000000000005,235.21,36.720000000000006,229.45000000000005,307.45000000000005,229.45000000000005,37.21,224.88,289.44,224.88,37.21,219.12,289.44,219.12"><contents>有的指令的执行是影响标志寄存器的，比如， add 、
sub 、 mul 、 div 、 inc 、 or 、 and 等，它们大都是运算指令（进行逻辑或算术运算）；有的指令
的执行对标志寄存器没有影响，比如， mov 、 push 、 pop 等，它们大都是传送指令 。</contents></underline><underline page="225" rect="37.210,143.530,306.970,159.370" color="#A6A1E6" flags="print" name="d90b5e39-cbdd-c938-f491-c809670acab7" title="Guest" subject="下划线" date="D:20240406103926+08'00'" creationdate="D:20240406103926+08'00'" coords="50.65,159.37010000000004,306.96999999999997,159.37010000000004,50.65,153.85000000000002,306.96999999999997,153.85000000000002,37.21,149.0501,261.13,149.0501,37.21,143.52999999999997,261.13,143.52999999999997"><contents>flag 的第 2 位是 PF , 奇偶标志位。 它记录相关指令执行后，其结果的所有 bit 位中 l
的个数是否为偶数。如果 l 的个数为偶数， P仁I , 如果为奇数，那么 p仁0 。</contents></underline><underline page="226" rect="36.970,369.610,307.452,385.440" color="#A6A1E6" flags="print" name="60be29dc-167a-0752-1004-870d246a54d2" title="Guest" subject="下划线" date="D:20240406104000+08'00'" creationdate="D:20240406104000+08'00'" coords="50.65,385.4401,307.4515,385.4401,50.65,379.91999999999996,307.4515,379.91999999999996,36.97,375.1301,140.17000000000002,375.1301,36.97,369.61,140.17000000000002,369.61"><contents>flag 的第 7 位是 SF , 符号标志位。 它记录相关指令执行后，其结果是否为负。如果
结果为负 ， sf=1 ： 如果非负， sf=0 。</contents></underline><underline page="227" rect="36.970,225.370,307.450,241.440" color="#A6A1E6" flags="print" name="0405848d-cbfa-8cca-ffac-5a3951b87263" title="Guest" subject="下划线" date="D:20240406104059+08'00'" creationdate="D:20240406104059+08'00'" coords="162.066,241.44,307.45,241.44,162.066,235.68,307.45,235.68,36.97,231.13,246.96,231.13,36.97,225.37,246.96,225.37"><contents>一般情况下，在进行无符号数运算的时候，它记
录了运算结果的最高有效位向更高位的进位值， 或从更高位的借位值。</contents></underline><underline page="227" rect="36.970,73.440,307.450,99.840" color="#A6A1E6" flags="print" name="aa9c6ec4-cdea-4199-1da3-e5c89851dc69" title="Guest" subject="下划线" date="D:20240406104116+08'00'" creationdate="D:20240406104116+08'00'" coords="176.65,99.84000000000003,307.44,99.84000000000003,176.65,94.07999999999998,307.44,94.07999999999998,36.97,89.51999999999998,307.45,89.51999999999998,36.97,83.75999999999999,307.45,83.75999999999999,36.97,79.20000000000005,212.41,79.20000000000005,36.97,73.44,212.41,73.44"><contents>由千这个进位值在 8 位数中无法保存，我们
在前面的课程中，就只是简单地说这个进位值丢失了。其实 CPU 在运算的时候，并不丢
弃这个进位值，而是记录在一个特殊的寄存器的某一位上 。</contents></underline><underline page="229" rect="36.970,271.920,307.440,288" color="#A6A1E6" flags="print" name="dc0b9f7f-6bb0-cfce-ce2c-d9fdec40090f" title="Guest" subject="下划线" date="D:20240406104625+08'00'" creationdate="D:20240406104625+08'00'" coords="50.65,288,307.4401,288,50.65,282.24,307.4401,282.24,36.97,277.4401,210.01,277.4401,36.97,271.91999999999996,210.01,271.91999999999996"><contents>flag 的第 11 位是 OF , 溢出标志位。一般情况下， OF 记录了有符号数运算的结果是
否发生了溢出 。 如果发生溢出， OF=1 ： 如果没有， OF=0 。</contents></underline><underline page="229" rect="36.970,246,307.440,261.850" color="#A6A1E6" flags="print" name="631e4e66-41d3-447a-9d6d-638e29570a07" title="Guest" subject="下划线" date="D:20240406104636+08'00'" creationdate="D:20240406104636+08'00'" coords="50.879999999999995,261.8501,307.44,261.8501,50.879999999999995,256.33,307.44,256.33,36.97,251.76,126.20199999999998,251.76,36.97,246,126.20199999999998,246"><contents>一定要注意 CF 和 OF 的区别 ： CF 是对无符号数运算有意义的标志位，而 OF 是对有
符号数运算有意义的标志位。</contents></underline><underline page="230" rect="50.650,279.850,221.770,285.610" color="#A6A1E6" flags="print" name="d3913e9d-7e83-3290-a64b-4043bd8ec94e" title="Guest" subject="下划线" date="D:20240406104834+08'00'" creationdate="D:20240406104834+08'00'" coords="50.65,285.61,221.77,285.61,50.65,279.85,221.77,279.85"><contents>adc 是带进位加法指令， 它利用了 CF 位上记录的进位值。</contents></underline><underline page="231" rect="36.970,406.800,307.690,443.520" color="#A6A1E6" flags="print" name="e40b55f9-57ad-8fdb-f126-0e294809b5bf" title="Guest" subject="下划线" date="D:20240406105157+08'00'" creationdate="D:20240406105157+08'00'" coords="138.95999999999998,443.52,307.6903,443.52,138.95999999999998,437.76,307.6903,437.76,36.97,432.9701,307.21,432.9701,36.97,427.45,307.21,427.45,36.97,422.6401,307.44,422.6401,36.97,417.12,307.44,417.12,36.97,412.56,142.08,412.56,36.97,406.8,142.08,406.8"><contents>在执行 adc 指令的时候加上的 CF 的值的含义，是由 adc
指令前面的指令决定的，也就是说，关键在千所加上的 CF 值是被什么指令设置的 。 显
然，如果 CF 的值是被 sub 指令设置的，那么它的含义就是借位值 ： 如果是被 add 指令设
置的，那么它的含义就是进位值 。</contents></underline><underline page="231" rect="36.970,223.680,307.441,239.760" color="#A6A1E6" flags="print" name="cd26efb3-ed1f-acfe-c364-abf1a995c7c1" title="Guest" subject="下划线" date="D:20240406105251+08'00'" creationdate="D:20240406105251+08'00'" coords="154.81,239.76,307.44050000000004,239.76,154.81,234,307.44050000000004,234,36.97,229.20010000000002,198.49,229.20010000000002,36.97,223.68,198.49,223.68"><contents>用 add 指令无法进行计算。我们将计算分两步进
行，先将低 16 位相加，然后将高 16 位和进位值相加 。</contents></underline><squiggly page="231" rect="50.540,184.845,96.778,215.747" color="#E44234" flags="print" name="d1804173-97b5-991d-316a-afb1e5550fe3" title="Guest" subject="曲线" date="D:20240406105844+08'00'" creationdate="D:20240406105844+08'00'" coords="50.54,215.74728979999998,93.16256379999999,215.74728979999998,50.54,208.6047782,93.16256379999999,208.6047782,50.54,207.8372898,96.77847890000001,207.8372898,50.54,200.69477819999997,96.77847890000001,200.69477819999997,50.809999999999995,199.9072898,93.35764230000001,199.9072898,50.809999999999995,192.76477820000002,93.35764230000001,192.76477820000002,50.809999999999995,191.98728979999999,93.19632149999998,191.98728979999999,50.809999999999995,184.84477819999995,93.19632149999998,184.84477819999995"><contents>mov ax , OOlEH
mov bx, OFOOOH
add bx , 1000H
adc ax , 0020H</contents></squiggly><text page="231" rect="50.540,184.747,81.540,215.747" color="#FFFF00" flags="print,nozoom,norotate" inreplyto="d1804173-97b5-991d-316a-afb1e5550fe3" name="f38f8d07-9cf0-df83-7159-b0f1da241410" title="Guest" subject="注释" date="D:20240406105900+08'00'" creationdate="D:20240406105900+08'00'" icon="Comment" statemodel="Review"><trn-custom-data bytes="{&quot;trn-mention&quot;:&quot;{\&quot;contents\&quot;:\&quot;ax为高位，bx为低位\&quot;,\&quot;ids\&quot;:[]}&quot;}"/><contents>ax为高位，bx为低位</contents></text><underline page="233" rect="50.650,403.450,116.816,408.970" color="#A6A1E6" flags="print" name="015450d1-5410-6bdb-bf54-59037d69ac12" title="Guest" subject="下划线" date="D:20240406110501+08'00'" creationdate="D:20240406110501+08'00'" coords="50.65,408.9701,116.8164,408.9701,50.65,403.45,116.8164,403.45"><contents>sbb 是带借位减法指令</contents></underline><underline page="233" rect="36.720,213.370,302.880,229.440" color="#A6A1E6" flags="print" name="34dd8d6c-552e-0d0c-bcd7-af35ed809094" title="Guest" subject="下划线" date="D:20240406110557+08'00'" creationdate="D:20240406110557+08'00'" coords="50.65,229.44,302.87999999999994,229.44,50.65,223.68,302.87999999999994,223.68,36.720000000000006,219.13,120.01920000000001,219.13,36.720000000000006,213.37,120.01920000000001,213.37"><contents>cmp 是比较指令， cmp 的功能相当千减法指令，只是不保存结果 。 cmp 指令执行后 ，
将对标志寄存器产生影响。</contents></underline><underline page="233" rect="36.720,145.005,307.200,162.010" color="#A6A1E6" flags="print" name="c482bf6c-4da7-5d19-b75f-9e9f640211a9" title="Guest" subject="下划线" date="D:20240406110639+08'00'" creationdate="D:20240406110639+08'00'" coords="51.37,162.01010000000002,307.20000000000005,162.01010000000002,51.37,156.49,307.20000000000005,156.49,36.720000000000006,152.1472898,90.63300000000001,152.1472898,36.720000000000006,145.00477820000003,90.63300000000001,145.00477820000003"><contents>比如，指令 cmp ax,ax, 做（ax)-(ax)的运算，结果为 o , 但并不在 ax 中保存，仅影响
flag 的相关各位。</contents></underline><underline page="234" rect="36.720,220.800,307.450,267.600" color="#A6A1E6" flags="print" name="647760b0-647f-0925-d07e-bd8dc39c178f" title="Guest" subject="下划线" date="D:20240406110740+08'00'" creationdate="D:20240406110740+08'00'" coords="273.61,267.6001,307.21000000000004,267.6001,273.61,262.08,307.21000000000004,262.08,36.720000000000006,257.2801,307.45,257.2801,36.720000000000006,251.76,307.45,251.76,36.97,247.2,307.21,247.2,36.97,241.44,307.21,241.44,36.720000000000006,236.88,307.45,236.88,36.720000000000006,231.12,307.45,231.12,36.97,226.32010000000002,87.60000000000001,226.32010000000002,36.97,220.8,87.60000000000001,220.8"><contents>进行无符号
数运算和进行有符号数运莽。所以利用 cmp 指令可以对无符号数进行比较，也可以对有
符号数进行比较。上面所讲的是用 cmp 进行无符号数比较时， 相关标志位对比较结果的
记录。下面我们再来看一下如果用 cmp 来进行有符号数比较时， CPU 用哪些标志位对比
较结果进行记录 。</contents></underline><underline page="235" rect="36.970,79.920,307.442,96" color="#A6A1E6" flags="print" name="e720de30-2b65-b2d7-95c0-781fae0a39a1" title="Guest" subject="下划线" date="D:20240406111049+08'00'" creationdate="D:20240406111049+08'00'" coords="50.65,96,307.442,96,50.65,90.24000000000001,307.442,90.24000000000001,36.97,85.68,127.866,85.68,36.97,79.92000000000002,127.866,79.92000000000002"><contents>但是逻辑上的结果的正负，才是 cmp 指令所求的真正结果，因为我们就是要靠它得
到两个操作对象的比较信息。</contents></underline><underline page="236" rect="36.970,401.520,307.450,417.610" color="#A6A1E6" flags="print" name="c499072d-eb8b-03be-79ec-e8295bf2eb8b" title="Guest" subject="下划线" date="D:20240406111103+08'00'" creationdate="D:20240406111103+08'00'" coords="50.65,417.61,307.44999999999993,417.61,50.65,411.85,307.44999999999993,411.85,36.97,407.28,226.33119999999997,407.28,36.97,401.52,226.33119999999997,401.52"><contents>所以，我们应该在考查 sf（得知实际结果的正负）的同时考查 of（得知有没有溢出），就
可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</contents></underline><square page="236" rect="32.760,164.330,326.590,370.870" color="#007A3B" flags="print" name="6f4ca808-d5db-f010-92ff-40a2467bce8a" title="Guest" subject="矩形" date="D:20240406111134+08'00'" creationdate="D:20240406111118+08'00'"/><underline page="237" rect="105.266,426.730,242.170,432.490" color="#A6A1E6" flags="print" name="0ca24ce0-d6c5-5674-c406-0661d88b4f2e" title="Guest" subject="下划线" date="D:20240406111203+08'00'" creationdate="D:20240406111203+08'00'" coords="105.26599999999999,432.48999999999995,242.1696,432.48999999999995,105.26599999999999,426.72999999999996,242.1696,426.72999999999996"><contents>所有条件转移指令的转移位移都是[- 128 , 127] 。</contents></underline><square page="237" rect="31.740,159.520,321.470,326.700" color="#007A3B" flags="print" name="aed49b6b-3a7a-2f26-f1a5-5149cc86a684" title="Guest" subject="矩形" date="D:20240406111245+08'00'" creationdate="D:20240406111241+08'00'"/><underline page="239" rect="37.210,411.850,307.440,427.930" color="#A6A1E6" flags="print" name="17a1645a-f8e3-84cd-8a67-d5d411f35399" title="Guest" subject="下划线" date="D:20240406111448+08'00'" creationdate="D:20240406111448+08'00'" coords="50.879999999999995,427.93,307.44,427.93,50.879999999999995,422.17,307.44,422.17,37.21,417.37010000000004,107.08000000000001,417.37010000000004,37.21,411.85,107.08000000000001,411.85"><contents>编程思路： 初始设置(ax)~O , 然后用循环依次比较每个字节的值，找到一个和 8 相等
的数就将 ax 的值加 1 。</contents></underline><underline page="240" rect="36.970,158.880,302.880,174.970" color="#A6A1E6" flags="print" name="06cc11ef-4286-a18c-35be-896ebbbaa809" title="Guest" subject="下划线" date="D:20240406111514+08'00'" creationdate="D:20240406111514+08'00'" coords="108.96000000000001,174.96999999999997,302.87999999999994,174.96999999999997,108.96000000000001,169.20999999999998,302.87999999999994,169.20999999999998,36.97,164.64,199.20000000000002,164.64,36.97,158.88,199.20000000000002,158.88"><contents>cmp 、 标志寄存器的相关位、条件转移指令兰者配合应用的原理 ，
这个原理具有普遍性，而不是逐条讲解条件转移指令 。</contents></underline><underline page="241" rect="50.650,134.880,141.840,151.440" color="#A6A1E6" flags="print" name="718fb371-622b-8ce4-15fb-1d692dcef6cb" title="Guest" subject="下划线" date="D:20240406111843+08'00'" creationdate="D:20240406111843+08'00'" coords="50.65,151.44,141.1194876,151.44,50.65,145.68,141.1194876,145.68,50.65,140.64,141.84,140.64,50.65,134.88,141.84,134.88"><contents>d仁0 每次操作后 si 、 山 递增；
d仁l 每次操作后 si、小 递减。</contents></underline><square page="242" rect="37.620,331.930,301.250,424.320" color="#007A3B" flags="print" name="294d9af4-ae37-14a8-417b-47adf4fb414c" title="Guest" subject="矩形" date="D:20240406111909+08'00'" creationdate="D:20240406111907+08'00'"/><underline page="242" rect="72.240,77.760,257.269,83.280" color="#A6A1E6" flags="print" name="85e35214-11df-7e0d-ac2b-7072e6ced3ef" title="Guest" subject="下划线" date="D:20240406112244+08'00'" creationdate="D:20240406112244+08'00'" coords="72.24000000000001,83.2801,257.26919999999996,83.2801,72.24000000000001,77.75999999999999,257.26919999999996,77.75999999999999"><contents>rep 的作用是根据 ex 的值，重复执行后面的串传送指令。</contents></underline><square page="243" rect="27.640,133.190,331.960,275.750" color="#007A3B" flags="print" name="82725477-0f43-ad7c-5049-fa09b7a2728a" title="Guest" subject="矩形" date="D:20240406112406+08'00'" creationdate="D:20240406112403+08'00'"/><underline page="244" rect="36.970,137.530,307.440,169.210" color="#A6A1E6" flags="print" name="183859ef-9105-873a-182e-4ceeafa179ae" title="Guest" subject="下划线" date="D:20240406112538+08'00'" creationdate="D:20240406112538+08'00'" coords="50.4,169.21000000000004,307.44000000000005,169.21000000000004,50.4,163.45000000000005,307.44000000000005,163.45000000000005,36.97,158.64010000000002,53.05,158.64010000000002,36.97,153.12,53.05,153.12,50.4,143.28999999999996,216.25,143.28999999999996,50.4,137.52999999999997,216.25,137.52999999999997"><contents>pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存
器中 。
pushf 和 popf, 为直接访问标志寄存器提供了一种方法。</contents></underline><square page="245" rect="26.620,327.810,310.460,414.830" color="#007A3B" flags="print" name="360d070f-1425-0e39-26a1-a74981f1d497" title="Guest" subject="矩形" date="D:20240406112734+08'00'" creationdate="D:20240406112730+08'00'"/><underline page="247" rect="36.720,374.170,307.441,400.320" color="#A6A1E6" flags="print" name="2d66cc62-07ee-cf72-2cb5-3ef323e8ab05" title="Guest" subject="下划线" date="D:20240406150550+08'00'" creationdate="D:20240406150550+08'00'" coords="217.3144,400.3201,307.20029999999997,400.3201,217.3144,394.8,307.20029999999997,394.8,36.97,390.23999999999995,307.44059999999996,390.23999999999995,36.97,384.47999999999996,307.44059999999996,384.47999999999996,36.720000000000006,379.93,119.92080000000001,379.93,36.720000000000006,374.17,119.92080000000001,374.17"><contents>可以在执行完当前正在执行的
指令之后，检测到从 CPU 外部发送过来的或内部产生的一种特殊信息， 并且可以立即对
所接收到的信息进行处理。</contents></underline><square page="247" rect="21.790,156.820,317.070,227.650" color="#007A3B" flags="print" name="11048eca-2e65-2057-2319-a478a37c13e1" title="Guest" subject="矩形" date="D:20240406150659+08'00'" creationdate="D:20240406150657+08'00'"/><underline page="247" rect="37.440,83.760,307.450,99.840" color="#A6A1E6" flags="print" name="9e30bcfc-e808-beec-c950-6630acc85e83" title="Guest" subject="下划线" date="D:20240406150734+08'00'" creationdate="D:20240406150734+08'00'" coords="273.13,99.84000000000003,307.45,99.84000000000003,273.13,94.07999999999998,307.45,94.07999999999998,37.44,89.51999999999998,262.80039999999997,89.51999999999998,37.44,83.75999999999999,262.80039999999997,83.75999999999999"><contents>我们将产生
中断信息的事件，即中断信息的来源 ， 简称为中断源，上述的 4 种中断源</contents></underline><underline page="248" rect="36.720,289.920,307.450,306" color="#A6A1E6" flags="print" name="8bf2969d-e63c-0b09-abb6-359868c0317e" title="Guest" subject="下划线" date="D:20240406150835+08'00'" creationdate="D:20240406150835+08'00'" coords="50.65,306,307.45,306,50.65,300.24,307.45,300.24,36.720000000000006,295.67999999999995,179.05,295.67999999999995,36.720000000000006,289.91999999999996,179.05,289.91999999999996"><contents>CPU 的设计者必须在中 断信息和其处理程序的入口地址之间建立某种联系，使得
CPU 根据中断信息可以找到要执行的处理程序 。</contents></underline><underline page="248" rect="36.720,168,307.451,204.490" color="#A6A1E6" flags="print" name="e6d05452-4284-d8c5-6f9a-afc0a1f28fc7" title="Guest" subject="下划线" date="D:20240406150910+08'00'" creationdate="D:20240406150910+08'00'" coords="50.65,204.49,307.44,204.49,50.65,198.73000000000002,307.44,198.73000000000002,36.97,194.15999999999997,307.44,194.15999999999997,36.97,188.39999999999998,307.44,188.39999999999998,36.97,183.85000000000002,307.45050000000003,183.85000000000002,36.97,178.09000000000003,307.45050000000003,178.09000000000003,36.720000000000006,173.5201,87.60000000000001,173.5201,36.720000000000006,168,87.60000000000001,168"><contents>CPU 用 8 位的中断类型码通过中断向散表找到相应的中断处理程序的入口地址。那
么什么是中断向歉表呢？中断向砬表就是中断向显的列表 。 那么什么又是中断向歉呢 ？ 所
谓中断向最，就是中断处理程序的入口地址 。 展开来讲 ， 中断向最表 ， 就是中断处理程序
入口地址的列表 。</contents></underline><underline page="248" rect="37.440,59.280,307.211,75.360" color="#A6A1E6" flags="print" name="b8b7c398-0fdd-795e-e1c3-e8c013866edc" title="Guest" subject="下划线" date="D:20240406151009+08'00'" creationdate="D:20240406151009+08'00'" coords="72,75.36000000000001,307.2106,75.36000000000001,72,69.60000000000002,307.2106,69.60000000000002,37.44,65.04000000000002,143.05,65.04000000000002,37.44,59.27999999999997,143.05,59.27999999999997"><contents>CPU 如何找到 中断向蜇表 ？ 现在 ， 找到中断向蜇表成了通过中断类型码找到
中断处理程序入口地址的先决条件。</contents></underline><underline page="249" rect="36.970,380.890,307.690,396.720" color="#A6A1E6" flags="print" name="8f8bee91-197c-5b99-817a-07c77dba1fa1" title="Guest" subject="下划线" date="D:20240406151059+08'00'" creationdate="D:20240406151059+08'00'" coords="199.20999999999998,396.7201,307.69,396.7201,199.20999999999998,391.2,307.69,391.2,36.97,386.65,267.85,386.65,36.97,380.89,267.85,380.89"><contents>这个入 口 地址包括段地址和偏移地
址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址 。</contents></underline><underline page="249" rect="217.340,327.175,255.677,334.317" color="#A6A1E6" flags="print" name="9720dafb-604b-abe6-5594-55a0f85a565f" title="Guest" subject="下划线" date="D:20240406151152+08'00'" creationdate="D:20240406151152+08'00'" coords="217.34,334.31728979999997,255.67739999999998,334.31728979999997,217.34,327.1747782,255.67739999999998,327.1747782"><contents>SB 01 70 00</contents></underline><underline page="249" rect="36.970,123.840,307.440,139.930" color="#A6A1E6" flags="print" name="c10bce65-cddd-0c4c-ddc6-07ebcba2386f" title="Guest" subject="下划线" date="D:20240406151315+08'00'" creationdate="D:20240406151315+08'00'" coords="63.87440000000001,139.92999999999995,307.44,139.92999999999995,63.87440000000001,134.16999999999996,307.44,134.16999999999996,36.97,129.3601,279.36,129.3601,36.97,123.84000000000003,279.36,123.84000000000003"><contents>在使用 call 指令调用子程序时有同样的间题，子程序执行后还要返回到原来的执
行点继续执行，所以， call 指令先保存当前 CS 和 IP 的值，然后再设置 CS 和 IP 。</contents></underline><square page="249" rect="33.530,41.690,322.730,107.700" color="#007A3B" flags="print" name="a3567116-bd9e-fef9-7936-876af02dbbed" title="Guest" subject="矩形" date="D:20240406151325+08'00'" creationdate="D:20240406151323+08'00'"/><square page="250" rect="35.840,232.330,168.910,299.390" color="#007A3B" flags="print" name="e084855a-0b97-39b9-36a5-5eb8ecd90e01" title="Guest" subject="矩形" date="D:20240406151522+08'00'" creationdate="D:20240406151521+08'00'"/><square page="250" rect="42.960,90.340,277.670,149.640" color="#007A3B" flags="print" name="97b72c8a-bfd7-bb67-6fed-7573db7c03a1" title="Guest" subject="矩形" date="D:20240406151628+08'00'" creationdate="D:20240406151626+08'00'"/><underline page="253" rect="36.720,308.640,307.451,335.050" color="#A6A1E6" flags="print" name="b3b859e6-0c50-c333-7f68-62dd5a4151ca" title="Guest" subject="下划线" date="D:20240406152047+08'00'" creationdate="D:20240406152047+08'00'" coords="36.720000000000006,335.04999999999995,307.45050000000003,335.04999999999995,36.720000000000006,329.28999999999996,307.45050000000003,329.28999999999996,36.97,324.71999999999997,307.4406,324.71999999999997,36.97,318.96,307.4406,318.96,37.21,314.40000000000003,227.05,314.40000000000003,37.21,308.64000000000004,227.05,308.64000000000004"><contents>DOS 系统和其他应用程序都不会随便使用这段空间。可以利用 中断向显表中 的空闲单元
来存放我们的程序。一般情况下，从 0000:0200 至 0000:02FF 的 256 个字节的空间所对应
的中断向散表项都是空的 ， 操作系统和其他应用程序都不占用 。</contents></underline><underline page="254" rect="36.970,296.640,307.440,323.050" color="#A6A1E6" flags="print" name="c75a1a24-8f61-308b-a04f-302531789fbe" title="Guest" subject="下划线" date="D:20240406152201+08'00'" creationdate="D:20240406152201+08'00'" coords="107.76,323.04999999999995,307.21,323.04999999999995,107.76,317.28999999999996,307.21,317.28999999999996,36.97,312.4801,307.44,312.4801,36.97,306.96,307.44,306.96,37.44,302.40000000000003,168.186,302.40000000000003,37.44,296.64000000000004,168.186,296.64000000000004"><contents>首先执行 doO 安装程序，将 doO 的代码复制到内存 0:200 处，然后
设置中断向篮表，将 doO 的入口地址，即偏移地址 200H 和段地址 o , 保存在 0 号表项
中。这两部分工作完成后，程序就返回了。</contents></underline><square page="254" rect="30.390,58.860,319.370,113.560" color="#007A3B" flags="print" name="e547d840-4a60-9ca5-fc6f-87231a9451d4" title="Guest" subject="矩形" date="D:20240406152339+08'00'" creationdate="D:20240406152337+08'00'"/><underline page="256" rect="103.151,199.223,172.851,205.249" color="#A6A1E6" flags="print" name="c410d43b-a9a3-7ce2-9fe9-ed4c9d525f20" title="Guest" subject="下划线" date="D:20240406152532+08'00'" creationdate="D:20240406152532+08'00'" coords="103.15065390000001,205.24928980000004,172.85122780000003,205.24928980000004,103.15065390000001,199.2227782,172.85122780000003,199.2227782"><contents>o ffset doOend-o ffset</contents></underline><underline page="256" rect="53.530,45.370,264.450,51.130" color="#A6A1E6" flags="print" name="54facb3c-5dd8-303c-13fc-35185cdcb68e" title="Guest" subject="下划线" date="D:20240406152618+08'00'" creationdate="D:20240406152618+08'00'" coords="53.53,51.129999999999995,264.45,51.129999999999995,53.53,45.370000000000005,264.45,45.370000000000005"><contents>“ -”是编译器识别的运算符号，编译器可以用它来进行两个常数的减法</contents></underline><underline page="260" rect="36.970,270,307.450,286.090" color="#A6A1E6" flags="print" name="15face1b-383a-b54f-2673-0e30c9f8fa82" title="Guest" subject="下划线" date="D:20240406153043+08'00'" creationdate="D:20240406153043+08'00'" coords="50.65,286.09,307.45,286.09,50.65,280.33,307.45,280.33,36.97,275.5201,293.77,275.5201,36.97,270,293.77,270"><contents>基本上， CPU 在执行完一条指令之后，如果检测到标志寄存器的 TF 位为 l ，则产生
单步中断，引发中断过程。单步中断的中断类型码为 1 ，则它所引发的中断过程如下。</contents></underline><underline page="260" rect="36.720,48,307.440,64.090" color="#A6A1E6" flags="print" name="6a135b92-231f-4c8d-2338-f66ed21a51cd" title="Guest" subject="下划线" date="D:20240406153139+08'00'" creationdate="D:20240406153139+08'00'" coords="57.37,64.09000000000003,307.44030000000004,64.09000000000003,57.37,58.329999999999984,307.44030000000004,58.329999999999984,36.720000000000006,53.75999999999999,233.53000000000003,53.75999999999999,36.720000000000006,48,233.53000000000003,48"><contents>Debug 提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输
入命令。然后，在使用 t 命令执行指令时， Debug 将 TF 设置为 l</contents></underline><underline page="261" rect="36.720,308.640,307.451,335.050" color="#A6A1E6" flags="print" name="9dfad830-7d2c-0f5a-cd82-de42e88a4d6c" title="Guest" subject="下划线" date="D:20240406153237+08'00'" creationdate="D:20240406153237+08'00'" coords="50.65,335.04999999999995,307.451,335.04999999999995,50.65,329.28999999999996,307.451,329.28999999999996,36.720000000000006,324.4801,307.44019999999995,324.4801,36.720000000000006,318.96,307.44019999999995,318.96,36.720000000000006,314.40000000000003,103.158,314.40000000000003,36.720000000000006,308.64000000000004,103.158,308.64000000000004"><contents>CPU 当然不能让这种情况发生，解决的办法就是， 在进入中断处理程序之前，设置
TF=0。从而避免 CPU 在执行中断处理程序的时候发生单步中断。这就是为什么在中断过
程中有 TF=0 这个步骤</contents></underline><underline page="261" rect="36.720,93.600,307.450,109.680" color="#A6A1E6" flags="print" name="6691a683-cb0e-bdb8-0c1d-217fe1041e5b" title="Guest" subject="下划线" date="D:20240406153515+08'00'" creationdate="D:20240406153515+08'00'" coords="140.2363,109.68,307.45,109.68,140.2363,103.92000000000002,307.45,103.92000000000002,36.720000000000006,99.36000000000001,115.56,99.36000000000001,36.720000000000006,93.60000000000002,115.56,93.60000000000002"><contents>将设置 ss 和 sp 的指令连续存放，使得设置 sp 的指令紧
接着设置 ss 的指令执行，</contents></underline><underline page="263" rect="36.720,374.170,307.440,390.240" color="#A6A1E6" flags="print" name="ec7eb2dd-e8be-e887-b67f-3539ab226ee3" title="Guest" subject="下划线" date="D:20240406195004+08'00'" creationdate="D:20240406195004+08'00'" coords="288,390.23999999999995,307.44019999999995,390.23999999999995,288,384.47808000000003,307.44019999999995,384.47808000000003,36.720000000000006,379.93,88.90960000000001,379.93,36.720000000000006,374.17,88.90960000000001,374.17"><contents>中断过
程和两种内中断的</contents></underline><square page="263" rect="42.050,247.800,292.820,308.710" color="#007A3B" flags="print" name="b196f8ec-d1a0-bcd3-5305-0c2e24b87402" title="Guest" subject="矩形" date="D:20240406195101+08'00'" creationdate="D:20240406195100+08'00'"/><underline page="264" rect="36.720,411.850,306.961,427.930" color="#A6A1E6" flags="print" name="5ce1ac6c-790b-5f34-4e75-b185bf0f194c" title="Guest" subject="下划线" date="D:20240406195220+08'00'" creationdate="D:20240406195220+08'00'" coords="50.879999999999995,427.93,306.9607,427.93,50.879999999999995,422.17,306.9607,422.17,36.720000000000006,417.37010000000004,246.082,417.37010000000004,36.720000000000006,411.85,246.082,411.85"><contents>一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用
程序调用。我们在编程的时候，可以用 int 指令调用这些子程序 。 当</contents></underline><underline page="264" rect="176.170,231.370,286.560,236.170" color="#A6A1E6" flags="print" name="bc1ef17a-f77d-0c8d-942e-3968f2e49236" title="Guest" subject="下划线" date="D:20240406195322+08'00'" creationdate="D:20240406195322+08'00'" coords="176.17,236.17000000000002,286.5601,236.17000000000002,176.17,231.37,286.5601,231.37"><contents>7ch 的中断例程，计算 ax 中的数据的平方</contents></underline><underline page="265" rect="50.650,155.760,293.040,161.280" color="#A6A1E6" flags="print" name="0756943c-642d-377c-a887-abd95ee3b5d2" title="Guest" subject="下划线" date="D:20240406195454+08'00'" creationdate="D:20240406195454+08'00'" coords="50.65,161.2801,293.04,161.2801,50.65,155.76,293.04,155.76"><contents>int 指令和 ］rel 指令的配合使用与 ca]］ 指令和 rel 指令的配合使用具有相似的思路 。</contents></underline><underline page="267" rect="78.230,253.157,166.891,259.519" color="#A6A1E6" flags="print" name="d1498eb8-1cfc-bb9e-ce07-91d358e0bd48" title="Guest" subject="下划线" date="D:20240406195711+08'00'" creationdate="D:20240406195711+08'00'" coords="78.23,259.5186,166.89124220000002,259.5186,78.23,253.1574,166.89124220000002,253.1574"><contents>mov bx , offset s - offset se</contents></underline><underline page="269" rect="64.800,227.290,226.570,232.810" color="#A6A1E6" flags="print" name="4865dd1e-e67d-43b1-0631-e9b5f0b50d12" title="Guest" subject="下划线" date="D:20240406195909+08'00'" creationdate="D:20240406195909+08'00'" coords="64.8,232.81009999999998,226.57039999999998,232.81009999999998,64.8,227.28999999999996,226.57039999999998,227.28999999999996"><contents>外部中断（第 1 5 章中进行讲解）和 内部中断的中断例程；</contents></underline><underline page="276" rect="37.210,296.640,307.441,312.720" color="#A6A1E6" flags="print" name="3f2befae-99e1-541e-2c9b-8eddf9b51573" title="Guest" subject="下划线" date="D:20240406200115+08'00'" creationdate="D:20240406200115+08'00'" coords="99.83999999999999,312.71999999999997,307.44059999999996,312.71999999999997,99.83999999999999,306.96,307.44059999999996,306.96,37.21,302.16010000000006,191.53000000000003,302.16010000000006,37.21,296.64000000000004,191.53000000000003,296.64000000000004"><contents>都有一组可以由 CPU 读写的寄存器 。 这些寄存器， 它们在物理上可
能处千不同的芯片中，但是它们在以下两点上相同 。</contents></underline><underline page="276" rect="36.720,102,307.200,128.400" color="#A6A1E6" flags="print" name="fd977189-ea76-87ea-241b-fd75de3f7651" title="Guest" subject="下划线" date="D:20240406200247+08'00'" creationdate="D:20240406200247+08'00'" coords="213.12,128.39999999999998,307.2,128.39999999999998,213.12,122.63999999999999,307.2,122.63999999999999,36.97,118.07999999999998,302.87999999999994,118.07999999999998,36.97,112.32,302.87999999999994,112.32,36.720000000000006,107.75999999999999,253.20000000000002,107.75999999999999,36.720000000000006,102,253.20000000000002,102"><contents>因为端口所在的芯片和 CPU 通
过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送 。 在 PC 系统中 ，
CPU 最多可以定位 64KB 个不同的端 口 。 则端口地址的范围为 0~65535 。</contents></underline><underline page="276" rect="36.720,76.080,204.000,81.600" color="#A6A1E6" flags="print" name="36aa8b66-f318-1622-8b2a-aa8670fc8349" title="Guest" subject="下划线" date="D:20240406200300+08'00'" creationdate="D:20240406200300+08'00'" coords="36.720000000000006,81.6001,204.00000000000003,81.6001,36.720000000000006,76.07999999999998,204.00000000000003,76.07999999999998"><contents>m 和 out , 分别用千从端口读取数据和往端 口写入数据 。</contents></underline><square page="278" rect="42.660,211.850,202.170,262.160" color="#007A3B" flags="print" name="66fac055-3dca-d71f-0d1b-1f8805a9a468" title="Guest" subject="矩形" date="D:20240406201248+08'00'" creationdate="D:20240406201246+08'00'"/><underline page="283" rect="36.970,200.400,307.450,263.050" color="#A6A1E6" flags="print" name="e09e7450-83b3-3a54-69e1-dd7934d503ce" title="Guest" subject="下划线" date="D:20240406201349+08'00'" creationdate="D:20240406201349+08'00'" coords="50.879999999999995,263.04999999999995,307.44,263.04999999999995,50.879999999999995,257.28999999999996,307.44,257.28999999999996,36.97,252.72,220.5702,252.72,36.97,246.96,220.5702,246.96,50.879999999999995,237.13,307.44999999999993,237.13,50.879999999999995,231.37,307.44999999999993,231.37,36.97,226.56009999999998,307.44,226.56009999999998,36.97,221.03999999999996,307.44,221.03999999999996,36.97,216.49,307.44,216.49,36.97,210.73000000000002,307.44,210.73000000000002,37.21,206.15999999999997,136.08,206.15999999999997,37.21,200.39999999999998,136.08,200.39999999999998"><contents>第 14 章我们讲过， PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯
片的内部有若干寄存器， CPU 将这些寄存器当作端口来访问。
外设的输入不直接送入内存和 CPU, 而是送入相关的接口芯片的端口 中： CPU 向外
设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。 CPU 还
可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关
的芯片根据命令对外设实施控制 。</contents></underline><underline page="283" rect="64.800,70.320,245.530,76.080" color="#A6A1E6" flags="print" name="8b12bd3a-c27f-e472-5f3d-3c40d033e408" title="Guest" subject="下划线" date="D:20240406202017+08'00'" creationdate="D:20240406202017+08'00'" coords="64.8,76.07999999999998,245.53000000000003,76.07999999999998,64.8,70.32,245.53000000000003,70.32"><contents>外设的输入到达，相关芯片将向 CPU 发出相应的中断信息 。</contents></underline><square page="284" rect="22.270,332.610,317.950,450.160" color="#007A3B" flags="print" name="8ff6759a-b8c0-379f-f4ff-c0af4e89a78f" title="Guest" subject="矩形" date="D:20240406202106+08'00'" creationdate="D:20240406202103+08'00'"/><underline page="298" rect="78.240,147.600,289.920,153.120" color="#A6A1E6" flags="print" name="567da7fd-c263-6f49-9965-aa15c346d1bf" title="Guest" subject="下划线" date="D:20240406202234+08'00'" creationdate="D:20240406202234+08'00'" coords="78.24000000000001,153.12009999999998,289.92,153.12009999999998,78.24000000000001,147.60000000000002,289.92,147.60000000000002"><contents>code 、 a 、 b 、 start 、 s 都是标号 。 这些标号仅仅表示了内存单元的地址。</contents></underline><underline page="299" rect="36.970,340.570,307.451,366.960" color="#A6A1E6" flags="print" name="80613ba1-80a1-526e-72fe-eb33f3936c04" title="Guest" subject="下划线" date="D:20240406202335+08'00'" creationdate="D:20240406202335+08'00'" coords="50.879999999999995,366.96,307.44,366.96,50.879999999999995,361.2,307.44,361.2,37.21,356.65,307.45079999999996,356.65,37.21,350.89,307.45079999999996,350.89,36.97,346.0901,132.72,346.0901,36.97,340.57,132.72,340.57"><contents>在 code 段中使用的标号 a 、 b 后面没有 ＂ ： ＂，它们是同时描述内存地址和单元长度
的标号 。 标号 a , 描述了地址 code :O , 和从这个地址开始，以后的内存单元都是字节单
元 ： 而标号 b 描述了地址 code:8</contents></underline><underline page="307" rect="198.160,417.406,250.560,429.458" color="#A6A1E6" flags="print" name="0931e2e6-9d9d-fac8-e614-07f826019d31" title="Guest" subject="下划线" date="D:20240406202601+08'00'" creationdate="D:20240406202601+08'00'" coords="198.16,429.4584,250.56,429.4584,198.16,417.4056,250.56,417.4056"><contents>直接定址表</contents></underline><square page="14" rect="237.470,66.090,309.650,191.180" color="#007A3B" flags="print" name="564b0cd0-30be-eff1-5099-982a381d696f" title="Guest" subject="矩形" date="D:20240407084321+08'00'" creationdate="D:20240407084319+08'00'"/><square page="15" rect="44.310,77.100,308.830,196.440" color="#007A3B" flags="print" name="829bf22e-ac7c-daab-2b5f-687baa13a043" title="Guest" subject="矩形" date="D:20240407084748+08'00'" creationdate="D:20240407084711+08'00'"/><underline page="16" rect="183.600,192.240,213.360,200.880" color="#A6A1E6" flags="print" name="b4118822-1e52-fe6a-251e-2f7de9b9fed6" title="Guest" subject="下划线" date="D:20240407085032+08'00'" creationdate="D:20240407085032+08'00'" coords="183.59999999999997,200.88,213.35999999999999,200.88,183.59999999999997,192.24,213.35999999999999,192.24"><contents>总 线</contents></underline><square page="22" rect="125.920,71.480,224.760,210.510" color="#007A3B" flags="print" name="9983b157-8596-674a-33b7-16f45cf2776b" title="Guest" subject="矩形" date="D:20240407090322+08'00'" creationdate="D:20240407090319+08'00'"/><square page="32" rect="43.930,294.640,299.430,449.250" color="#007A3B" flags="print" name="622e2a33-1820-4cf1-935c-7928d2451c7a" title="Guest" subject="矩形" date="D:20240407091254+08'00'" creationdate="D:20240407091251+08'00'"/><underline page="297" rect="36.720,411.600,304.080,426.720" color="#A6A1E6" flags="print" name="d35b2e15-4555-0091-0614-33f03fa930f7" title="Guest" subject="下划线" date="D:20240407095026+08'00'" creationdate="D:20240407095026+08'00'" coords="48.720000000000006,426.71999999999997,304.08000000000004,426.71999999999997,48.720000000000006,421.91999999999996,304.08000000000004,421.91999999999996,36.720000000000006,416.40000000000003,164.41,416.40000000000003,36.720000000000006,411.6,164.41,411.6"><contents>这些指令对标志寄存器或其他处理机状态进行设置，比如， cld 、 std 、 cli 、 sti 、 nop 、 clc 、 cmc 、
stc 、 hlt 、 wai t 、 esc 、 lock 等都是处理机控制指令。</contents></underline><square page="69" rect="20.650,142.050,325.200,416.270" color="#007A3B" flags="print" name="17eb8243-96ba-be64-89bc-b0bf1fb237ea" title="Guest" subject="矩形" date="D:20240407112614+08'00'" creationdate="D:20240407112613+08'00'"/></annots><pages><defmtx matrix="1,0,0,-1,0,486.24"/></pages></xfdf>