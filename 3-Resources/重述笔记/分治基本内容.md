---
Project: "[[分治|分治]]"
Status: 🟨
tags:
  - Resources
Deadline: 2024-03-21
CreateTime: 2024-03-21
Connected: 
---
# 分治基本内容

「分治 divide and conquer」，全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤。
1. 分（划分阶段）：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。
2. 治（合并阶段）：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。
# 如何判断分治问题
一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。
1. 问题可以被分解：原问题可以被分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。
2. 子问题是独立的：子问题之间是没有重叠的，互相没有依赖，可以被独立解决。
3. 子问题的解可以被合并：原问题的解通过合并子问题的解得来。
如归并排序满足以上三条判断依据
1. 问题可以被分解：递归地将数组（原问题）划分为两个子数组（子问题）。
2. 子问题是独立的：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。
3. 子问题的解可以被合并：两个有序子数组（子问题的解）可以被合并为一个有序数组（原问题的解）。
# 通过分治提升效率
分治不仅可以有效地解决算法问题，往往还可以带来算法效率的提升。在排序算法中，快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略。

## 将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高?
### 1. 操作数量优化
![[BAvMXOSKbrXnYZww-edacf652-f512-c06f-a0a8-6332aa021446.png|970]]
进一步想，如果我们把子数组不断地再从中点划分为两个子数组，直至子数组只剩一个元素时停止划分呢？这种思路实际上就是“归并排序”，时间复杂度为 𝑂(𝑛 log 𝑛) 。

再思考，如果我们多设置几个划分点，将原数组平均划分为 𝑘 个子数组呢？这种情况与“桶排序”非常类似，它非常适合排序海量数据，理论上时间复杂度可以达到 𝑂(𝑛 + 𝑘) 。

### 2. 并行计算优化
分治生成的子问题是相互独立的，因此通常可以并行解决。也就是说，分治不仅可以降低算法的时间复杂度，还有利于操作系统的并行优化。

# 分治常见应用
## 算法问题
- 寻找最近点对：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后再找出跨越两部分的最近点对。
- 大整数乘法：例如Karatsuba 算法，它是将大整数乘法分解为几个较小的整数的乘法和加法。
- 矩阵乘法：例如 Strassen 算法，它是将大矩阵乘法分解为多个小矩阵的乘法和加法。
- 汉诺塔问题：汉诺塔问题可以视为典型的分治策略，通过递归解决。
- 求解逆序对：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以通过分治的思想，借助归并排序进行求解。
## 数据结构
- 二分查找：二分查找是将有序数组从中点索引分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，然后在剩余区间执行相同的二分操作。
- 归并排序：文章开头已介绍，不再赘述。
- 快速排序：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，然后再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。
- 桶排序：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。
- 树：例如二叉搜索树、AVL 树、红黑树、B 树、B+树等，它们的查找、插入和删除等操作都可以视为分治的应用。
- 堆：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。
- 哈希表：虽然哈希表来并不直接应用分治，但某些哈希冲突解决策略间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。