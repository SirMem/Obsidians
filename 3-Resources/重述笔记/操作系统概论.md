---
Project: "[[4-Archives/Stopping/操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 
Connected: 
---

# 从helloworld说起
- hello 这个可执行文件是如何存储在计算机中的？ 
- 如何根据字符串 "hello" 找到存储在计算机中的 hello 文件？
- hello 文件是如何加载到内存中的？内存的布局是什么样的？
- hello 程序在执行过程中是如何将 “ Hello World!" 输出到显示器的？
- 两个 hello 程序是如何同时在一个 CPU 上运行的？
- 两个 hello 程序同时运行，为什么输出的字符串不会互相覆盖？
- 是否可以支持 1 万个 hel lo 同时运行？ 10 万个呢？ 100 万个呢？
- 如果能支持 100 万个 hello 同时运行，内存不够怎么办？
- 如果 hel lo 和其他应用程序同时运行，其中有一个应用出现运行故障（如发生死循环），是否会干扰 hello 的正常运行？

# 操作系统是什么
操作系统有两个职责：对硬件进行管理和抽象，为应用提供服务并进行管理。

# 操作系统接口
## 操作系统接口层级
![[raVzvbusFpmvqlHI-10f8e759-339a-7cd5-5efd-9e91a083c90a.png|838]]
## 系统调用接口
应用程序通过操作系统内核提供的接口向内核申请服务，这些接口通常称为系统调用接口。 不同的操作系统提供的系统调用接口往往各不相同，同—操作系统的不同版本所提供的系统调用接口也会有所变化。

以 hello 程序中的 printf 为例展示了系统调用的执行过程。 首先， printf调用标准库 Jibe 中的 write 函数。

libc 在准备好相关的参数后，执行 SVC 指令。使控制流从应用程序的代码转移到操作系统内核的代码，即运行主体由应用程序切换为操作系统内核。

内核的处理函数根据系统调用传入的第一个参数，识别出该调用需要执行操作系统内核提供的 sys_write 函数，从而通过系统调用表找到并调用该函数。 从上述例子可以看出，系统调用是用户态应用向操作系统内核请求服务的方法。

![[raVzvbusFpmvqlHI-04fe14bb-8c9e-d1e7-5875-24c909be1788.png|1163]]

## POSIX接口
由于每个操作系统提供的系统调用各不相同，为了实现同一应用程序在不同操作系统上的可移植性，逐渐形成了关于操作系统接口的一些标准， POSIX 是其中应用最广泛的一个。

POSIX是Portable Operating System Interface for uniX的简写，即可移植操作系统接口 ， X 表明其是对 UNIX API 的传承。

在 POSIX 被提出之前，世界上存在很多不同的 UNIX 操作系统。这些接口各异的操作系统对应用程序开发人员造成了比较大的困扰。为了使应用程序能够运行在不同的 UNIX 操作系统之上， IEEE 于 20 世纪 80 年代定义了一套标准的操作系统 API。POSIX 这个名称是由开源软
件先驱Richard Stallman 应 IEEE 的请求而取的一个易于记忆的名称。

POSIX 标准通常通过C 语言库 (C library, libc) 在用户地址空间实现，常见的 libc 包括 glibc 、 musl 、 eglibc 等，Android 也实现了一个名为 bionic 的 Iibc。 

通常而言，应用程序只需要调用 libc 提供的接口就可以实现对操作系统功能的调用，这样一方面可支持应用在类 UNlX 系统（包括 Linux)上的可移植性，另一方面也使新的操作系统可以通过移植 libc 支持现有的应用生态。

## 领域应用接口
在 POSIX 或操作系统调用的基础上还可以封装面向不同领域的应用接口 。 为了应用开发的便捷性（如更多可复用的功能），人们逐渐开始为各个应用领域定义应用开发接口与软件架构。

例如，面向汽车领域，一些车企联合起来定义了AUTOSAR ( AUTomotive Open System ARchitecture )，从而方便汽车电子平台各个部件的开发者遵循同一标准和软件架构进行开发。 随着汽车智能化引起的功能需求的增加，AUTOSAR 也逐步演进到了 Adaptive AUTOSAR, 并提供更为丰富的应用开发接口 。

Android 应用框架为移动应用开发人员在 Android 操作系统上开发 App 定义了应用开发接口， iOS 同样也为苹果手机平台定义了应用开发接口 。