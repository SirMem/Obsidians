---
Project: "[[4-Archives/Stopping/操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-14
Connected: 
---

# Q&A
为什么需要进程这一抽象？
相比直接使用物理内存地址，使用虚拟内存地址有哪些优势?
为什么说"一切皆文件"?

## 引入
基于异常机制和[[操作系统的硬件运行环境(系统ISA)#系统ISA|系统ISA]], 操作系统为应用程序提供底层硬件的抽象与接口，使应用程序能够更方便地使用硬件，包括处理器、物理内存和设备。
![[raVzvbusFpmvqlHI-6e095043-68bb-c1ed-c37b-e0a26e5a0cfb.png|1854]]
# 接口抽象
## 并发与并行
其中，对处理器的抽象是进程。 操作系统将多个应用程序通过分时复用的方式在单个处理器上交替执行，使这些应用看上去像是“同时“在运行。

之后提出了更轻量级的线程抽象以及多线程机制，允许一个应用程序并行使用多个处理器。 

## 文件
对存储、网络、键盘、显示器等外部设备的抽象是文件。
文件有一组很直观的操作接口，包括打开、读取、写入、关闭等。 将设备抽象为文件，可使应用程序通过同一套接口来操作不同的设备。
## 内存虚拟化
对物理内存的抽象是虚拟内存，也就是对物理内存的虚拟化。应用程序可以使用与操作物理内存相同的接口（如 ldr 和str 指令）来操作虚拟内存，而不用考虑物理内存空间是否足够，与其他应用同时使用内存是否会产生冲突等问题。

## 总结
通过这些抽象和接口，应用程序可以使用操作系统提供的一系列功能。
其中，有些功能对应用程序来说不是直接感知的，例如处理器的分时复用、虚拟地址映射等；

有些功能则需要应用程序通过系统调用主动发起，例如创建进程、打开文件等。 操作系统提供的这些功能，使程序员不用考虑硬件资源管理的繁杂细节，降低了应用程序的编程复杂度。

# 进程
进程是程序在内存中的实例，是计算机中的程序关于其运行状态的抽象。它是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
![[Pasted image 20240415164829.png]]
## 虚拟空间简要
虚拟地址空间其实就是操作系统对每一个进程都认为自己独自占有占有内存的一种假象，用来存放虚拟地址。

进程和虚拟空间的关系主要体现在虚拟内存地址空间的概念上。在操作系统中，每个进程都有一个独立的虚拟地址空间，这是操作系统对每个进程都认为自己独自占有内存的一种假象。这种设计使得各个进程之间的地址空间互不干扰，相互独立

## 进程中的进程(线程)
线程，有时被称为轻量级进程（Lightweight Process，LWP），是程序执行流的最小单元。它是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务
## 进程间通信
### 子进程
进程和子进程之间有一种“父子”关系。在操作系统中，当一个进程创建另一个进程时，新创建的进程被称为子进程，而创建它的进程被称为父进程。这种关系通常是通过操作系统提供的 `fork()` 系统调用来创建的。

具体来说：
- 当一个进程调用 `fork()` 系统调用时，操作系统会创建一个新的进程，该新进程是调用进程（父进程）的副本。这个新的进程称为子进程。
- 子进程与父进程几乎完全相同，包括它们的代码、数据和上下文信息（比如打开的文件描述符）等。
- 子进程和父进程之间有着不同的进程ID（PID），但是除了这个以外，它们之间没有其他直接的关联。
- 子进程可以独立地执行不同的任务，它们与父进程并行运行，彼此之间相互独立。

子进程的创建可以使得程序执行并发任务，实现多任务处理和并行计算等功能。通常情况下，父进程会监视子进程的执行，并在需要时与其进行通信或协调。

## 操作系统给进程提供的接口
在提供进程这一抽象的同时，操作系统也提供了一系列接口，允许用户对进程进行操作 ， 如创建进程、 让进程执行指定的程序 、 退出进程等。

操作系统为了更好地管理进程，同时提供进程之间的互操作 、 通信等功能，一般会根据进程的创建关系，通过层次化的方式将所有进程组织起来。

通常，进程的创建者称为父进程，被创建的新进程则称为子进程。 每个子进程都有对应的父进程，一直往上可以追溯到系统启动的第一个进程（如 Linux 中的 init) 。

## 案例分析:使用POSIX进程接口实现shell
[[操作系统概论#POSIX接口|POSIX]] 规范提供了一组用千操作进程的接口，spawn 接口用于创建新进程， waitpid 接口用于等待进程退出并回收资源， exit 接口用于退出进程， getpid 接口用于获得当前进程的ID。 shell 便使用这些接口创建新的进程来执行用户命令，同时也能管理这些进程。

我们将利用 POSIX 接口来实现一个只包含最基础功能的 shell: mysh。mysh 接收来自用户的命令，但一次只能执行一个程序，不支持参数传递，且无法强制终止程序的执行。

```c
#include <stdio.h>  // 包含标准输入输出库
#include <spawn.h>  // 包含用于创建新进程的库
#include <sys/wait.h>  // 包含用于等待进程状态改变的函数
#include <string.h>  // 包含字符串操作函数
#include <stdlib.h>  // 包含一些常用的函数，如exit()
#define MAXLINE 1000  // 定义最大行长度为1000

// 主函数
int main()
{
	char cmdline[MAXLINE];  // 定义一个字符数组来存储命令行

	while(1){  // 无限循环，直到用户输入"quit"
		printf("mysh>");  // 打印提示符
		fflush(stdout);  // 清空输出缓冲区

		fgets(cmdline, MAXLINE, stdin);  // 从标准输入读取一行
		// 移除行尾的换行符
		cmdline[strcspn(cmdline,"\n")] = "\0";
		eval(cmdline);  // 执行命令行
	}
	return 0;
}

// eval函数，用于评估和执行命令行
void eval(char *cmdline)
{
	char *argv[2] = {cmdline, NULL};  // 定义参数列表
	if(strcmp(cmdline, "quit") == 0){  // 如果命令行是"quit"，则退出程序
		exit(0);
	}

	pid_t pid;  // 定义进程ID
	// 创建一个新的进程来执行命令
	posix_spawn(&pid, cmdline, NULL, NULL, argv, NULL);
	// 等待新进程终止
	int exit_status;
	waitpid(pid, & exit_status, 0);
	if(!WIFEXITED(exit_status)){  // 如果进程非正常终止，则打印错误信息
		printf("Program terminated unexpectedly!\n");
	}
}
```

这个程序是一个非常基础的shell，它只能执行单个命令，不能处理管道、重定向或者后台进程。如果你想要一个完全功能的shell，你需要处理这些高级特性。
### 标准输出流
输出缓冲区 stdout 是计算机程序中的一个术语，用于描述程序输出的临时存储区域。在许多编程语言中，当程序产生输出时，输出通常首先被写入到输出缓冲区中，然后才被传输到实际的输出设备，比如屏幕或文件。

这种缓冲机制有助于提高程序的性能，因为将输出数据暂时存储在缓冲区中可以减少对输出设备的访问次数。然而，有时候程序可能需要立即将输出刷新到设备上，而不是等到缓冲区满了或者程序执行结束才进行刷新。在这种情况下，程序员可以调用相应的函数来强制刷新输出缓冲区。

stdout 是标准输出流的名称，它通常与控制台输出相关联。在许多操作系统中，stdout 默认情况下会被设置成行缓冲模式，这意味着当程序输出一个换行符时，缓冲区会被刷新，输出被发送到目标设备。

# 虚拟内存
## 介绍
虚拟内存是一种计算机系统的内存管理技术，它使得程序能够访问比实际物理内存更大的地址空间，同时还可以提供更多的内存管理功能。

具体来说，虚拟内存通过将物理内存和磁盘上的存储空间组合起来，创建了一个抽象的、连续的地址空间，供程序使用。这个地址空间被称为虚拟地址空间，而程序中的地址称为虚拟地址。

严格来说不是所有虚拟地址都能使用，例如零地址通常无法使用。 若内核与应用共享地址空间，则内核占据的地址段也无法使用
## 特点

1. **地址空间扩展**：虚拟内存可以将物理内存和磁盘上的空间组合在一起，从而形成一个比物理内存更大的虚拟地址空间。这使得程序可以访问比物理内存更大的内存空间，提高了系统的可用内存大小。

2. **内存保护**：虚拟内存可以通过将内存划分为页面（或者页）并设置访问权限来提供内存保护机制。这样，不同的页面可以具有不同的权限，例如只读、读写、执行等。这可以防止程序访问非法的内存区域，提高系统的稳定性和安全性。

3. **内存共享**：虚拟内存允许多个进程共享相同的物理内存页。当多个进程都需要访问相同的数据或程序时，虚拟内存可以将这些共享的页面映射到它们的虚拟地址空间中，从而节省了内存空间，并提高了系统的效率。

4. **页面置换**：虚拟内存可以将物理内存中暂时不用的页面移出到磁盘上，从而腾出空间供其他页面使用。这个过程称为页面置换，它可以提高物理内存的利用率，允许系统在物理内存不足时继续运行程序。

## 映射
从虚拟地址到物理地址的地址翻译是由处理器与操作系统协同完成的：处理器负责在程序运行时将虚拟地址动态翻译为物理地址，橾作系统则负责配置虚拟地址与物理地址之间的具体映射。
![[raVzvbusFpmvqlHI-656ac57f-0f6e-2970-6a65-331012f42f0f.png|1357]]

一块连续虚拟地址的区域可以映射到多块不连续的物理内存区域，对于没有使用的虚拟地址区域，操作系统可以不做映射，从而节省物理内存。

## 例子
```c
#include <stdio.h>
#include <stdlih.b>
#include <unistd.h>

int g_val = 0;

int main(int argc, char** argv)
{
	g_val = strtol(argv[1], NULL, 10);
	pid_t pid = getpid();
	for(int i = 0; i < 2; i++){
		printf("[%d]The address of g_val is %p.\n",pid, &g_val);
		printf("[%d]The value of g_val is %d.\n",pid, g_val);
	}
}
```

## 好处
程序员在编程时，无须关心物理内存具体如何分配，也不用关心所使用的地址是否会与其他进程重叠，而是可以使用连续的整个虚拟地址空间，实际运行时的内 否会与其他进程重叠，而是可以使用连续的整个虚拟地址空间，实际运行时的内存资源分配由操作系统负责，进而大大减轻了程序员的负担。

每个应用程序的虚拟地址空间是彼此隔离的，丙此应用程序在运行期间的内存读写对其他应用程序是不可见的，这样就保证了不同应用程序之间的隔离，防止出错程序或恶意程序干扰或破坏其他程序的执行。

操作系统可以选择只将程序实际正在使用的虚拟地址映射到物理内存地址，对于从未被进程使用的虚拟地址，操作系统还可以不将其映射到任何位置，从而提高内存的资源利用率。

操作系统可以选择将部分虚拟内存区域的数据暂存到磁盘上，从而允许应用程序使用的内存大小突破物理内存的容批限制。

操作系统可以为不同的虚拟内存区域设置不同的权限，包括可读、可写、可执行，以及是允许用户态访间还是仅内核态可访问等，从而增强程序执行和系统整体的安全性。除此之外，操作系统还可以通过虚拟内存实现一些更加高级的功能，例如写时拷贝、程序间的内存共享等

## 进程的虚拟内存布局
每个进程都有自己独立的虚拟内存空间，其局大体都是相同的。其中，每个进程的虚拟内存
空间都是一段从 0 开始的连续地址空间 。 从低地址到高地址的分布如下 ：
- 代码段与数据段。 数据段与代码段通常位于虚拟地址空间中较低的地址。 其中，数据段主要保存的是全局变量的值，代码段保存的则是执行代码。 这两个部分都保存在可执行文件中，在进程执行前，操作系统会将它们载入虚拟地址空间 。
- 用户堆。 堆管理的是进程在运行过程中动态分配的内存，例如通过 malloc 分配的区域。 堆的扩展方向是自底向上：堆顶在高地址，当进程需要更多内存时，堆顶会向高地址扩展。
- 代码库。 进程的执行有时需要依赖共享的代码库（比如 libc)，这些代码库会被映射到用户栈下方的虚拟地址，并标记为只读。
- 用户栈。 栈保存了进程需要使用的各种临时数据（如临时变量的值） 。 栈是一个可以伸缩的数据结构，其扩展方向是自顶向下：栈底在高地址，栈顶在低地址。当临时数据被压入栈内时，栈顶会向低地址扩展。
- 内核部分。 进程地址空间顶端的部分通常是为操作系统内核保留的区域，又可以进一步细分为内核代码段、内核数据段、 内核栈等。应用程序无法直接访间这部分内存区域，只有操作系统内核才能访问。对于不同进程来说，这部分虚拟地址空间的映射都是一样的 。
![[raVzvbusFpmvqlHI-3a1e4c80-352a-ca26-efb1-ab9f85a3bfbb.png|750]]

# 文件:对存储设备的抽象 
对于大部分应用程序来说，仅仅有处理器和内存是远远不够的，因为内存中的数据在计算机重启后就完全消失了。 对用户而言，他们也有许多数据想要永久存储在计算机系统中，如日常生活中的文档、视频、程序等。 现代计算机系统中有着非常多样的存储设备，例如桌面主机中常见的机械硬盘与固态硬盘，以及移动端的嵌入式多媒体卡和通用闪存存储。

为了将不同存储设备的细节隐藏起来，让程序员可以通过统一、便利的方式来访问这些设备，操作系统使用了文件这一抽象。 文件是一个“有名字的字节序列＂，每个文件都拥有自己的文件名， 文件名独立于文件的数据而存在。 不同的文件名可以属于同一个目录，目录可以层层嵌套，顶层是根目录，通常用 “ /" 表示。

![[raVzvbusFpmvqlHI-fff44ed8-bea7-6fb2-b496-6d1cd1ecb084.png|1169]]

操作系统提供了一组接口用于文件访问，包括文件的打开、读取、写入、关闭等。例如， 应用程序可以通过 open 接口打开一个文件。 在打开成功后， open 会返回一个文件描述符 (File Descriptor. fd) 。 通过文件描述符，可以利用 read 、 write 接口分别对相应的文件进行读取和写入操作，并最终通过 close 关闭己打开的文件。 

除了通过 read 与 write 接口来访间文件外，操作系统也支持直接将文件映射到虚拟地址中来访问——这种方式称为内存映射，具体为 mmap 系统调用。 通过将文件与一块连续的虚拟内存区域相关联，用户程序可以直接通过读写内存的方式来访问文件。

![[raVzvbusFpmvqlHI-c5ca8ea4-7b50-bd63-c3f5-53155ba75061.png|1510]]
此图展示了使用 mmap 来映射一个文本文件的例子。
```c
#include <fcntl.h>  // 包含文件控制操作，如 open
#include <sys/mman.h>  // 包含内存管理函数，如 mmap
#include <unistd.h>  // 包含各种系统调用，如 write

int main()
{
	int fd = open("hello.txt", O_RDONLY);  // 打开名为 "hello.txt" 的文件，只读模式
	void *start = mmap(NULL, 13, PROT_READ, MAP_PRIVATE, fd, 0 /*offset*/);  // 将 "hello.txt" 文件的前13个字符映射到内存中
	write(1, start, 13);  // 将内存中的这13个字符写入到标准输出
}

```

首先通过 open 接口打开 hello.txt 文件，然后通过 mmap 将这一文件中的 13 个字符映射到内存中，并将得到的内存映射区域存放在 start 指针中。 PROT_READ 参数表明这段内存映射区域是只读的，同时 MAP_PRIVATE 参数表明这段内存映射区域是进程私有的，不能被其他进程操作。我们将 start 指向的内容输出，便能发现其与文件内容是一致的

# 文件:对所有设备的抽象
以 Linux 为代表的操作系统继承了 UNIX 经典的设计哲学 ”一切都是文件”(everything is a file )，将文件作为所有 I/O 设备的抽象。 这里主要有两方面的原因： 一方面，从用户的角度来看，许多设备确实有与文件类似的操作，比如对串口设备的读写操作，可以很自然地对应到对文件的读写操作；另一方面，从实现的角度来看，将设备抽象为文件可以复用操作系统中对文件进行操作的大批代码。

在 Linux 中，为了让应用程序能够访问某个设备，会首先为这个设备创建一个特殊的文件 设备文件，通常放在 /dev／目录下。如果应用程序需要操作这个设备，则可以通过 open 打开这个设备文件，获得对应的 fd, 并进一步进行读写操作。

例如，程序员平时常用的终端，实际上便是在与一类叫作 TTY 设备的特殊文件打交道。 在hello 程序中使用 printf 向终端进行输出时，实际上是通过 write 系统调用将需要输出的内容写入 TTY设备文件中。 类似地， mysb 在通过 fgets 读取用户输入时，实际上也是通过 read 系统调用从 TTY 设备文件中读取键盘的输入。 这一特殊文件的打开与关闭，是在进程创建与退出时由操作系统自动完成的。