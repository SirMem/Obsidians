---
Project: "[[4-Archives/Stopping/操作系统|操作系统]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-17
Connected: 
---

# 局部性
## 介绍
一个编写良好的计算机程序常常具有良好的局部性(locality) 。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理

## 时间局部性
在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用 。
## 空间局部性
在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能在不远的将来引用附近的一个内存位置。

## 对程序数据引用的局部性
![[eDqKLfGvNLCndwWt-f6d73f25-5bd3-9e01-3b29-a194a2bcc2ba.png|836]]
在这个例子中，变量 sum 在每次循环迭代中被引用一次，因此，对于 sum 来说，有好的时间局部性。另一方面，因为 sum是标量 ，对于 sum 来说，没有空间局部性。

向量 v 的元素是被顺序汶取的，一个接一个，按照它们存储在内存中的顺序（为了方便，假设数组是从地址 0 开始的）。因此，对于变量 v ,函数有很好的空间局部性，但是时间局部性很差，因为每个向量元索只被访问一次。

因为对于循环体中的每个变量，这个函数要么有好的空间局部性，要么有好的时间局部性，所以我们可以断定 sumvec 函数有良好的局部性。
![[eDqKLfGvNLCndwWt-32f0f230-35d8-2c71-7801-07db9d4434bb.png|824]]


![[eDqKLfGvNLCndwWt-1358eb0a-242b-c85b-486a-8dd7ad805707.png|814]]

函数 sumarraycols的空间局部性很差，因为它按照列顺序来扫描数组，而不是按照行顺序。因为 C 数组在内存中是按照行顺序来存放的，结果就得到步长为 N 的引用模式

## 取指令的局部性
因为程序指令是存放在内存中的， CPU 必须取出（读出）这些指令，所以我们也能够评价一个程序关千取指令的局部性。

例如，图 6-17 中 for 循环体里的指令是按照连续的内存顺序执行的，因此循环有良好的空间局部性。因为循环体会被执行多次，所以它也有很好的时间局部性。

## 小结
- 重复引用相同变量的程序有良好的时间局部性。
- 对于具有步长为 k 的引用模式的程序，步长越小，空间局部性越好。具有步长为 1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好 。

# 存储器层次结构中的缓存

## 存储器层次结构内容
![[eDqKLfGvNLCndwWt-f7c1c282-8b95-ce16-8398-f87d195df651.png|859]]

## 介绍
一般而言．高速缓存(cache, 读作 "cash")是一个小而快速的存储设备，它作为存储
在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存 (caching,读作 "cashing") 。

存储器层次结构的中心思想是，对于每个 k, 位于 k 层的更快更小的存储设备作为位于 k+1 层的更大更慢的存储设备的缓存。例如，本地磁盘作为通过网络从远程磁盘取出的文件（例如 Web 页面）的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存 CPU 寄存器组。

## 块
存储器被划分成连续的数据对象组块 (chunk), 称为块 (block) 。每个块都有一个唯一的地址或名字，使之区别于其他的块。块可以是固定大小的（通常是这样的），也可以是可变大小的（例如存储在Web 服务器上的远程 HTML 文件）
![[eDqKLfGvNLCndwWt-98089649-1999-1a0b-6283-063af9ef6348.png|663]]

L1 和 L0 之间的传送通常使用的是 1 个字大小的块。 L2 和 L1 之间（以及 L3 和 L2 之间、 L4 和 L3 之间）的传送通常使用的是几十个字节的块。而 L5 和 L4 之间的传送用的是大小为几百或几千字节的块。一般而言，层次结构中较低层（离 CPU 较远）的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。

## 缓存命中
当程序需要第 k + 1 层的某个数据对象 d 时，它首先在当前存储在第 k 层的一个块中查找 d 。如果 d 刚好缓存在第 k 层中，那么就是我们所说的缓存命中 (cache hit) 。该程序直接从第 k 层读取 d, 根据存储器层次结构的性质，这要比从第 k+1 层读取 d 更快。

另一方面，如果第 K 层中没有缓存数据对象 d, 那么就是我们所说的缓存不命中(cache miss) 。当发生缓存不命中时，第 K 层的缓存从第 k + 1 层缓存中取出包含 d 的那个块，如果第 k 层的缓存已经满了，可能就会覆盖现存的一个块。

覆盖一个现存的块的过程称为替换 (replacing) 或驱逐 (evicting) 这个块。被驱逐的这个块有时也称为牺牲块 (victim block) 。决定该替换哪个块是由缓存的替换策略 (replace­ment policy)来控制的。

## 缓存暖身
"缓存暖身"是指在系统启动或者某个特定操作之前，提前加载一些数据到缓存中，以便提高后续操作的性能。这个过程类似于把一辆冷车启动前让引擎预热一段时间，以便在启动时更加顺畅。

在软件开发中，缓存暖身可以用于优化系统性能。通过在系统启动或者某个特定操作之前，将预计会频繁使用的数据加载到缓存中，可以减少后续操作中的缓存不命中率，提高系统响应速度。这对于需要处理大量数据或者频繁进行某些操作的系统特别有用。
## 缓存不命中的种类
### 冷缓不命中(cold miss)
如果第 K 层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为冷缓存 (cold cache) , 此类不命中称为强制性不命中 (compulsory miss)或冷不命中 (cold miss) 。

只要发生了不命中，第 K 层的缓存就必须执行某个放置策略(placement policy), 确定把它从第 k+1 层中取出的块放在哪里。

### 冲突不命中 (conflict miss)
冲突不命中（Conflict Miss）是指在缓存中发生了一个不命中，这是因为缓存中的某些行已经被其他数据占据，而被请求的数据正好与这些占据了缓存行的数据发生了冲突。冲突不命中通常发生在使用直接映射或组相联映射的缓存结构中，因为它们都容易产生相同索引的冲突。。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身 (warmed up) 之后的稳定状态中出现。

例如，如果一个缓存使用直接映射，那么每个内存地址都只能映射到缓存的一个特定位置。如果多个内存地址被映射到了相同的缓存位置，那么它们就会发生冲突。当请求一个数据，而该数据的地址与已经存储在该缓存位置上的数据的地址冲突时，就会发生冲突不命中。

## 缓存管理
存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。在每一层上，某种形式的逻辑必须管理缓存。硬件控制器将缓存划分成块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。管理缓存的逻辑可以是硬件、软件，或是两者的结合。

例如，编译器管理寄存器文件，缓存层次结构的最高层。它决定当发生不命中时何时发射加载，以及确定哪个寄存器来存放数据。

L1 、 L2 和 L3 层的缓存完全是由内置在缓存中的硬件逻辑来管理的。在一个有虚拟内存的系统中， DRAM 主存作为存储在磁盘上的数据块的缓存，是由操作系统软件和 CPU 上的地址翻译硬件共同管理的。

对于一个具有像 AFS 这样的分布式文件系统的机器来说，本地磁盘作为缓存，它是由运行在本地机器上的 AFS 客户端进程管理的 。 在大多数时候，缓存都是自动运行的，不需要程序采取特殊的或显式的行动 。
## 小结
- 利用时间局部性：由于时间局部性，同一数据对象可能会被多次使用。 一旦一个数据对象在第一次不命中时被复制到缓存中，我们就会期望后面对该目标有一系列的访问命中。因为缓存比低一层的存储设备更快，对后面的命中的服务会比最开始的不命中快很多 。
- 利用空间局部性：块通常包含有多个数据对象。由于空间局部性，我们会期望后面对该块中其他对象的访问能够补偿不命中后复制该块的花费。
![[eDqKLfGvNLCndwWt-afc4f029-2c82-c296-1d4a-5e8a79787811.png|841]]

# 编写高速缓存友好的代码
## 循环
程序通常把大部分时间都花在少最的核心函数上，而这些函数通常把大部分时间都花在了少扯循环上。所以要把注意力集中在核心函数里的循环上，而忽略其他部分 。

尽量减小每个循环内部的缓存不命中数量 。 在其他条件（例如加载和存储的总次数）相同的情况下，不命中率较低的循环运行得更快。

- 对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文件中（时间局部性）。
- 步长为 1 的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。