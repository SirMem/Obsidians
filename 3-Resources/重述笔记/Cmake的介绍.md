---
Project: "[[CMake]]"
Status: 🟨
tags:
  - Resources
Deadline: 
CreateTime: 2024-04-17
Connected:
---

# 什么是Cmake
CMake是一个跨平台的开源构建系统，用于管理软件构建过程。它使用一种称为CMakeLists.txt的简单语言来描述项目的构建过程，然后根据此描述生成适合不同操作系统和编译器的构建脚本（如Makefile、Visual Studio项目文件等）。这使得开发者可以在不同的平台上使用同一套构建描述来构建他们的软件，而无需为每个平台单独编写构建脚本。

## 为什么我需要一个好的构建系统？

以下情况是否适用于你？

- 你想避免将路径硬编码
- 你需要在不止一台电脑上构建软件包
- 你想在项目中使用 CI（持续集成）
- 你需要支持不同的操作系统（甚至可能只是 Unix 的不同版本）
- 你想支持多个编译器
- 你想使用 IDE，但也许不总是使用
- 你想从逻辑上描述你的程序是如何结构的，而不是通过某些标志和命令
- 你想使用一个第三方库
- 你想使用工具，比如 Clang-Tidy，来帮助你编码
- 你想使用调试器来 Debug

如果是这样，你会从类似 CMake 的构建系统中受益。

## 为什么答案一定是CMake？

构建系统是一个热门话题。当然，有很多构建系统可选。但是，即使是一个真的非常好的构建系统，或者一个使用类似（CMake）的语法的，也不能达到 CMake 的使用体验。 为什么？ 因为生态。 每个 IDE 都支持 CMake（或者是 CMake 支持那个 IDE）。 使用 CMake 构建的软件包比使用其他任何构建系统的都多。 所以，如果你想要在你的代码中包含一个库，你有两个选择，要么自己写一个构建系统，要么使用该库支持的构建系统中的某个。而那通常包含 CMake。 如何你的工程包含的库多了，CMake 或很快成为那些库所支持的构建系统的交集。并且，如果你使用一个预装在系统中的库，它有很大可能有一个 find CMake 或者是一个 config CMake 的脚本。

## 为什么使用现代的 CMake ？

大概在 CMake 2.6-2.8 时， CMake 开始成为主流。它出现在大多数 Linux 操作系统的包管理器中，并被用于许多包中。

接着 Python 3 出现了。

这是一个直到现在某些的工程中进行的非常艰难、丑陋的迁移。

我知道，这和 CMake 没有任何关系。

但它们有一个 3 ,并且都跟在 2 后面。

所以我相信 CMake 3 跟在 Python 3 后面真是十分倒霉。[1](https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/README_GitBook.html#fn_1) 因为尽管每一个版本的 CMake 都有良好的向后兼容性，但 CMake 3 却总是被当作新事物来对待。 你会发现像 CentOS7 这样的操作系统，其上的 GCC 4.8 几乎完全支持 C++14 ，而 CMake 则是在 C++11 之前几年就已经出现的 CMake 2.8 。

你应该至少使用在你的编译器之后出现的 CMake 版本，因为它需要知道该版本的编译器标志等信息。 而且，由于 CMake 只会启用 CMakeLists.txt 中包含的最低 CMake 版本所对应的特性，所以即使是在系统范围内安装一个新版本的 CMake 也是相当安全的。 你至少应该在本地安装它。这很容易（在许多情况下是 1-2 行命令），你会发现 5 分钟的工作将为你节省数百行和数小时的 CMakeLists.txt 编写，而且从长远来看，将更容易维护