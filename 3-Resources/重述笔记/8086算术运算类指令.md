---
Project: "[[8086汇编]]"
Status: 
tags:
  - Resources
Deadline: 
CreateTime: 
Connected:
---
# 概念
算术运算类指令支持加、减、乘、除等基本算术运算，操作对象可以是字节或字的无符号和有符号的二进制整数，也可以是无符号的压缩、非压缩 BCD 数。非压缩 BCD 数的高 4 位在进行乘/除运算时必须全为 0，进行加/减运算时可以是任何值。

算术运算类指令共 20 条，如表所示。除数据宽度变换指令（CBW，CWD）外，其余指令的执行结果都影响标志位。这些标志位中的绝大多数可供条件转移指令进行测试，以改变程序的流程。掌握指令执行结果对标志位的影响，对编程有重要的作用。

![[Pasted image 20240407203822.png]]

b 运算结果影响标志位；* 标志位为任意值；— 运算结果不影响标志位；① 标志位置 1。

# 二进制算术运算指令
## 加/减法类指令
### 加/减法指令 ADD/SUB
指令格式：ADD OPRD1，OPRD2

SUB OPRD1，OPRD2

功能：完成两个操作数的加/减运算，结果送入目标操作数，即 OPRD1±OPRD2→OPRD1。

具体指令如下：

ADD reg，reg/mem/imm  ；reg←reg+（reg/mem/imm）
ADD mem，reg/imm      ；mem←mem+（reg/imm）
SUB reg，reg/mem/imm  ；reg←reg–（reg/mem/imm）
SUB mem，reg/imm      ；mem←mem–（reg/imm）

要求源操作数和目标操作数同为带符号数或同为无符号数，且长度相等。源操作数可以是寄存器、存储器或立即数，目标操作数只能是寄存器或存储器，且两个操作数不能同时为存储器。运算影响全部状态标志位。

例如：设 AX=65A0H，BX=B79EH，则指令 ADD BX，AX 执行后，BX=1D3EH，CF=1，SF=0，OF=0，AF=0，PF=0，ZF=0。

结果表明，若 BX 和 AX 中是无符号数，则运算结果大于 65535（CF=1）；若 BX 和 AX 中是有符号数，则运算结果在 16 位补码所能表示的范围内（–32768～+32767），运算结果正确（OF=0，SF=0）。

若 AX、BX 中存放的数和上例相同，则指令 SUB AX，BX 执行后，AX=AE02H，CF=1，SF=1，OF=1，AF=1，PF=0，ZF=0。

结果表明，若两个操作数是无符号数，CF=1 表示不够减，运算结果是以 216为模的差值的补码；若两个操作数是有符号数，则运算结果超出 16 位补码所能表示的范围（OF=1），AX 中存放的数（AE02H）并不是正确的运算结果。

### 带进位、借位的加/减法指令 ADC/SBB
指令格式：ADC OPRD1，OPRD2

SBB OPRD1，OPRD2

ADC/SBB 指令常与 ADD/SUB 配合，用于两个或两个以上的多精度数的运算。除了加法操作时加上进位位或减法操作时再减去借位位外，它们同 ADD/SUB 指令的使用注意事项和对标志位的影响情况相同。

具体指令如下：

ADC reg，reg/mem/imm  ；reg←reg+（reg/mem/imm）+CF
ADC mem，reg/imm      ；mem←mem+（reg/imm）+CF
SBB reg，reg/mem/imm  ；reg←reg–（reg/mem/imm）–CF
SBB mem，reg/imm      ；mem←mem–（reg/imm）–CF

例如：有两个 32 位数分别存放在自 FIRST 和 SECOND 开始的存储区中，变量定义如下（DW 是汇编语言伪指令，它为变量 FIRST、SECOND 按字分配存储单元）：

FIRST DW 2211H，4433H   ；定义变量 FIRST=44332211H
SECOND DW 6655H，8877H  ；定义变量 SECOND=88776655H

用字相加指令实现两个变量的和，并将和存放于 FIRST 变量的程序段为：

MOV AX，SECOND     ；取第二个加数的低 16 位 
ADD FIRST，AX      ；与第一个加数的低 16 位相加并存回和，如有进位，则 CF＝1
MOV AX，SECOND+2   ；取 32 位数据 SECOND 的高 16 位 
ADC FIRST+2，AX    ；将两个数的高 16 位相加并加上 CF，和存回 FIRST 的高 16 位

### 增量和减量指令 INC/DEC
指令格式：INC OPRD

DEC OPRD

功能：INC/DEC 是单操作数指令，完成对指定操作数的加 1/减 1，然后返回运算结果。

具体指令如下：

INC reg   ；reg←reg+1   DEC reg  ；reg←reg–1
INC mem   ；mem←mem+1   DEC mem  ；mem←mem–1

设计这两条指令的目的，主要是用于调整地址指针和计数器（循环程序的循环次数），所以它们不影响 CF 标志（即保持此指令之前的值）。对其他 5 个标志位的影响与前述加/减法指令一样。指令中的操作数可以在通用寄存器或内存中。

例如：

INC CX             ；CX 寄存器中的内容加 1
DEC BYTE PTR [BX]  ；将数据段中以 BX 指向的字节存储单元内容减 1
DEC WORD PTR [BX]  ；将数据段中以 BX 指向的字存储单元的内容减 1

### 求补指令 NEG
指令格式：NEG OPRD

功能：对操作数求补。即用零减去操作数，再把结果送回操作数。求补运算也可以表达成：将操作数按位求反加 1。指令执行的效果是改变操作数的符号，但绝对值不变，所以又称为取负指令。具体指令如下：

NEG reg   ；reg ← 0–reg
NEG mem   ；mem ← 0–mem

NEG 指令影响所有状态标志位，不过对 CF 标志的影响为：若操作数不是 0，则总是使 CF 置 1；否则将 CF 清 0。若在字节操作时对-128、或在字操作时对-32768 求补，则操作数没有变化，但溢出标志 OF 置位。

例如：

NEG AL       ；这两条指令实现（100－AL）的运算 
ADD AL，100

### 比较指令 CMP
指令格式：CMP OPRD1，OPRD2

比较指令 CMP 将计算 OPRD1－OPRD2，但运算结果不送回 OPRD1。即 CMP 指令与减法指令 SUB 执行同样的操作，同样影响标志位，只是不改变操作数本身。参加比较的源操作数可以是立即数、寄存器或存储器操作数，目标操作数只能是寄存器或存储器操作数。

具体指令为：

CMP reg，reg/mem/imm  ；reg–（reg/mem/imm）
CMP mem，reg/imm      ；mem–（reg/imm）

比较指令用于比较两个数的大小关系，执行比较指令后，可以根据受影响的标志位状态来判断两个操作数是否相等、谁大、谁小。所以 CMP 指令后面常跟条件转移指令，根据比较结果产生不同的分支转移。判断无符号数和有符号数大小的条件有所不同，列举如下。

● 如果是两个无符号数比较，则可根据进位标志 CF 的状态来判断：

若 CF=1，则 OPRD1＜OPRD2；若 CF=0，则 OPRD1＞OPRD2。

● 如果是两个有符号数比较，则要根据 SF 和 OF 两个标志位的关系来判断：

若 SF⊕OF=1，则 OPRD1＜OPRD2；若 SF⊕OF=0，则 OPRD1＞OPRD2。

● 不管操作数有无符号，若在比较指令后，ZF=1 则 OPRD1=OPRD2；否则不等。

所以，条件转移指令也按无符号数和有符号数分为两类
![[Pasted image 20240407205242.png]]
## 乘/除法指令
### 乘法指令 MUL/IMUL
指令格式：MUL OPRD

IMUL OPRD

MUL 和 IMUL 指令分别用于实现无符号数的乘法和有符号数的乘法运算。它们都只有一个源操作数，源操作数可以是寄存器或存储器，而目标操作数隐含规定在累加器中。

具体的指令如下：

MUL reg 或 IMUL reg    ；AX←AL×reg8（或 DX，AX←AX×reg16）
MUL mem 或 IMUL mem    ；AX←AL×mem8（或 DX，AX←AX×mem16）

MUL 指令用于无符号二进制数乘法运算。若为字节（OPRD 为字节）乘法，则 AL×OPRD，乘积存于 AX 中；若为字（OPRD 为字）乘法，则 AX×OPRD，乘积的高 16 位存放在 DX 中，低 16 位存放在 AX 中。当乘积的高半部分（字节相乘时为 AH；字相乘时为 DX）不为 0，则标志 CF=OF=1，表示在 AH 或 DX 中存有乘积的有效数值；否则，CF=OF=0。而其他状态标志位的内容不确定。

IMUL 指令除了完成两个有符号数的相乘以外，其他与 MUL 完全类似。若乘积的高半部分（字节相乘时为 AH，字相乘时为 DX）存有积的有效数值（不光是符号部分），则 CF=OF=1；否则 CF=OF=0，表示高半部分全部是低半部分符号位的扩展。

由于乘法指令为乘积保留了 2 倍于原来操作数的存储空间，因而不会出现溢出现象。

### 除法指令 DIV/IDIV
指令格式：DIV OPRD

IDIV OPRD

DIV 和 IDIV 分别用来实现无符号数的除法和有符号数的除法运算。指令中对操作数的规定同乘法指令，除法指令执行后，所有的状态标志位都不确定。

具体的指令如下：

DIV reg 或 IDIV reg    ；AH，AL←AX/reg8（或 DX，AX←DX:AX/reg16）
DIV mem 或 IDIV mem    ；AH，AL←AX/mem8（或 DX，AX←DX:AX/mem16）

DIV 用于无符号数的除法运算。对字节除法，被除数在 AX 中，除数即 OPRD（字节），商在 AL 中，余数在 AH 中；对字除法，被除数高位在 DX 中，低位在 AX 中，除数即 OPRD（字），商在 AX 中，余数在 DX 中。若商超过存放它的寄存器的容量（字节相除时为 FFH，字相除时为 FFFFH），则引起 0 型中断（即除法出错中断），且商和余数为不定值。

IDIV 除了完成有符号数相除以外，其余与 DIV 完全类似。商的符号根据代数符号的规则确定，余数的符号与被除数的相同。在字节相除时，最大的商是 +127（7FH），最小的负数商是-127（81H）；在字相除时，最大的商为 32767（7FFFH），最小的负数商是-32767（8001H）。若相除以后，商超出上述讨论值的范围，则商和余数的值不能确定，并产生一个 0 型中断。

注意：在除法运算中，要求被除数的长度为除数长度的 2 倍。若被除数和除数是具有相同位数的字节或字，这时就需要将被除数扩展为字或双字，且大小和符号不变，然后再相除。

# 符号扩展指令 CBW/CWD
指令格式：CBW
CWD

功能：CBW 和 CWD 分别用于将有符号操作数从字节转换成字或从字转换为双字，操作数隐含规定在累加器中。CBW 将 AL 中的字节符号数的符号扩展到 AH 中，CWD 将 AX 中的字符号数的符号扩展到 DX 中。CBW 和 CWD 指令都不影响任何标志位。扩展规则如下：

（1）若 AL ＜ 80H，则 AH←0；若 AL≥80H，则 AH←FFH。

（2）若 AX ＜ 8000H，则 DX←0；若 AX≥8000H，则 DX←FFFFH。

例如：求 0BF4H÷0100H（带符号数相除）。由于除数为字，则必须将被除数进行符号扩展后才能相除。程序段如下：

MOV  AX，0BF4H
CWD              ；被除数扩展为 DX:AX＝0000 0BF4H
MOV  BX，0100H
IDIV BX          ；AX← 商 0BH，DX← 余数 F4H

注意：对无符号数，可采用直接使高位置「0」的方法进行扩展。

# BCD（十进制）运算调整指令
CPU 中的 ALU 单元只能执行二进制数的算术操作。对于 BCD 数的算术运算，可以直接使用二进制数的算术运算指令，但必须在二进制算术运算指令之后，紧接着用一条调整指令来加以校正调整。所有的调整指令都隐含操作数在累加器中，对标志位的影响如表所示。
![[Pasted image 20240407205457.png]]
（1）非压缩 BCD 数加/减法调整指令 AAA/AAS

AAA/AAS 用于将 AL 中的由两个非压缩 BCD 数相加/减后的结果进行调整，以得到正确的非压缩 BCD 和/差。程序中它们紧跟在 ADD（或 ADC）/SUB（或 SBB）指令之后。

AAA/AAS 指令完成如下调整操作：

 若 （AL&0FH）＞9 或 标志 AF=1，则 
     AL←AL±6，AH←AH±1，AF←1，CF←AF，AL←AL&0FH （「-」号对指令 AAS 而言）

（2）压缩 BCD 数加/减法调整指令 DAA/DAS

DAA/DAS 用于将 AL 中两个压缩 BCD 数相加/减的结果进行校正，以得到正确的压缩 BCD 和/差。程序中它们紧跟在 ADD（或 ADC）/SUB（或 SBB）指令之后。

DAA/DAS 指令完成如下调整操作：

 若 （AL&0FH）＞9 或 AF=1，则 AL←AL±6，AF←1 （「-」号仅对 DAS 而言）
 若 AL＞9FH 或 CF=1，则 AL← AL±60H，CF←1 （「-」号仅对 DAS 而言）

例如：AL=47H（十进制数 47 的 BCD 码），BH=25H（十进制数 25 的 BCD 码），用下列指令可得到这两个数和的正确结果。

ADD AL，BH  ；AL←AL+BH
DAA         ；将 AL 的内容调整为 72H

应该注意，所有的调整指令仅用来对一次加/减运算的结果 AL 进行调整。因而对多位压缩或非压缩的 BCD 数的运算，必须由低位向高位逐个进行调整。

【例 3-1】 计算（8576）10+（2695）10。假设两个操作数分别存于 AX、BX，即 AX=8576H，BX=2695H，则下列程序段将实现两个数的求和运算，结果放在 AX 中。

ADD AL，BL
DAA
MOV DL，AL   ；暂存低字节压缩 BCD 数在 DL 中 
MOV AL，AH
ADC AL，BH
DAA
MOV AH，AL   ；高字节压缩 BCD 数在 AH 中 
MOV AL，DL   ；压缩 BCD 数的和在 AX 中 

（3）非压缩 BCD 数乘/除法调整指令 AAM/AAD

AAM 紧跟在 MUL 指令之后，将 AX 中两个 1 位非压缩 BCD 数相乘的结果进行调整，得到正确的非压缩 BCD 的乘积（高位在 AH 中，低位在 AL 中）。调整操作为：

AH ← AX/0AH  ；AX 被 0AH 除的商 →AH
AL ← AX%0AH  ；AX 被 0AH 除的余数 →AL

例如：

MOV AL，07H
MOV BL，09H
MUL BL        ；执行乘法指令后 AX=003FH
AAM           ；执行乘法调整指令后 AX=0603H

AAD 指令用来在进行两个非压缩 BCD 数的除法运算之前，先调整 AL 和 AH 中的内容，再用二进制除法指令 DIV 相除。相除以后，以非压缩 BCD 数表示的商在 AL 中，而相应的余数在 AH 中。调整操作为：

AL←AH×0AH+AL，AH←0

例如：设 AX=0103H，BL=06H（分别表示非压缩 BCD 数 13 和 6）。

AAD         ；先调整得 AX=000DH
DIV BL      ；执行除法指令后，商 AL=02H，余数 AH=1

